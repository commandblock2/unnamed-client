diff --git a/mcp918.iml b/mcp918.iml
index 20cf5d5..1718dab 100644
--- a/mcp918.iml
+++ b/mcp918.iml
@@ -16,9 +16,12 @@
     <exclude-output />
     <content url="file://$MODULE_DIR$/../idea-project" />
     <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/src/embeddedlibs" isTestSource="false" />
       <sourceFolder url="file://$MODULE_DIR$/src/minecraft" isTestSource="false" />
     </content>
+    <content url="file://$MODULE_DIR$/../src">
+      <sourceFolder url="file://$MODULE_DIR$/../src/embeddedlibs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/../src/unnamed-client" isTestSource="false" />
+    </content>
     <orderEntry type="sourceFolder" forTests="false" />
     <orderEntry type="library" name="libraryjavasound-20101123" level="project" />
     <orderEntry type="inheritedJdk" />
diff --git a/src/embeddedlibs/net/minecraft/client/audio/FUCKLWJGL3/ChannelLWJGL3OpenAL.java b/src/embeddedlibs/net/minecraft/client/audio/FUCKLWJGL3/ChannelLWJGL3OpenAL.java
deleted file mode 100644
index 4899cef..0000000
--- a/src/embeddedlibs/net/minecraft/client/audio/FUCKLWJGL3/ChannelLWJGL3OpenAL.java
+++ /dev/null
@@ -1,385 +0,0 @@
-//
-// Source code recreated from a .class file by IntelliJ IDEA
-// (powered by FernFlower decompiler)
-//
-
-package net.minecraft.client.audio.FUCKLWJGL3;
-
-import java.nio.ByteBuffer;
-import java.nio.IntBuffer;
-import java.util.LinkedList;
-import javax.sound.sampled.AudioFormat;
-import org.lwjgl.BufferUtils;
-import org.lwjgl.openal.AL10;
-import paulscode.sound.Channel;
-
-public class ChannelLWJGL3OpenAL extends Channel {
-    public IntBuffer ALSource;
-    public int ALformat;
-    public int sampleRate;
-    public float millisPreviouslyPlayed = 0.0F;
-
-    public ChannelLWJGL3OpenAL(int type, IntBuffer src) {
-        super(type);
-        this.libraryType = SoundEngine.class;
-        this.ALSource = src;
-    }
-
-    public void cleanup() {
-        if (this.ALSource != null) {
-            try {
-                AL10.alSourceStopv(this.ALSource);
-                AL10.alGetError();
-            } catch (Exception var3) {
-            }
-
-            try {
-                AL10.alDeleteSources(this.ALSource);
-                AL10.alGetError();
-            } catch (Exception var2) {
-            }
-
-            this.ALSource.clear();
-        }
-
-        this.ALSource = null;
-        super.cleanup();
-    }
-
-    public boolean attachBuffer(IntBuffer buf) {
-        if (this.errorCheck(this.channelType != 0, "Sound buffers may only be attached to normal sources.")) {
-            return false;
-        } else {
-            AL10.alSourcei(this.ALSource.get(0), 4105, buf.get(0));
-            if (this.attachedSource != null && this.attachedSource.soundBuffer != null && this.attachedSource.soundBuffer.audioFormat != null) {
-                this.setAudioFormat(this.attachedSource.soundBuffer.audioFormat);
-            }
-
-            return this.checkALError();
-        }
-    }
-
-    public void setAudioFormat(AudioFormat audioFormat) {
-        short soundFormat = 0;
-        if (audioFormat.getChannels() == 1) {
-            if (audioFormat.getSampleSizeInBits() == 8) {
-                soundFormat = 4352;
-            } else {
-                if (audioFormat.getSampleSizeInBits() != 16) {
-                    this.errorMessage("Illegal sample size in method 'setAudioFormat'");
-                    return;
-                }
-
-                soundFormat = 4353;
-            }
-        } else {
-            if (audioFormat.getChannels() != 2) {
-                this.errorMessage("Audio data neither mono nor stereo in method 'setAudioFormat'");
-                return;
-            }
-
-            if (audioFormat.getSampleSizeInBits() == 8) {
-                soundFormat = 4354;
-            } else {
-                if (audioFormat.getSampleSizeInBits() != 16) {
-                    this.errorMessage("Illegal sample size in method 'setAudioFormat'");
-                    return;
-                }
-
-                soundFormat = 4355;
-            }
-        }
-
-        this.ALformat = soundFormat;
-        this.sampleRate = (int)audioFormat.getSampleRate();
-    }
-
-    public void setFormat(int format, int rate) {
-        this.ALformat = format;
-        this.sampleRate = rate;
-    }
-
-    public boolean preLoadBuffers(LinkedList<byte[]> bufferList) {
-        if (this.errorCheck(this.channelType != 1, "Buffers may only be queued for streaming sources.")) {
-            return false;
-        } else if (this.errorCheck(bufferList == null, "Buffer List null in method 'preLoadBuffers'")) {
-            return false;
-        } else {
-            boolean playing = this.playing();
-            if (playing) {
-                AL10.alSourceStop(this.ALSource.get(0));
-                this.checkALError();
-            }
-
-            int processed = AL10.alGetSourcei(this.ALSource.get(0), 4118);
-            IntBuffer streamBuffers;
-            if (processed > 0) {
-                streamBuffers = BufferUtils.createIntBuffer(processed);
-                AL10.alGenBuffers(streamBuffers);
-                if (this.errorCheck(this.checkALError(), "Error clearing stream buffers in method 'preLoadBuffers'")) {
-                    return false;
-                }
-
-                AL10.alSourceUnqueueBuffers(this.ALSource.get(0), streamBuffers);
-                if (this.errorCheck(this.checkALError(), "Error unqueuing stream buffers in method 'preLoadBuffers'")) {
-                    return false;
-                }
-            }
-
-            if (playing) {
-                AL10.alSourcePlay(this.ALSource.get(0));
-                this.checkALError();
-            }
-
-            streamBuffers = BufferUtils.createIntBuffer(bufferList.size());
-            AL10.alGenBuffers(streamBuffers);
-            if (this.errorCheck(this.checkALError(), "Error generating stream buffers in method 'preLoadBuffers'")) {
-                return false;
-            } else {
-                ByteBuffer byteBuffer = null;
-
-                for(int i = 0; i < bufferList.size(); ++i) {
-                    byteBuffer = (ByteBuffer)BufferUtils.createByteBuffer(((byte[])bufferList.get(i)).length).put((byte[])bufferList.get(i)).flip();
-
-                    try {
-                        AL10.alBufferData(streamBuffers.get(i), this.ALformat, byteBuffer, this.sampleRate);
-                    } catch (Exception var9) {
-                        this.errorMessage("Error creating buffers in method 'preLoadBuffers'");
-                        this.printStackTrace(var9);
-                        return false;
-                    }
-
-                    if (this.errorCheck(this.checkALError(), "Error creating buffers in method 'preLoadBuffers'")) {
-                        return false;
-                    }
-                }
-
-                try {
-                    AL10.alSourceQueueBuffers(this.ALSource.get(0), streamBuffers);
-                } catch (Exception var8) {
-                    this.errorMessage("Error queuing buffers in method 'preLoadBuffers'");
-                    this.printStackTrace(var8);
-                    return false;
-                }
-
-                if (this.errorCheck(this.checkALError(), "Error queuing buffers in method 'preLoadBuffers'")) {
-                    return false;
-                } else {
-                    AL10.alSourcePlay(this.ALSource.get(0));
-                    return !this.errorCheck(this.checkALError(), "Error playing source in method 'preLoadBuffers'");
-                }
-            }
-        }
-    }
-
-    public boolean queueBuffer(byte[] buffer) {
-        if (this.errorCheck(this.channelType != 1, "Buffers may only be queued for streaming sources.")) {
-            return false;
-        } else {
-            ByteBuffer byteBuffer = (ByteBuffer)BufferUtils.createByteBuffer(buffer.length).put(buffer).flip();
-            IntBuffer intBuffer = BufferUtils.createIntBuffer(1);
-            AL10.alSourceUnqueueBuffers(this.ALSource.get(0), intBuffer);
-            if (this.checkALError()) {
-                return false;
-            } else {
-                if (AL10.alIsBuffer(intBuffer.get(0))) {
-                    this.millisPreviouslyPlayed += this.millisInBuffer(intBuffer.get(0));
-                }
-
-                this.checkALError();
-                AL10.alBufferData(intBuffer.get(0), this.ALformat, byteBuffer, this.sampleRate);
-                if (this.checkALError()) {
-                    return false;
-                } else {
-                    AL10.alSourceQueueBuffers(this.ALSource.get(0), intBuffer);
-                    return !this.checkALError();
-                }
-            }
-        }
-    }
-
-    public int feedRawAudioData(byte[] buffer) {
-        if (this.errorCheck(this.channelType != 1, "Raw audio data can only be fed to streaming sources.")) {
-            return -1;
-        } else {
-            ByteBuffer byteBuffer = (ByteBuffer)BufferUtils.createByteBuffer(buffer.length).put(buffer).flip();
-            int processed = AL10.alGetSourcei(this.ALSource.get(0), 4118);
-            IntBuffer intBuffer;
-            if (processed > 0) {
-                intBuffer = BufferUtils.createIntBuffer(processed);
-                AL10.alGenBuffers(intBuffer);
-                if (this.errorCheck(this.checkALError(), "Error clearing stream buffers in method 'feedRawAudioData'")) {
-                    return -1;
-                }
-
-                AL10.alSourceUnqueueBuffers(this.ALSource.get(0), intBuffer);
-                if (this.errorCheck(this.checkALError(), "Error unqueuing stream buffers in method 'feedRawAudioData'")) {
-                    return -1;
-                }
-
-                if (AL10.alIsBuffer(intBuffer.get(0))) {
-                    this.millisPreviouslyPlayed += this.millisInBuffer(intBuffer.get(0));
-                }
-
-                this.checkALError();
-            } else {
-                intBuffer = BufferUtils.createIntBuffer(1);
-                AL10.alGenBuffers(intBuffer);
-                if (this.errorCheck(this.checkALError(), "Error generating stream buffers in method 'preLoadBuffers'")) {
-                    return -1;
-                }
-            }
-
-            AL10.alBufferData(intBuffer.get(0), this.ALformat, byteBuffer, this.sampleRate);
-            if (this.checkALError()) {
-                return -1;
-            } else {
-                AL10.alSourceQueueBuffers(this.ALSource.get(0), intBuffer);
-                if (this.checkALError()) {
-                    return -1;
-                } else {
-                    if (this.attachedSource != null && this.attachedSource.channel == this && this.attachedSource.active() && !this.playing()) {
-                        AL10.alSourcePlay(this.ALSource.get(0));
-                        this.checkALError();
-                    }
-
-                    return processed;
-                }
-            }
-        }
-    }
-
-    public float millisInBuffer(int alBufferi) {
-        return (float)AL10.alGetBufferi(alBufferi, 8196) / (float)AL10.alGetBufferi(alBufferi, 8195) / ((float)AL10.alGetBufferi(alBufferi, 8194) / 8.0F) / (float)this.sampleRate * 1000.0F;
-    }
-
-    public float millisecondsPlayed() {
-        float offset = (float)AL10.alGetSourcei(this.ALSource.get(0), 4134);
-        float bytesPerFrame = 1.0F;
-        switch(this.ALformat) {
-            case 4352:
-                bytesPerFrame = 1.0F;
-                break;
-            case 4353:
-                bytesPerFrame = 2.0F;
-                break;
-            case 4354:
-                bytesPerFrame = 2.0F;
-                break;
-            case 4355:
-                bytesPerFrame = 4.0F;
-        }
-
-        offset = offset / bytesPerFrame / (float)this.sampleRate * 1000.0F;
-        if (this.channelType == 1) {
-            offset += this.millisPreviouslyPlayed;
-        }
-
-        return offset;
-    }
-
-    public int buffersProcessed() {
-        if (this.channelType != 1) {
-            return 0;
-        } else {
-            int processed = AL10.alGetSourcei(this.ALSource.get(0), 4118);
-            return this.checkALError() ? 0 : processed;
-        }
-    }
-
-    public void flush() {
-        if (this.channelType == 1) {
-            int queued = AL10.alGetSourcei(this.ALSource.get(0), 4117);
-            if (!this.checkALError()) {
-                for(IntBuffer intBuffer = BufferUtils.createIntBuffer(1); queued > 0; --queued) {
-                    try {
-                        AL10.alSourceUnqueueBuffers(this.ALSource.get(0), intBuffer);
-                    } catch (Exception var4) {
-                        return;
-                    }
-
-                    if (this.checkALError()) {
-                        return;
-                    }
-                }
-
-                this.millisPreviouslyPlayed = 0.0F;
-            }
-        }
-    }
-
-    public void close() {
-        try {
-            AL10.alSourceStop(this.ALSource.get(0));
-            AL10.alGetError();
-        } catch (Exception var2) {
-        }
-
-        if (this.channelType == 1) {
-            this.flush();
-        }
-
-    }
-
-    public void play() {
-        AL10.alSourcePlay(this.ALSource.get(0));
-        this.checkALError();
-    }
-
-    public void pause() {
-        AL10.alSourcePause(this.ALSource.get(0));
-        this.checkALError();
-    }
-
-    public void stop() {
-        AL10.alSourceStop(this.ALSource.get(0));
-        if (!this.checkALError()) {
-            this.millisPreviouslyPlayed = 0.0F;
-        }
-
-    }
-
-    public void rewind() {
-        if (this.channelType != 1) {
-            AL10.alSourceRewind(this.ALSource.get(0));
-            if (!this.checkALError()) {
-                this.millisPreviouslyPlayed = 0.0F;
-            }
-
-        }
-    }
-
-    public boolean playing() {
-        int state = AL10.alGetSourcei(this.ALSource.get(0), 4112);
-        if (this.checkALError()) {
-            return false;
-        } else {
-            return state == 4114;
-        }
-    }
-
-    private boolean checkALError() {
-        switch(AL10.alGetError()) {
-            case 0:
-                return false;
-            case 40961:
-                this.errorMessage("Invalid name parameter.");
-                return true;
-            case 40962:
-                this.errorMessage("Invalid parameter.");
-                return true;
-            case 40963:
-                this.errorMessage("Invalid enumerated parameter value.");
-                return true;
-            case 40964:
-                this.errorMessage("Illegal call.");
-                return true;
-            case 40965:
-                this.errorMessage("Unable to allocate memory.");
-                return true;
-            default:
-                this.errorMessage("An unrecognized error occurred.");
-                return true;
-        }
-    }
-}
diff --git a/src/embeddedlibs/net/minecraft/client/audio/FUCKLWJGL3/SoundEngine.java b/src/embeddedlibs/net/minecraft/client/audio/FUCKLWJGL3/SoundEngine.java
deleted file mode 100644
index 27cae1a..0000000
--- a/src/embeddedlibs/net/minecraft/client/audio/FUCKLWJGL3/SoundEngine.java
+++ /dev/null
@@ -1,561 +0,0 @@
-package net.minecraft.client.audio.FUCKLWJGL3;
-
-import java.net.URL;
-import java.nio.ByteBuffer;
-import java.nio.FloatBuffer;
-import java.nio.IntBuffer;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Set;
-import javax.sound.sampled.AudioFormat;
-
-import org.lwjgl.BufferUtils;
-import org.lwjgl.LWJGLException;
-import org.lwjgl.openal.AL;
-import org.lwjgl.openal.AL10;
-import org.lwjgl.openal.ALC;
-import org.lwjgl.openal.ALCCapabilities;
-import paulscode.sound.Channel;
-import paulscode.sound.FilenameURL;
-import paulscode.sound.ICodec;
-import paulscode.sound.Library;
-import paulscode.sound.ListenerData;
-import paulscode.sound.SoundBuffer;
-import paulscode.sound.SoundSystemConfig;
-import paulscode.sound.SoundSystemException;
-import paulscode.sound.Source;
-
-import static org.lwjgl.openal.ALC10.*;
-
-public class SoundEngine extends Library {
-    private static final boolean GET = false;
-    private static final boolean SET = true;
-    private static final boolean XXX = false;
-    private FloatBuffer listenerPositionAL = null;
-    private FloatBuffer listenerOrientation = null;
-    private FloatBuffer listenerVelocity = null;
-    private HashMap<String, IntBuffer> ALBufferMap = null;
-    private static boolean alPitchSupported = true;
-
-    long device;
-
-    public SoundEngine() throws SoundSystemException {
-        this.ALBufferMap = new HashMap();
-        this.reverseByteOrder = true;
-    }
-
-    public void init() throws SoundSystemException {
-        boolean errors = false;
-
-        device = alcOpenDevice((ByteBuffer) null);
-        ALCCapabilities deviceCaps = ALC.createCapabilities(device);
-
-        long context = alcCreateContext(device, (IntBuffer) null);
-        alcMakeContextCurrent(context);
-        AL.createCapabilities(deviceCaps);
-        errors = this.checkALError();
-
-        if (errors) {
-            this.importantMessage("OpenAL did not initialize properly!");
-        } else {
-            this.message("OpenAL initialized.");
-        }
-
-        this.listenerPositionAL = BufferUtils.createFloatBuffer(3).put(new float[]{this.listener.position.x, this.listener.position.y, this.listener.position.z});
-        this.listenerOrientation = BufferUtils.createFloatBuffer(6).put(new float[]{this.listener.lookAt.x, this.listener.lookAt.y, this.listener.lookAt.z, this.listener.up.x, this.listener.up.y, this.listener.up.z});
-        this.listenerVelocity = BufferUtils.createFloatBuffer(3).put(new float[]{0.0F, 0.0F, 0.0F});
-        this.listenerPositionAL.flip();
-        this.listenerOrientation.flip();
-        this.listenerVelocity.flip();
-        AL10.alListenerfv(4100, this.listenerPositionAL);
-        errors = this.checkALError() || errors;
-        AL10.alListenerfv(4111, this.listenerOrientation);
-        errors = this.checkALError() || errors;
-        AL10.alListenerfv(4102, this.listenerVelocity);
-        errors = this.checkALError() || errors;
-        AL10.alDopplerFactor(SoundSystemConfig.getDopplerFactor());
-        errors = this.checkALError() || errors;
-        AL10.alDopplerVelocity(SoundSystemConfig.getDopplerVelocity());
-        errors = this.checkALError() || errors;
-        if (errors) {
-            this.importantMessage("OpenAL did not initialize properly!");
-            throw new SoundEngine.Exception("Problem encountered while loading OpenAL or creating the listener.  Probable cause:  OpenAL not supported", 101);
-        } else {
-            super.init();
-            ChannelLWJGL3OpenAL channel = (ChannelLWJGL3OpenAL) this.normalChannels.get(1);
-
-            try {
-                AL10.alSourcef(channel.ALSource.get(0), 4099, 1.0F);
-                if (this.checkALError()) {
-                    alPitchSupported(true, false);
-                    throw new SoundEngine.Exception("OpenAL: AL_PITCH not supported.", 108);
-                } else {
-                    alPitchSupported(true, true);
-                }
-            } catch (java.lang.Exception var4) {
-                alPitchSupported(true, false);
-                throw new SoundEngine.Exception("OpenAL: AL_PITCH not supported.", 108);
-            }
-        }
-    }
-
-    // TODO somethinghere
-    public static boolean libraryCompatible() {
-        return true;
-    }
-
-    protected Channel createChannel(int type) {
-        IntBuffer ALSource = BufferUtils.createIntBuffer(1);
-
-        try {
-            AL10.alGenSources(ALSource);
-        } catch (java.lang.Exception var5) {
-            AL10.alGetError();
-            return null;
-        }
-
-        if (AL10.alGetError() != 0) {
-            return null;
-        } else {
-            ChannelLWJGL3OpenAL channel = new ChannelLWJGL3OpenAL(type, ALSource);
-            return channel;
-        }
-    }
-
-    public void cleanup() {
-        super.cleanup();
-        Set<String> keys = this.bufferMap.keySet();
-        Iterator iter = keys.iterator();
-
-        while (iter.hasNext()) {
-            String filename = (String) iter.next();
-            IntBuffer buffer = (IntBuffer) this.ALBufferMap.get(filename);
-            if (buffer != null) {
-                AL10.alDeleteBuffers(buffer);
-                this.checkALError();
-                buffer.clear();
-            }
-        }
-
-        this.bufferMap.clear();
-        alcCloseDevice(device);
-        this.bufferMap = null;
-        this.listenerPositionAL = null;
-        this.listenerOrientation = null;
-        this.listenerVelocity = null;
-    }
-
-    public boolean loadSound(FilenameURL filenameURL) {
-        if (this.bufferMap == null) {
-            this.bufferMap = new HashMap();
-            this.importantMessage("Buffer Map was null in method 'loadSound'");
-        }
-
-        if (this.ALBufferMap == null) {
-            this.ALBufferMap = new HashMap();
-            this.importantMessage("Open AL Buffer Map was null in method'loadSound'");
-        }
-
-        if (this.errorCheck(filenameURL == null, "Filename/URL not specified in method 'loadSound'")) {
-            return false;
-        } else if (this.bufferMap.get(filenameURL.getFilename()) != null) {
-            return true;
-        } else {
-            ICodec codec = SoundSystemConfig.getCodec(filenameURL.getFilename());
-            if (this.errorCheck(codec == null, "No codec found for file '" + filenameURL.getFilename() + "' in method 'loadSound'")) {
-                return false;
-            } else {
-                codec.reverseByteOrder(true);
-                URL url = filenameURL.getURL();
-                if (this.errorCheck(url == null, "Unable to open file '" + filenameURL.getFilename() + "' in method 'loadSound'")) {
-                    return false;
-                } else {
-                    codec.initialize(url);
-                    SoundBuffer buffer = codec.readAll();
-                    codec.cleanup();
-                    codec = null;
-                    if (this.errorCheck(buffer == null, "Sound buffer null in method 'loadSound'")) {
-                        return false;
-                    } else {
-                        this.bufferMap.put(filenameURL.getFilename(), buffer);
-                        AudioFormat audioFormat = buffer.audioFormat;
-                        short soundFormat = 0;
-                        if (audioFormat.getChannels() == 1) {
-                            if (audioFormat.getSampleSizeInBits() == 8) {
-                                soundFormat = 4352;
-                            } else {
-                                if (audioFormat.getSampleSizeInBits() != 16) {
-                                    this.errorMessage("Illegal sample size in method 'loadSound'");
-                                    return false;
-                                }
-
-                                soundFormat = 4353;
-                            }
-                        } else {
-                            if (audioFormat.getChannels() != 2) {
-                                this.errorMessage("File neither mono nor stereo in method 'loadSound'");
-                                return false;
-                            }
-
-                            if (audioFormat.getSampleSizeInBits() == 8) {
-                                soundFormat = 4354;
-                            } else {
-                                if (audioFormat.getSampleSizeInBits() != 16) {
-                                    this.errorMessage("Illegal sample size in method 'loadSound'");
-                                    return false;
-                                }
-
-                                soundFormat = 4355;
-                            }
-                        }
-
-                        IntBuffer intBuffer = BufferUtils.createIntBuffer(1);
-                        AL10.alGenBuffers(intBuffer);
-                        if (this.errorCheck(AL10.alGetError() != 0, "alGenBuffers error when loading " + filenameURL.getFilename())) {
-                            return false;
-                        } else {
-                            AL10.alBufferData(intBuffer.get(0), soundFormat, (ByteBuffer) BufferUtils.createByteBuffer(buffer.audioData.length).put(buffer.audioData).flip(), (int) audioFormat.getSampleRate());
-                            if (this.errorCheck(AL10.alGetError() != 0, "alBufferData error when loading " + filenameURL.getFilename()) && this.errorCheck(intBuffer == null, "Sound buffer was not created for " + filenameURL.getFilename())) {
-                                return false;
-                            } else {
-                                this.ALBufferMap.put(filenameURL.getFilename(), intBuffer);
-                                return true;
-                            }
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    public boolean loadSound(SoundBuffer buffer, String identifier) {
-        if (this.bufferMap == null) {
-            this.bufferMap = new HashMap();
-            this.importantMessage("Buffer Map was null in method 'loadSound'");
-        }
-
-        if (this.ALBufferMap == null) {
-            this.ALBufferMap = new HashMap();
-            this.importantMessage("Open AL Buffer Map was null in method'loadSound'");
-        }
-
-        if (this.errorCheck(identifier == null, "Identifier not specified in method 'loadSound'")) {
-            return false;
-        } else if (this.bufferMap.get(identifier) != null) {
-            return true;
-        } else if (this.errorCheck(buffer == null, "Sound buffer null in method 'loadSound'")) {
-            return false;
-        } else {
-            this.bufferMap.put(identifier, buffer);
-            AudioFormat audioFormat = buffer.audioFormat;
-            short soundFormat = 0;
-            if (audioFormat.getChannels() == 1) {
-                if (audioFormat.getSampleSizeInBits() == 8) {
-                    soundFormat = 4352;
-                } else {
-                    if (audioFormat.getSampleSizeInBits() != 16) {
-                        this.errorMessage("Illegal sample size in method 'loadSound'");
-                        return false;
-                    }
-
-                    soundFormat = 4353;
-                }
-            } else {
-                if (audioFormat.getChannels() != 2) {
-                    this.errorMessage("File neither mono nor stereo in method 'loadSound'");
-                    return false;
-                }
-
-                if (audioFormat.getSampleSizeInBits() == 8) {
-                    soundFormat = 4354;
-                } else {
-                    if (audioFormat.getSampleSizeInBits() != 16) {
-                        this.errorMessage("Illegal sample size in method 'loadSound'");
-                        return false;
-                    }
-
-                    soundFormat = 4355;
-                }
-            }
-
-            IntBuffer intBuffer = BufferUtils.createIntBuffer(1);
-            AL10.alGenBuffers(intBuffer);
-            if (this.errorCheck(AL10.alGetError() != 0, "alGenBuffers error when saving " + identifier)) {
-                return false;
-            } else {
-                AL10.alBufferData(intBuffer.get(0), soundFormat, (ByteBuffer) BufferUtils.createByteBuffer(buffer.audioData.length).put(buffer.audioData).flip(), (int) audioFormat.getSampleRate());
-                if (this.errorCheck(AL10.alGetError() != 0, "alBufferData error when saving " + identifier) && this.errorCheck(intBuffer == null, "Sound buffer was not created for " + identifier)) {
-                    return false;
-                } else {
-                    this.ALBufferMap.put(identifier, intBuffer);
-                    return true;
-                }
-            }
-        }
-    }
-
-    public void unloadSound(String filename) {
-        this.ALBufferMap.remove(filename);
-        super.unloadSound(filename);
-    }
-
-    public void setMasterVolume(float value) {
-        super.setMasterVolume(value);
-        AL10.alListenerf(4106, value);
-        this.checkALError();
-    }
-
-    public void newSource(boolean priority, boolean toStream, boolean toLoop, String sourcename, FilenameURL filenameURL, float x, float y, float z, int attModel, float distOrRoll) {
-        IntBuffer myBuffer = null;
-        if (!toStream) {
-            myBuffer = (IntBuffer) this.ALBufferMap.get(filenameURL.getFilename());
-            if (myBuffer == null && !this.loadSound(filenameURL)) {
-                this.errorMessage("Source '" + sourcename + "' was not created " + "because an error occurred while loading " + filenameURL.getFilename());
-                return;
-            }
-
-            myBuffer = (IntBuffer) this.ALBufferMap.get(filenameURL.getFilename());
-            if (myBuffer == null) {
-                this.errorMessage("Source '" + sourcename + "' was not created " + "because a sound buffer was not found for " + filenameURL.getFilename());
-                return;
-            }
-        }
-
-        SoundBuffer buffer = null;
-        if (!toStream) {
-            buffer = (SoundBuffer) this.bufferMap.get(filenameURL.getFilename());
-            if (buffer == null && !this.loadSound(filenameURL)) {
-                this.errorMessage("Source '" + sourcename + "' was not created " + "because an error occurred while loading " + filenameURL.getFilename());
-                return;
-            }
-
-            buffer = (SoundBuffer) this.bufferMap.get(filenameURL.getFilename());
-            if (buffer == null) {
-                this.errorMessage("Source '" + sourcename + "' was not created " + "because audio data was not found for " + filenameURL.getFilename());
-                return;
-            }
-        }
-
-        this.sourceMap.put(sourcename, new SourceLWJGL3OpenAL(this.listenerPositionAL, myBuffer, priority, toStream, toLoop, sourcename, filenameURL, buffer, x, y, z, attModel, distOrRoll, false));
-    }
-
-    public void rawDataStream(AudioFormat audioFormat, boolean priority, String sourcename, float x, float y, float z, int attModel, float distOrRoll) {
-        this.sourceMap.put(sourcename, new SourceLWJGL3OpenAL(this.listenerPositionAL, audioFormat, priority, sourcename, x, y, z, attModel, distOrRoll));
-    }
-
-    public void quickPlay(boolean priority, boolean toStream, boolean toLoop, String sourcename, FilenameURL filenameURL, float x, float y, float z, int attModel, float distOrRoll, boolean temporary) {
-        IntBuffer myBuffer = null;
-        if (!toStream) {
-            myBuffer = (IntBuffer) this.ALBufferMap.get(filenameURL.getFilename());
-            if (myBuffer == null) {
-                this.loadSound(filenameURL);
-            }
-
-            myBuffer = (IntBuffer) this.ALBufferMap.get(filenameURL.getFilename());
-            if (myBuffer == null) {
-                this.errorMessage("Sound buffer was not created for " + filenameURL.getFilename());
-                return;
-            }
-        }
-
-        SoundBuffer buffer = null;
-        if (!toStream) {
-            buffer = (SoundBuffer) this.bufferMap.get(filenameURL.getFilename());
-            if (buffer == null && !this.loadSound(filenameURL)) {
-                this.errorMessage("Source '" + sourcename + "' was not created " + "because an error occurred while loading " + filenameURL.getFilename());
-                return;
-            }
-
-            buffer = (SoundBuffer) this.bufferMap.get(filenameURL.getFilename());
-            if (buffer == null) {
-                this.errorMessage("Source '" + sourcename + "' was not created " + "because audio data was not found for " + filenameURL.getFilename());
-                return;
-            }
-        }
-
-        SourceLWJGL3OpenAL s = new SourceLWJGL3OpenAL(this.listenerPositionAL, myBuffer, priority, toStream, toLoop, sourcename, filenameURL, buffer, x, y, z, attModel, distOrRoll, false);
-        this.sourceMap.put(sourcename, s);
-        this.play(s);
-        if (temporary) {
-            s.setTemporary(true);
-        }
-
-    }
-
-    public void copySources(HashMap<String, Source> srcMap) {
-        if (srcMap != null) {
-            Set<String> keys = srcMap.keySet();
-            Iterator<String> iter = keys.iterator();
-            if (this.bufferMap == null) {
-                this.bufferMap = new HashMap();
-                this.importantMessage("Buffer Map was null in method 'copySources'");
-            }
-
-            if (this.ALBufferMap == null) {
-                this.ALBufferMap = new HashMap();
-                this.importantMessage("Open AL Buffer Map was null in method'copySources'");
-            }
-
-            this.sourceMap.clear();
-
-            while (true) {
-                String sourcename;
-                Source source;
-                SoundBuffer buffer;
-                do {
-                    do {
-                        if (!iter.hasNext()) {
-                            return;
-                        }
-
-                        sourcename = (String) iter.next();
-                        source = (Source) srcMap.get(sourcename);
-                    } while (source == null);
-
-                    buffer = null;
-                    if (!source.toStream) {
-                        this.loadSound(source.filenameURL);
-                        buffer = (SoundBuffer) this.bufferMap.get(source.filenameURL.getFilename());
-                    }
-                } while (!source.toStream && buffer == null);
-
-                this.sourceMap.put(sourcename, new SourceLWJGL3OpenAL(this.listenerPositionAL, (IntBuffer) this.ALBufferMap.get(source.filenameURL.getFilename()), source, buffer));
-            }
-        }
-    }
-
-    public void setListenerPosition(float x, float y, float z) {
-        super.setListenerPosition(x, y, z);
-        this.listenerPositionAL.put(0, x);
-        this.listenerPositionAL.put(1, y);
-        this.listenerPositionAL.put(2, z);
-        AL10.alListenerfv(4100, this.listenerPositionAL);
-        this.checkALError();
-    }
-
-    public void setListenerAngle(float angle) {
-        super.setListenerAngle(angle);
-        this.listenerOrientation.put(0, this.listener.lookAt.x);
-        this.listenerOrientation.put(2, this.listener.lookAt.z);
-        AL10.alListenerfv(4111, this.listenerOrientation);
-        this.checkALError();
-    }
-
-    public void setListenerOrientation(float lookX, float lookY, float lookZ, float upX, float upY, float upZ) {
-        super.setListenerOrientation(lookX, lookY, lookZ, upX, upY, upZ);
-        this.listenerOrientation.put(0, lookX);
-        this.listenerOrientation.put(1, lookY);
-        this.listenerOrientation.put(2, lookZ);
-        this.listenerOrientation.put(3, upX);
-        this.listenerOrientation.put(4, upY);
-        this.listenerOrientation.put(5, upZ);
-        AL10.alListenerfv(4111, this.listenerOrientation);
-        this.checkALError();
-    }
-
-    public void setListenerData(ListenerData l) {
-        super.setListenerData(l);
-        this.listenerPositionAL.put(0, l.position.x);
-        this.listenerPositionAL.put(1, l.position.y);
-        this.listenerPositionAL.put(2, l.position.z);
-        AL10.alListenerfv(4100, this.listenerPositionAL);
-        this.checkALError();
-        this.listenerOrientation.put(0, l.lookAt.x);
-        this.listenerOrientation.put(1, l.lookAt.y);
-        this.listenerOrientation.put(2, l.lookAt.z);
-        this.listenerOrientation.put(3, l.up.x);
-        this.listenerOrientation.put(4, l.up.y);
-        this.listenerOrientation.put(5, l.up.z);
-        AL10.alListenerfv(4111, this.listenerOrientation);
-        this.checkALError();
-        this.listenerVelocity.put(0, l.velocity.x);
-        this.listenerVelocity.put(1, l.velocity.y);
-        this.listenerVelocity.put(2, l.velocity.z);
-        AL10.alListenerfv(4102, this.listenerVelocity);
-        this.checkALError();
-    }
-
-    public void setListenerVelocity(float x, float y, float z) {
-        super.setListenerVelocity(x, y, z);
-        this.listenerVelocity.put(0, this.listener.velocity.x);
-        this.listenerVelocity.put(1, this.listener.velocity.y);
-        this.listenerVelocity.put(2, this.listener.velocity.z);
-        AL10.alListenerfv(4102, this.listenerVelocity);
-    }
-
-    public void dopplerChanged() {
-        super.dopplerChanged();
-        AL10.alDopplerFactor(SoundSystemConfig.getDopplerFactor());
-        this.checkALError();
-        AL10.alDopplerVelocity(SoundSystemConfig.getDopplerVelocity());
-        this.checkALError();
-    }
-
-    private boolean checkALError() {
-        switch (AL10.alGetError()) {
-            case 0:
-                return false;
-            case 40961:
-                this.errorMessage("Invalid name parameter.");
-                return true;
-            case 40962:
-                this.errorMessage("Invalid parameter.");
-                return true;
-            case 40963:
-                this.errorMessage("Invalid enumerated parameter value.");
-                return true;
-            case 40964:
-                this.errorMessage("Illegal call.");
-                return true;
-            case 40965:
-                this.errorMessage("Unable to allocate memory.");
-                return true;
-            default:
-                this.errorMessage("An unrecognized error occurred.");
-                return true;
-        }
-    }
-
-    public static boolean alPitchSupported() {
-        return alPitchSupported(false, false);
-    }
-
-    private static synchronized boolean alPitchSupported(boolean action, boolean value) {
-        if (action) {
-            alPitchSupported = value;
-        }
-
-        return alPitchSupported;
-    }
-
-    public static String getTitle() {
-        return "LWJGL OpenAL";
-    }
-
-    public static String getDescription() {
-        return "The LWJGL binding of OpenAL.  For more information, see http://www.lwjgl.org";
-    }
-
-    public String getClassName() {
-        return "LibraryLWJGLOpenAL";
-    }
-
-    public static class Exception extends SoundSystemException {
-        public static final int CREATE = 101;
-        public static final int INVALID_NAME = 102;
-        public static final int INVALID_ENUM = 103;
-        public static final int INVALID_VALUE = 104;
-        public static final int INVALID_OPERATION = 105;
-        public static final int OUT_OF_MEMORY = 106;
-        public static final int LISTENER = 107;
-        public static final int NO_AL_PITCH = 108;
-
-        public Exception(String message) {
-            super(message);
-        }
-
-        public Exception(String message, int type) {
-            super(message, type);
-        }
-    }
-}
diff --git a/src/embeddedlibs/net/minecraft/client/audio/FUCKLWJGL3/SourceLWJGL3OpenAL.java b/src/embeddedlibs/net/minecraft/client/audio/FUCKLWJGL3/SourceLWJGL3OpenAL.java
deleted file mode 100644
index 9a959f1..0000000
--- a/src/embeddedlibs/net/minecraft/client/audio/FUCKLWJGL3/SourceLWJGL3OpenAL.java
+++ /dev/null
@@ -1,444 +0,0 @@
-//
-// Source code recreated from a .class file by IntelliJ IDEA
-// (powered by FernFlower decompiler)
-//
-
-package net.minecraft.client.audio.FUCKLWJGL3;
-
-import org.lwjgl.BufferUtils;
-import org.lwjgl.openal.AL10;
-import paulscode.sound.*;
-
-import javax.sound.sampled.AudioFormat;
-import java.nio.FloatBuffer;
-import java.nio.IntBuffer;
-import java.util.LinkedList;
-
-public class SourceLWJGL3OpenAL extends Source {
-    private ChannelLWJGL3OpenAL channelOpenAL;
-    private IntBuffer myBuffer;
-    private FloatBuffer listenerPosition;
-    private FloatBuffer sourcePosition;
-    private FloatBuffer sourceVelocity;
-
-    public SourceLWJGL3OpenAL(FloatBuffer listenerPosition, IntBuffer myBuffer, boolean priority, boolean toStream, boolean toLoop, String sourcename, FilenameURL filenameURL, SoundBuffer soundBuffer, float x, float y, float z, int attModel, float distOrRoll, boolean temporary) {
-        super(priority, toStream, toLoop, sourcename, filenameURL, soundBuffer, x, y, z, attModel, distOrRoll, temporary);
-        this.channelOpenAL = (ChannelLWJGL3OpenAL) this.channel;
-        if (this.codec != null) {
-            this.codec.reverseByteOrder(true);
-        }
-
-        this.listenerPosition = listenerPosition;
-        this.myBuffer = myBuffer;
-        this.libraryType = SoundEngine.class;
-        this.pitch = 1.0F;
-        this.resetALInformation();
-    }
-
-    public SourceLWJGL3OpenAL(FloatBuffer listenerPosition, IntBuffer myBuffer, Source old, SoundBuffer soundBuffer) {
-        super(old, soundBuffer);
-        this.channelOpenAL = (ChannelLWJGL3OpenAL) this.channel;
-        if (this.codec != null) {
-            this.codec.reverseByteOrder(true);
-        }
-
-        this.listenerPosition = listenerPosition;
-        this.myBuffer = myBuffer;
-        this.libraryType = SoundEngine.class;
-        this.pitch = 1.0F;
-        this.resetALInformation();
-    }
-
-    public SourceLWJGL3OpenAL(FloatBuffer listenerPosition, AudioFormat audioFormat, boolean priority, String sourcename, float x, float y, float z, int attModel, float distOrRoll) {
-        super(audioFormat, priority, sourcename, x, y, z, attModel, distOrRoll);
-        this.channelOpenAL = (ChannelLWJGL3OpenAL) this.channel;
-        this.listenerPosition = listenerPosition;
-        this.libraryType = SoundEngine.class;
-        this.pitch = 1.0F;
-        this.resetALInformation();
-    }
-
-    public void cleanup() {
-        super.cleanup();
-    }
-
-    public void changeSource(FloatBuffer listenerPosition, IntBuffer myBuffer, boolean priority, boolean toStream, boolean toLoop, String sourcename, FilenameURL filenameURL, SoundBuffer soundBuffer, float x, float y, float z, int attModel, float distOrRoll, boolean temporary) {
-        super.changeSource(priority, toStream, toLoop, sourcename, filenameURL, soundBuffer, x, y, z, attModel, distOrRoll, temporary);
-        this.listenerPosition = listenerPosition;
-        this.myBuffer = myBuffer;
-        this.pitch = 1.0F;
-        this.resetALInformation();
-    }
-
-    public boolean incrementSoundSequence() {
-        if (!this.toStream) {
-            this.errorMessage("Method 'incrementSoundSequence' may only be used for streaming sources.");
-            return false;
-        } else {
-            synchronized (this.soundSequenceLock) {
-                if (this.soundSequenceQueue != null && this.soundSequenceQueue.size() > 0) {
-                    this.filenameURL = (FilenameURL) this.soundSequenceQueue.remove(0);
-                    if (this.codec != null) {
-                        this.codec.cleanup();
-                    }
-
-                    this.codec = SoundSystemConfig.getCodec(this.filenameURL.getFilename());
-                    if (this.codec != null) {
-                        this.codec.reverseByteOrder(true);
-                        if (this.codec.getAudioFormat() == null) {
-                            this.codec.initialize(this.filenameURL.getURL());
-                        }
-
-                        AudioFormat audioFormat = this.codec.getAudioFormat();
-                        if (audioFormat == null) {
-                            this.errorMessage("Audio Format null in method 'incrementSoundSequence'");
-                            return false;
-                        }
-
-                        short soundFormat = 0;
-                        if (audioFormat.getChannels() == 1) {
-                            if (audioFormat.getSampleSizeInBits() == 8) {
-                                soundFormat = 4352;
-                            } else {
-                                if (audioFormat.getSampleSizeInBits() != 16) {
-                                    this.errorMessage("Illegal sample size in method 'incrementSoundSequence'");
-                                    return false;
-                                }
-
-                                soundFormat = 4353;
-                            }
-                        } else {
-                            if (audioFormat.getChannels() != 2) {
-                                this.errorMessage("Audio data neither mono nor stereo in method 'incrementSoundSequence'");
-                                return false;
-                            }
-
-                            if (audioFormat.getSampleSizeInBits() == 8) {
-                                soundFormat = 4354;
-                            } else {
-                                if (audioFormat.getSampleSizeInBits() != 16) {
-                                    this.errorMessage("Illegal sample size in method 'incrementSoundSequence'");
-                                    return false;
-                                }
-
-                                soundFormat = 4355;
-                            }
-                        }
-
-                        this.channelOpenAL.setFormat(soundFormat, (int) audioFormat.getSampleRate());
-                        this.preLoad = true;
-                    }
-
-                    return true;
-                } else {
-                    return false;
-                }
-            }
-        }
-    }
-
-    public void listenerMoved() {
-        this.positionChanged();
-    }
-
-    public void setPosition(float x, float y, float z) {
-        super.setPosition(x, y, z);
-        if (this.sourcePosition == null) {
-            this.resetALInformation();
-        } else {
-            this.positionChanged();
-        }
-
-        this.sourcePosition.put(0, x);
-        this.sourcePosition.put(1, y);
-        this.sourcePosition.put(2, z);
-        if (this.channel != null && this.channel.attachedSource == this && this.channelOpenAL != null && this.channelOpenAL.ALSource != null) {
-            AL10.alSourcefv(this.channelOpenAL.ALSource.get(0), 4100, this.sourcePosition);
-            this.checkALError();
-        }
-
-    }
-
-    public void positionChanged() {
-        this.calculateDistance();
-        this.calculateGain();
-        if (this.channel != null && this.channel.attachedSource == this && this.channelOpenAL != null && this.channelOpenAL.ALSource != null) {
-            AL10.alSourcef(this.channelOpenAL.ALSource.get(0), 4106, this.gain * this.sourceVolume * Math.abs(this.fadeOutGain) * this.fadeInGain);
-            this.checkALError();
-        }
-
-        this.checkPitch();
-    }
-
-    private void checkPitch() {
-        if (this.channel != null && this.channel.attachedSource == this && SoundEngine.alPitchSupported() && this.channelOpenAL != null && this.channelOpenAL.ALSource != null) {
-            AL10.alSourcef(this.channelOpenAL.ALSource.get(0), 4099, this.pitch);
-            this.checkALError();
-        }
-
-    }
-
-    public void setLooping(boolean lp) {
-        super.setLooping(lp);
-        if (this.channel != null && this.channel.attachedSource == this && this.channelOpenAL != null && this.channelOpenAL.ALSource != null) {
-            if (lp) {
-                AL10.alSourcei(this.channelOpenAL.ALSource.get(0), 4103, 1);
-            } else {
-                AL10.alSourcei(this.channelOpenAL.ALSource.get(0), 4103, 0);
-            }
-
-            this.checkALError();
-        }
-
-    }
-
-    public void setAttenuation(int model) {
-        super.setAttenuation(model);
-        if (this.channel != null && this.channel.attachedSource == this && this.channelOpenAL != null && this.channelOpenAL.ALSource != null) {
-            if (model == 1) {
-                AL10.alSourcef(this.channelOpenAL.ALSource.get(0), 4129, this.distOrRoll);
-            } else {
-                AL10.alSourcef(this.channelOpenAL.ALSource.get(0), 4129, 0.0F);
-            }
-
-            this.checkALError();
-        }
-
-    }
-
-    public void setDistOrRoll(float dr) {
-        super.setDistOrRoll(dr);
-        if (this.channel != null && this.channel.attachedSource == this && this.channelOpenAL != null && this.channelOpenAL.ALSource != null) {
-            if (this.attModel == 1) {
-                AL10.alSourcef(this.channelOpenAL.ALSource.get(0), 4129, dr);
-            } else {
-                AL10.alSourcef(this.channelOpenAL.ALSource.get(0), 4129, 0.0F);
-            }
-
-            this.checkALError();
-        }
-
-    }
-
-    public void setVelocity(float x, float y, float z) {
-        super.setVelocity(x, y, z);
-        this.sourceVelocity = BufferUtils.createFloatBuffer(3).put(new float[]{x, y, z});
-        this.sourceVelocity.flip();
-        if (this.channel != null && this.channel.attachedSource == this && this.channelOpenAL != null && this.channelOpenAL.ALSource != null) {
-            AL10.alSourcefv(this.channelOpenAL.ALSource.get(0), 4102, this.sourceVelocity);
-            this.checkALError();
-        }
-
-    }
-
-    public void setPitch(float value) {
-        super.setPitch(value);
-        this.checkPitch();
-    }
-
-    public void play(Channel c) {
-        if (!this.active()) {
-            if (this.toLoop) {
-                this.toPlay = true;
-            }
-
-        } else if (c == null) {
-            this.errorMessage("Unable to play source, because channel was null");
-        } else {
-            boolean newChannel = this.channel != c;
-            if (this.channel != null && this.channel.attachedSource != this) {
-                newChannel = true;
-            }
-
-            boolean wasPaused = this.paused();
-            super.play(c);
-            this.channelOpenAL = (ChannelLWJGL3OpenAL) this.channel;
-            if (newChannel) {
-                this.setPosition(this.position.x, this.position.y, this.position.z);
-                this.checkPitch();
-                if (this.channelOpenAL != null && this.channelOpenAL.ALSource != null) {
-                    if (SoundEngine.alPitchSupported()) {
-                        AL10.alSourcef(this.channelOpenAL.ALSource.get(0), 4099, this.pitch);
-                        this.checkALError();
-                    }
-
-                    AL10.alSourcefv(this.channelOpenAL.ALSource.get(0), 4100, this.sourcePosition);
-                    this.checkALError();
-                    AL10.alSourcefv(this.channelOpenAL.ALSource.get(0), 4102, this.sourceVelocity);
-                    this.checkALError();
-                    if (this.attModel == 1) {
-                        AL10.alSourcef(this.channelOpenAL.ALSource.get(0), 4129, this.distOrRoll);
-                    } else {
-                        AL10.alSourcef(this.channelOpenAL.ALSource.get(0), 4129, 0.0F);
-                    }
-
-                    this.checkALError();
-                    if (this.toLoop && !this.toStream) {
-                        AL10.alSourcei(this.channelOpenAL.ALSource.get(0), 4103, 1);
-                    } else {
-                        AL10.alSourcei(this.channelOpenAL.ALSource.get(0), 4103, 0);
-                    }
-
-                    this.checkALError();
-                }
-
-                if (!this.toStream) {
-                    if (this.myBuffer == null) {
-                        this.errorMessage("No sound buffer to play");
-                        return;
-                    }
-
-                    this.channelOpenAL.attachBuffer(this.myBuffer);
-                }
-            }
-
-            if (!this.playing()) {
-                if (this.toStream && !wasPaused) {
-                    if (this.codec == null) {
-                        this.errorMessage("Decoder null in method 'play'");
-                        return;
-                    }
-
-                    if (this.codec.getAudioFormat() == null) {
-                        this.codec.initialize(this.filenameURL.getURL());
-                    }
-
-                    AudioFormat audioFormat = this.codec.getAudioFormat();
-                    if (audioFormat == null) {
-                        this.errorMessage("Audio Format null in method 'play'");
-                        return;
-                    }
-
-
-                    short soundFormat = 0;
-                    if (audioFormat.getChannels() == 1) {
-                        if (audioFormat.getSampleSizeInBits() == 8) {
-                            soundFormat = 4352;
-                        } else {
-                            if (audioFormat.getSampleSizeInBits() != 16) {
-                                this.errorMessage("Illegal sample size in method 'play'");
-                                return;
-                            }
-
-                            soundFormat = 4353;
-                        }
-                    } else {
-                        if (audioFormat.getChannels() != 2) {
-                            this.errorMessage("Audio data neither mono nor stereo in method 'play'");
-                            return;
-                        }
-
-                        if (audioFormat.getSampleSizeInBits() == 8) {
-                            soundFormat = 4354;
-                        } else {
-                            if (audioFormat.getSampleSizeInBits() != 16) {
-                                this.errorMessage("Illegal sample size in method 'play'");
-                                return;
-                            }
-
-                            soundFormat = 4355;
-                        }
-                    }
-
-                    this.channelOpenAL.setFormat(soundFormat, (int) audioFormat.getSampleRate());
-                    this.preLoad = true;
-                }
-
-                this.channel.play();
-                if (this.pitch != 1.0F) {
-                    this.checkPitch();
-                }
-            }
-
-        }
-    }
-
-    public boolean preLoad() {
-        if (this.codec == null) {
-            return false;
-        } else {
-            this.codec.initialize(this.filenameURL.getURL());
-            LinkedList<byte[]> preLoadBuffers = new LinkedList();
-
-            for (int i = 0; i < SoundSystemConfig.getNumberStreamingBuffers(); ++i) {
-                this.soundBuffer = this.codec.read();
-                if (this.soundBuffer == null || this.soundBuffer.audioData == null) {
-                    break;
-                }
-
-                preLoadBuffers.add(this.soundBuffer.audioData);
-            }
-
-            this.positionChanged();
-            this.channel.preLoadBuffers(preLoadBuffers);
-            this.preLoad = false;
-            return true;
-        }
-    }
-
-    private void resetALInformation() {
-        this.sourcePosition = BufferUtils.createFloatBuffer(3).put(new float[]{this.position.x, this.position.y, this.position.z});
-        this.sourceVelocity = BufferUtils.createFloatBuffer(3).put(new float[]{this.velocity.x, this.velocity.y, this.velocity.z});
-        this.sourcePosition.flip();
-        this.sourceVelocity.flip();
-        this.positionChanged();
-    }
-
-    private void calculateDistance() {
-        if (this.listenerPosition != null) {
-            double dX = (double) (this.position.x - this.listenerPosition.get(0));
-            double dY = (double) (this.position.y - this.listenerPosition.get(1));
-            double dZ = (double) (this.position.z - this.listenerPosition.get(2));
-            this.distanceFromListener = (float) Math.sqrt(dX * dX + dY * dY + dZ * dZ);
-        }
-
-    }
-
-    private void calculateGain() {
-        if (this.attModel == 2) {
-            if (this.distanceFromListener <= 0.0F) {
-                this.gain = 1.0F;
-            } else if (this.distanceFromListener >= this.distOrRoll) {
-                this.gain = 0.0F;
-            } else {
-                this.gain = 1.0F - this.distanceFromListener / this.distOrRoll;
-            }
-
-            if (this.gain > 1.0F) {
-                this.gain = 1.0F;
-            }
-
-            if (this.gain < 0.0F) {
-                this.gain = 0.0F;
-            }
-        } else {
-            this.gain = 1.0F;
-        }
-
-    }
-
-    private boolean checkALError() {
-        switch (AL10.alGetError()) {
-            case 0:
-                return false;
-            case 40961:
-                this.errorMessage("Invalid name parameter.");
-                return true;
-            case 40962:
-                this.errorMessage("Invalid parameter.");
-                return true;
-            case 40963:
-                this.errorMessage("Invalid enumerated parameter value.");
-                return true;
-            case 40964:
-                this.errorMessage("Illegal call.");
-                return true;
-            case 40965:
-                this.errorMessage("Unable to allocate memory.");
-                return true;
-            default:
-                this.errorMessage("An unrecognized error occurred.");
-                return true;
-        }
-    }
-}
diff --git a/src/embeddedlibs/org/lwjgl/LWJGLException.java b/src/embeddedlibs/org/lwjgl/LWJGLException.java
deleted file mode 100644
index 79ef96b..0000000
--- a/src/embeddedlibs/org/lwjgl/LWJGLException.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/* 
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are 
- * met:
- * 
- * * Redistributions of source code must retain the above copyright 
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of 
- *   its contributors may be used to endorse or promote products derived 
- *   from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjgl;
-
-/**
- * <p>
- * This exception is supplied to make exception handling more generic for LWJGL
- * specific exceptions
- * </p>
- * 
- * @author Brian Matzon <brian@matzon.dk>
- * @version $Revision$
- * $Id$
- */
-public class LWJGLException extends Exception {
-
-	private static final long serialVersionUID = 1L;
-
-	/**
-	 * Plain c'tor
-	 */
-	public LWJGLException() {
-		super();
-	}
-
-	/**
-	 * Creates a new LWJGLException
-	 * 
-	 * @param msg
-	 *            String identifier for exception
-	 */
-	public LWJGLException(String msg) {
-		super(msg);
-	}
-
-	/**
-	 * @param message
-	 * @param cause
-	 */
-	public LWJGLException(String message, Throwable cause) {
-		super(message, cause);
-	}
-
-	/**
-	 * @param cause
-	 */
-	public LWJGLException(Throwable cause) {
-		super(cause);
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/BufferChecks.java b/src/embeddedlibs/org/lwjglx/BufferChecks.java
deleted file mode 100644
index 828fd4d..0000000
--- a/src/embeddedlibs/org/lwjglx/BufferChecks.java
+++ /dev/null
@@ -1,286 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx;
-
-import java.nio.*;
-
-/**
- * <p>A class to check buffer boundaries in general. If there is unsufficient space
- * in the buffer when the call is made then a buffer overflow would otherwise
- * occur and cause unexpected behaviour, a crash, or worse, a security risk.
- *
- * Internal class, don't use.
- * </p>
- * @author cix_foo <cix_foo@users.sourceforge.net>
- * @author elias_naur <elias_naur@users.sourceforge.net>
- * @version $Revision$
- * $Id$
- */
-public class BufferChecks {
-	/** Static methods only! */
-	private BufferChecks() {
-	}
-
-	/**
-	 * Helper methods to ensure a function pointer is not-null (0)
-	 */
-	public static void checkFunctionAddress(long pointer) {
-		if (LWJGLUtil.CHECKS && pointer == 0) {
-			throw new IllegalStateException("Function is not supported");
-		}
-	}
-
-	/**
-	 * Helper methods to ensure a ByteBuffer is null-terminated
-	 */
-	public static void checkNullTerminated(ByteBuffer buf) {
-		if ( LWJGLUtil.CHECKS && buf.get(buf.limit() - 1) != 0) {
-			throw new IllegalArgumentException("Missing null termination");
-		}
-	}
-
-	public static void checkNullTerminated(ByteBuffer buf, int count) {
-		if ( LWJGLUtil.CHECKS ) {
-			int nullFound = 0;
-			for ( int i = buf.position(); i < buf.limit(); i++ ) {
-				if ( buf.get(i) == 0 )
-					nullFound++;
-			}
-
-			if ( nullFound < count )
-				throw new IllegalArgumentException("Missing null termination");
-		}
-	}
-
-	/** Helper method to ensure an IntBuffer is null-terminated */
-	public static void checkNullTerminated(IntBuffer buf) {
-		if ( LWJGLUtil.CHECKS && buf.get(buf.limit() - 1) != 0 ) {
-			throw new IllegalArgumentException("Missing null termination");
-		}
-	}
-
-	/** Helper method to ensure a LongBuffer is null-terminated */
-	public static void checkNullTerminated(LongBuffer buf) {
-		if ( LWJGLUtil.CHECKS && buf.get(buf.limit() - 1) != 0 ) {
-			throw new IllegalArgumentException("Missing null termination");
-		}
-	}
-
-	/** Helper method to ensure a PointerBuffer is null-terminated */
-	public static void checkNullTerminated(PointerBuffer buf) {
-		if ( LWJGLUtil.CHECKS && buf.get(buf.limit() - 1) != 0 ) {
-			throw new IllegalArgumentException("Missing null termination");
-		}
-	}
-
-	public static void checkNotNull(Object o) {
-		if ( LWJGLUtil.CHECKS && o == null)
-			throw new IllegalArgumentException("Null argument");
-	}
-
-	/**
-	 * Helper methods to ensure a buffer is direct (and, implicitly, non-null).
-	 */
-	public static void checkDirect(ByteBuffer buf) {
-		if ( LWJGLUtil.CHECKS && !buf.isDirect()) {
-			throw new IllegalArgumentException("ByteBuffer is not direct");
-		}
-	}
-
-	public static void checkDirect(ShortBuffer buf) {
-		if ( LWJGLUtil.CHECKS && !buf.isDirect()) {
-			throw new IllegalArgumentException("ShortBuffer is not direct");
-		}
-	}
-
-	public static void checkDirect(IntBuffer buf) {
-		if ( LWJGLUtil.CHECKS && !buf.isDirect()) {
-			throw new IllegalArgumentException("IntBuffer is not direct");
-		}
-	}
-
-	public static void checkDirect(LongBuffer buf) {
-		if ( LWJGLUtil.CHECKS && !buf.isDirect()) {
-			throw new IllegalArgumentException("LongBuffer is not direct");
-		}
-	}
-
-	public static void checkDirect(FloatBuffer buf) {
-		if ( LWJGLUtil.CHECKS && !buf.isDirect()) {
-			throw new IllegalArgumentException("FloatBuffer is not direct");
-		}
-	}
-
-	public static void checkDirect(DoubleBuffer buf) {
-		if ( LWJGLUtil.CHECKS && !buf.isDirect()) {
-			throw new IllegalArgumentException("DoubleBuffer is not direct");
-		}
-	}
-
-	public static void checkDirect(PointerBuffer buf) {
-		// NO-OP, PointerBuffer is always direct.
-	}
-
-	public static void checkArray(Object[] array) {
-		if ( LWJGLUtil.CHECKS && (array == null || array.length == 0) )
-			throw new IllegalArgumentException("Invalid array");
-	}
-
-	/**
-	 * This is a separate call to help inline checkBufferSize.
-	 */
-	private static void throwBufferSizeException(Buffer buf, int size) {
-		throw new IllegalArgumentException("Number of remaining buffer elements is " + buf.remaining() + ", must be at least " + size + ". Because at most " + size + " elements can be returned, a buffer with at least " + size + " elements is required, regardless of actual returned element count");
-	}
-
-	private static void throwBufferSizeException(PointerBuffer buf, int size) {
-		throw new IllegalArgumentException("Number of remaining pointer buffer elements is " + buf.remaining() + ", must be at least " + size);
-	}
-
-	private static void throwArraySizeException(Object[] array, int size) {
-		throw new IllegalArgumentException("Number of array elements is " + array.length + ", must be at least " + size);
-	}
-
-	private static void throwArraySizeException(long[] array, int size) {
-		throw new IllegalArgumentException("Number of array elements is " + array.length + ", must be at least " + size);
-	}
-
-	/**
-	 * Helper method to ensure a buffer is big enough to receive data from a
-	 * glGet* operation.
-	 *
-	 * @param buf
-	 *            The buffer to check
-	 * @param size
-	 * 			  The minimum buffer size
-	 * @throws IllegalArgumentException
-	 */
-	public static void checkBufferSize(Buffer buf, int size) {
-		if ( LWJGLUtil.CHECKS && buf.remaining() < size) {
-			throwBufferSizeException(buf, size);
-		}
-	}
-
-	/**
-	 * Detects the buffer type and performs the corresponding check
-	 * and also returns the buffer position in bytes.
-	 *
-	 * @param buffer the buffer to check
-	 * @param size   the size to check
-	 *
-	 * @return the buffer position in bytes
-	 */
-	public static int checkBuffer(final Buffer buffer, final int size) {
-		final int posShift;
-		if ( buffer instanceof ByteBuffer ) {
-			BufferChecks.checkBuffer((ByteBuffer)buffer, size);
-			posShift = 0;
-		} else if ( buffer instanceof ShortBuffer ) {
-			BufferChecks.checkBuffer((ShortBuffer)buffer, size);
-			posShift = 1;
-		} else if ( buffer instanceof IntBuffer ) {
-			BufferChecks.checkBuffer((IntBuffer)buffer, size);
-			posShift = 2;
-		} else if ( buffer instanceof LongBuffer ) {
-			BufferChecks.checkBuffer((LongBuffer)buffer, size);
-			posShift = 4;
-		} else if ( buffer instanceof FloatBuffer ) {
-			BufferChecks.checkBuffer((FloatBuffer)buffer, size);
-			posShift = 2;
-		} else if ( buffer instanceof DoubleBuffer ) {
-			BufferChecks.checkBuffer((DoubleBuffer)buffer, size);
-			posShift = 4;
-		} else
-			throw new IllegalArgumentException("Unsupported Buffer type specified: " + buffer.getClass());
-
-		return buffer.position() << posShift;
-	}
-
-	public static void checkBuffer(ByteBuffer buf, int size) {
-		if ( LWJGLUtil.CHECKS ) {
-			checkBufferSize(buf, size);
-			checkDirect(buf);
-		}
-	}
-
-	public static void checkBuffer(ShortBuffer buf, int size) {
-		if ( LWJGLUtil.CHECKS ) {
-			checkBufferSize(buf, size);
-			checkDirect(buf);
-		}
-	}
-
-	public static void checkBuffer(IntBuffer buf, int size) {
-		if ( LWJGLUtil.CHECKS ) {
-			checkBufferSize(buf, size);
-			checkDirect(buf);
-		}
-	}
-
-	public static void checkBuffer(LongBuffer buf, int size) {
-		if ( LWJGLUtil.CHECKS ) {
-			checkBufferSize(buf, size);
-			checkDirect(buf);
-		}
-	}
-
-	public static void checkBuffer(FloatBuffer buf, int size) {
-		if ( LWJGLUtil.CHECKS ) {
-			checkBufferSize(buf, size);
-			checkDirect(buf);
-		}
-	}
-
-	public static void checkBuffer(DoubleBuffer buf, int size) {
-		if ( LWJGLUtil.CHECKS ) {
-			checkBufferSize(buf, size);
-			checkDirect(buf);
-		}
-	}
-
-	public static void checkBuffer(PointerBuffer buf, int size) {
-		if ( LWJGLUtil.CHECKS && buf.remaining() < size ) {
-			throwBufferSizeException(buf, size);
-		}
-	}
-
-	public static void checkArray(Object[] array, int size) {
-		if ( LWJGLUtil.CHECKS && array.length < size )
-			throwArraySizeException(array, size);
-	}
-
-	public static void checkArray(long[] array, int size) {
-		if ( LWJGLUtil.CHECKS && array.length < size )
-			throwArraySizeException(array, size);
-	}
-
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/BufferUtils.java b/src/embeddedlibs/org/lwjglx/BufferUtils.java
deleted file mode 100644
index 0fd803d..0000000
--- a/src/embeddedlibs/org/lwjglx/BufferUtils.java
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx;
-
-import java.nio.Buffer;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.CharBuffer;
-import java.nio.DoubleBuffer;
-import java.nio.FloatBuffer;
-import java.nio.IntBuffer;
-import java.nio.LongBuffer;
-import java.nio.ShortBuffer;
-
-/**
- * Some often-used Buffer code for creating native buffers of the appropriate size.
- *
- * @author $Author: spasi $
- * @version $Revision: 3528 $
- * $Id: BufferUtils.java 3528 2011-05-11 00:12:52Z spasi $
- */
-
-public final class BufferUtils {
-
-	/**
-	 * Construct a direct native-ordered bytebuffer with the specified size.
-	 * @param size The size, in bytes
-	 * @return a ByteBuffer
-	 */
-	public static ByteBuffer createByteBuffer(int size) {
-		return ByteBuffer.allocateDirect(size).order(ByteOrder.nativeOrder());
-	}
-
-	/**
-	 * Construct a direct native-order shortbuffer with the specified number
-	 * of elements.
-	 * @param size The size, in shorts
-	 * @return a ShortBuffer
-	 */
-	public static ShortBuffer createShortBuffer(int size) {
-		return createByteBuffer(size << 1).asShortBuffer();
-	}
-
-	/**
-	 * Construct a direct native-order charbuffer with the specified number
-	 * of elements.
-	 * @param size The size, in chars
-	 * @return an CharBuffer
-	 */
-	public static CharBuffer createCharBuffer(int size) {
-		return createByteBuffer(size << 1).asCharBuffer();
-	}
-
-	/**
-	 * Construct a direct native-order intbuffer with the specified number
-	 * of elements.
-	 * @param size The size, in ints
-	 * @return an IntBuffer
-	 */
-	public static IntBuffer createIntBuffer(int size) {
-		return createByteBuffer(size << 2).asIntBuffer();
-	}
-
-	/**
-	 * Construct a direct native-order longbuffer with the specified number
-	 * of elements.
-	 * @param size The size, in longs
-	 * @return an LongBuffer
-	 */
-	public static LongBuffer createLongBuffer(int size) {
-		return createByteBuffer(size << 3).asLongBuffer();
-	}
-
-	/**
-	 * Construct a direct native-order floatbuffer with the specified number
-	 * of elements.
-	 * @param size The size, in floats
-	 * @return a FloatBuffer
-	 */
-	public static FloatBuffer createFloatBuffer(int size) {
-		return createByteBuffer(size << 2).asFloatBuffer();
-	}
-
-	/**
-	 * Construct a direct native-order doublebuffer with the specified number
-	 * of elements.
-	 * @param size The size, in floats
-	 * @return a FloatBuffer
-	 */
-	public static DoubleBuffer createDoubleBuffer(int size) {
-		return createByteBuffer(size << 3).asDoubleBuffer();
-	}
-
-	/**
-	 * Construct a PointerBuffer with the specified number
-	 * of elements.
-	 * @param size The size, in memory addresses
-	 * @return a PointerBuffer
-	 */
-	public static PointerBuffer createPointerBuffer(int size) {
-		return PointerBuffer.allocateDirect(size);
-	}
-
-	/**
-	 * @return n, where buffer_element_size=2^n.
-	 */
-	public static int getElementSizeExponent(Buffer buf) {
-		if (buf instanceof ByteBuffer)
-			return 0;
-		else if (buf instanceof ShortBuffer || buf instanceof CharBuffer)
-			return 1;
-		else if (buf instanceof FloatBuffer || buf instanceof IntBuffer)
-			return 2;
-		else if (buf instanceof LongBuffer || buf instanceof DoubleBuffer)
-			return 3;
-		else
-			throw new IllegalStateException("Unsupported buffer type: " + buf);
-	}
-
-	/**
-	 * A helper function which is used to get the byte offset in an arbitrary buffer
-	 * based on its position
-	 * @return the position of the buffer, in BYTES
-	 */
-	public static int getOffset(Buffer buffer) {
-		return buffer.position() << getElementSizeExponent(buffer);
-	}
-
-	/** Fill buffer with zeros from position to remaining */
-	public static void zeroBuffer(ByteBuffer b) {
-	    zeroBuffer0(b, b.position(), b.remaining());
-	}
-
-	/** Fill buffer with zeros from position to remaining */
-	public static void zeroBuffer(ShortBuffer b) {
-	    zeroBuffer0(b, b.position()*2L, b.remaining()*2L);
-	}
-
-	/** Fill buffer with zeros from position to remaining */
-	public static void zeroBuffer(CharBuffer b) {
-	    zeroBuffer0(b, b.position()*2L, b.remaining()*2L);
-	}
-
-	/** Fill buffer with zeros from position to remaining */
-	public static void zeroBuffer(IntBuffer b) {
-	    zeroBuffer0(b, b.position()*4L, b.remaining()*4L);
-	}
-
-	/** Fill buffer with zeros from position to remaining */
-	public static void zeroBuffer(FloatBuffer b) {
-	    zeroBuffer0(b, b.position()*4L, b.remaining()*4L);
-	}
-
-	/** Fill buffer with zeros from position to remaining */
-	public static void zeroBuffer(LongBuffer b) {
-	    zeroBuffer0(b, b.position()*8L, b.remaining()*8L);
-	}
-
-	/** Fill buffer with zeros from position to remaining */
-	public static void zeroBuffer(DoubleBuffer b) {
-	    zeroBuffer0(b, b.position()*8L, b.remaining()*8L);
-	}
-
-	/** Fill buffer with zeros from position to remaining */
-	private static native void zeroBuffer0(Buffer b, long off, long size);
-
-	/**
-	 * Returns the memory address of the specified buffer.
-	 *
-	 * @param buffer the buffer
-	 *
-	 * @return the memory address
-	 */
-	static native long getBufferAddress(Buffer buffer);
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/LWJGLException.java b/src/embeddedlibs/org/lwjglx/LWJGLException.java
deleted file mode 100644
index 5d2c33f..0000000
--- a/src/embeddedlibs/org/lwjglx/LWJGLException.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/* 
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are 
- * met:
- * 
- * * Redistributions of source code must retain the above copyright 
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of 
- *   its contributors may be used to endorse or promote products derived 
- *   from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx;
-
-/**
- * <p>
- * This exception is supplied to make exception handling more generic for LWJGL
- * specific exceptions
- * </p>
- * 
- * @author Brian Matzon <brian@matzon.dk>
- * @version $Revision$
- * $Id$
- */
-public class LWJGLException extends Exception {
-
-	private static final long serialVersionUID = 1L;
-
-	/**
-	 * Plain c'tor
-	 */
-	public LWJGLException() {
-		super();
-	}
-
-	/**
-	 * Creates a new LWJGLException
-	 * 
-	 * @param msg
-	 *            String identifier for exception
-	 */
-	public LWJGLException(String msg) {
-		super(msg);
-	}
-
-	/**
-	 * @param message
-	 * @param cause
-	 */
-	public LWJGLException(String message, Throwable cause) {
-		super(message, cause);
-	}
-
-	/**
-	 * @param cause
-	 */
-	public LWJGLException(Throwable cause) {
-		super(cause);
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/LWJGLUtil.java b/src/embeddedlibs/org/lwjglx/LWJGLUtil.java
deleted file mode 100644
index 7f8799d..0000000
--- a/src/embeddedlibs/org/lwjglx/LWJGLUtil.java
+++ /dev/null
@@ -1,612 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx;
-
-import java.io.File;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.nio.ByteBuffer;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.security.PrivilegedActionException;
-import java.security.PrivilegedExceptionAction;
-import java.util.*;
-
-/**
- * <p>
- * Internal library methods
- * </p>
- *
- * @author Brian Matzon <brian@matzon.dk>
- * @version $Revision: 3608 $
- * $Id: LWJGLUtil.java 3608 2011-08-10 16:05:46Z spasi $
- */
-public class LWJGLUtil {
-	public static final int PLATFORM_LINUX 				= 1;
-	public static final int PLATFORM_MACOSX 			= 2;
-	public static final int PLATFORM_WINDOWS 			= 3;
-	public static final String PLATFORM_LINUX_NAME 		= "linux";
-	public static final String PLATFORM_MACOSX_NAME 	= "macosx";
-	public static final String PLATFORM_WINDOWS_NAME	= "windows";
-
-	private static final String LWJGL_ICON_DATA_16x16 =
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\376\377\377\377\302\327\350\377" +
-		"\164\244\313\377\120\213\275\377\124\216\277\377\206\257\322\377" +
-		"\347\357\366\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\365\365\365\377\215\217\221\377\166\202\215\377" +
-		"\175\215\233\377\204\231\252\377\224\267\325\377\072\175\265\377" +
-		"\110\206\272\377\332\347\361\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\364\370\373\377\234\236\240\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\344\344\344\377\204\255\320\377" +
-		"\072\175\265\377\133\222\301\377\374\375\376\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\221\266\325\377\137\137\137\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\042\042\042\377\377\377\377\377\350\360\366\377" +
-		"\071\174\265\377\072\175\265\377\304\330\351\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\306\331\351\377" +
-		"\201\253\316\377\035\035\035\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\146\146\146\377\377\377\377\377\320\340\355\377" +
-		"\072\175\265\377\072\175\265\377\215\264\324\377\377\377\377\377" +
-		"\362\362\362\377\245\245\245\377\337\337\337\377\242\301\334\377" +
-		"\260\305\326\377\012\012\012\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\250\250\250\377\377\377\377\377\227\272\330\377" +
-		"\072\175\265\377\072\175\265\377\161\241\312\377\377\377\377\377" +
-		"\241\241\241\377\000\000\000\377\001\001\001\377\043\043\043\377" +
-		"\314\314\314\377\320\320\320\377\245\245\245\377\204\204\204\377" +
-		"\134\134\134\377\357\357\357\377\377\377\377\377\140\226\303\377" +
-		"\072\175\265\377\072\175\265\377\155\236\310\377\377\377\377\377" +
-		"\136\136\136\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\317\317\317\377\037\037\037\377\003\003\003\377\053\053\053\377" +
-		"\154\154\154\377\306\306\306\377\372\374\375\377\236\277\332\377" +
-		"\167\245\314\377\114\211\274\377\174\250\316\377\377\377\377\377" +
-		"\033\033\033\377\000\000\000\377\000\000\000\377\027\027\027\377" +
-		"\326\326\326\377\001\001\001\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\122\122\122\377\345\345\345\377\075\075\075\377" +
-		"\150\150\150\377\246\246\247\377\332\336\341\377\377\377\377\377" +
-		"\164\164\164\377\016\016\016\377\000\000\000\377\131\131\131\377" +
-		"\225\225\225\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\221\221\221\377\233\233\233\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\002\002\002\377\103\103\103\377" +
-		"\377\377\377\377\356\356\356\377\214\214\214\377\277\277\277\377" +
-		"\126\126\126\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\323\323\323\377\130\130\130\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\063\063\063\377" +
-		"\377\377\377\377\377\377\377\377\374\375\376\377\377\377\377\377" +
-		"\300\300\300\377\100\100\100\377\002\002\002\377\000\000\000\377" +
-		"\033\033\033\377\373\373\373\377\027\027\027\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\170\170\170\377" +
-		"\377\377\377\377\377\377\377\377\322\341\356\377\176\251\316\377" +
-		"\340\352\363\377\377\377\377\377\324\324\324\377\155\155\155\377" +
-		"\204\204\204\377\323\323\323\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\275\275\275\377" +
-		"\377\377\377\377\377\377\377\377\376\376\376\377\146\232\305\377" +
-		"\075\177\266\377\202\254\320\377\344\355\365\377\377\377\377\377" +
-		"\377\377\377\377\345\345\345\377\055\055\055\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\014\014\014\377\366\366\366\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\342\354\364\377" +
-		"\115\211\274\377\072\175\265\377\076\200\266\377\207\260\322\377" +
-		"\347\357\366\377\377\377\377\377\376\376\376\377\274\274\274\377" +
-		"\117\117\117\377\003\003\003\377\112\112\112\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\353\362\370\377\214\263\324\377\126\220\300\377\120\214\275\377" +
-		"\167\245\314\377\355\363\370\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\337\337\337\377\346\346\346\377\377\377\377\377";
-
-	private static final String LWJGL_ICON_DATA_32x32 =
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\372\374\375\377" +
-		"\313\335\354\377\223\267\326\377\157\240\311\377\134\223\302\377\140\226\303\377\172\247\315\377\254\310\340\377\355\363\370\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\374\375\376\377\265\316\343\377\132\222\301\377" +
-		"\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\105\205\271\377" +
-		"\241\301\334\377\374\375\376\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\374\374\374\377\342\352\361\377\270\317\343\377\256\311\340\377" +
-		"\243\302\334\377\230\272\330\377\214\263\323\377\201\254\317\377\156\237\310\377\075\177\266\377\072\175\265\377\072\175\265\377" +
-		"\072\175\265\377\162\242\312\377\365\370\373\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\330\330\330\377\061\061\061\377\044\044\044\377\061\061\061\377\100\100\100\377" +
-		"\122\122\122\377\145\145\145\377\164\164\164\377\217\217\217\377\367\370\370\377\254\310\337\377\073\175\265\377\072\175\265\377" +
-		"\072\175\265\377\072\175\265\377\171\247\315\377\374\375\376\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\376\376\376\377\150\150\150\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\266\266\266\377\376\376\376\377\206\256\321\377\072\175\265\377" +
-		"\072\175\265\377\072\175\265\377\072\175\265\377\256\312\341\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\323\342\356\377\341\352\362\377\050\050\050\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\002\002\002\377\336\336\336\377\377\377\377\377\365\370\373\377\133\222\301\377" +
-		"\072\175\265\377\072\175\265\377\072\175\265\377\110\206\272\377\364\370\373\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\354\363\370\377\144\231\305\377\327\331\333\377\005\005\005\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\044\044\044\377\376\376\376\377\377\377\377\377\377\377\377\377\300\325\347\377" +
-		"\071\174\265\377\072\175\265\377\072\175\265\377\072\175\265\377\253\310\340\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\376\377\377\377" +
-		"\170\246\314\377\173\247\315\377\236\236\236\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\145\145\145\377\377\377\377\377\377\377\377\377\377\377\377\377\342\354\364\377" +
-		"\067\173\264\377\072\175\265\377\072\175\265\377\072\175\265\377\146\232\305\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\303\327\350\377" +
-		"\071\175\265\377\262\314\341\377\130\130\130\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\251\251\251\377\377\377\377\377\377\377\377\377\377\377\377\377\274\322\345\377" +
-		"\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\100\201\267\377\356\364\371\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\372\374\375\377\132\222\301\377" +
-		"\075\177\266\377\335\345\355\377\034\034\034\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\007\007\007\377\347\347\347\377\377\377\377\377\377\377\377\377\377\377\377\377\205\256\321\377" +
-		"\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\071\175\265\377\314\336\354\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\376\376\376\377\377\377\377\377\377\377\377\377\377\377\377\377\272\322\345\377\072\175\265\377" +
-		"\127\220\277\377\320\321\321\377\003\003\003\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\063\063\063\377\375\375\375\377\377\377\377\377\377\377\377\377\373\374\375\377\120\213\275\377" +
-		"\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\071\175\265\377\261\314\342\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\312\312\312\377\067\067\067\377\141\141\141\377\242\242\242\377\335\335\335\377\344\354\363\377\261\313\341\377" +
-		"\264\315\342\377\346\346\346\377\043\043\043\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\162\162\162\377\377\377\377\377\377\377\377\377\377\377\377\377\330\345\360\377\072\175\265\377" +
-		"\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\240\300\333\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\146\146\146\377\000\000\000\377\000\000\000\377\000\000\000\377\006\006\006\377\047\047\047\377\146\146\146\377" +
-		"\324\324\324\377\377\377\377\377\366\366\366\377\320\320\320\377\227\227\227\377\136\136\136\377\047\047\047\377\004\004\004\377" +
-		"\000\000\000\377\003\003\003\377\300\300\300\377\377\377\377\377\377\377\377\377\377\377\377\377\242\301\333\377\072\175\265\377" +
-		"\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\236\277\332\377\377\377\377\377\377\377\377\377" +
-		"\373\373\373\377\045\045\045\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\134\134\134\377\377\377\377\377\352\352\352\377\217\217\217\377\265\265\265\377\351\351\351\377\375\375\375\377\347\347\347\377" +
-		"\262\262\262\377\275\275\275\377\376\376\376\377\377\377\377\377\377\377\377\377\377\377\377\377\153\235\307\377\072\175\265\377" +
-		"\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\241\301\334\377\377\377\377\377\377\377\377\377" +
-		"\333\333\333\377\003\003\003\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\203\203\203\377\377\377\377\377\137\137\137\377\000\000\000\377\000\000\000\377\013\013\013\377\067\067\067\377\166\166\166\377" +
-		"\267\267\267\377\360\360\360\377\377\377\377\377\377\377\377\377\377\377\377\377\360\365\371\377\113\210\273\377\075\177\266\377" +
-		"\071\174\265\377\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\262\314\342\377\377\377\377\377\377\377\377\377" +
-		"\232\232\232\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\305\305\305\377\367\367\367\377\035\035\035\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\007\007\007\377\074\074\074\377\337\337\337\377\377\377\377\377\373\374\375\377\374\375\376\377\363\367\372\377" +
-		"\314\335\353\377\236\276\332\377\162\241\311\377\114\211\273\377\072\175\265\377\311\334\353\377\377\377\377\377\377\377\377\377" +
-		"\126\126\126\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\017\017\017\377" +
-		"\371\371\371\377\321\321\321\377\003\003\003\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\216\216\216\377\377\377\377\377\371\371\371\377\204\204\204\377\160\160\160\377" +
-		"\260\260\260\377\352\352\352\377\377\377\377\377\371\373\374\377\334\350\362\377\366\371\374\377\377\377\377\377\377\377\377\377" +
-		"\025\025\025\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\116\116\116\377" +
-		"\377\377\377\377\221\221\221\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\273\273\273\377\377\377\377\377\236\236\236\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\004\004\004\377\057\057\057\377\160\160\160\377\260\260\260\377\346\346\346\377\376\376\376\377\377\377\377\377" +
-		"\071\071\071\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\220\220\220\377" +
-		"\377\377\377\377\115\115\115\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\020\020\020\377\360\360\360\377\377\377\377\377\132\132\132\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\011\011\011\377\062\062\062\377\261\261\261\377" +
-		"\366\366\366\377\241\241\241\377\065\065\065\377\002\002\002\377\000\000\000\377\000\000\000\377\002\002\002\377\321\321\321\377" +
-		"\365\365\365\377\023\023\023\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\105\105\105\377\376\376\376\377\370\370\370\377\035\035\035\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\053\053\053\377" +
-		"\377\377\377\377\377\377\377\377\374\374\374\377\276\276\276\377\120\120\120\377\005\005\005\377\045\045\045\377\371\371\371\377" +
-		"\302\302\302\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\206\206\206\377\377\377\377\377\322\322\322\377\001\001\001\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\103\103\103\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\376\376\376\377\334\334\334\377\340\340\340\377\377\377\377\377" +
-		"\225\225\225\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\001\001\001\377\310\310\310\377\377\377\377\377\216\216\216\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\210\210\210\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\337\337\337\377\051\051\051\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\030\030\030\377\365\365\365\377\377\377\377\377\112\112\112\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\317\317\317\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\361\366\372\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\371\371\371\377\265\265\265\377\113\113\113\377\006\006\006\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\122\122\122\377\377\377\377\377\370\370\370\377\020\020\020\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\034\034\034\377\370\370\370\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\206\257\321\377\220\265\325\377\352\361\367\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\333\333\333\377\170\170\170\377\033\033\033\377\000\000\000\377" +
-		"\000\000\000\377\226\226\226\377\377\377\377\377\306\306\306\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\132\132\132\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\303\330\351\377\072\175\265\377\103\203\270\377" +
-		"\224\270\326\377\355\363\370\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\364\364\364\377\247\247\247\377" +
-		"\205\205\205\377\364\364\364\377\377\377\377\377\206\206\206\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\235\235\235\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\372\373\375\377\135\224\302\377\072\175\265\377" +
-		"\072\175\265\377\106\205\271\377\230\273\330\377\357\364\371\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\233\233\233\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\005\005\005\377\335\335\335\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\305\331\351\377\073\176\266\377" +
-		"\072\175\265\377\072\175\265\377\072\175\265\377\110\206\272\377\236\276\332\377\362\366\372\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\373\373\373\377\216\216\216\377\045\045\045\377\001\001\001\377\000\000\000\377" +
-		"\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\054\054\054\377\374\374\374\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\217\265\325\377" +
-		"\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\112\207\273\377\243\302\334\377\363\367\372\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\372\372\372\377\260\260\260\377\105\105\105\377" +
-		"\004\004\004\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\156\156\156\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\374\375\376\377" +
-		"\205\257\321\377\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\115\211\274\377" +
-		"\250\305\336\377\366\371\374\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\376\376\376\377" +
-		"\322\322\322\377\150\150\150\377\016\016\016\377\000\000\000\377\001\001\001\377\270\270\270\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\376\376\377\377\261\313\342\377\114\211\274\377\071\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377\072\175\265\377" +
-		"\072\175\265\377\115\211\274\377\277\324\347\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\354\354\354\377\223\223\223\377\233\233\233\377\375\375\375\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\363\367\372\377\265\316\343\377\201\254\320\377\145\231\305\377\141\227\304\377\154\236\310\377" +
-		"\217\265\325\377\305\331\351\377\367\372\374\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377" +
-		"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377";
-
-	/** LWJGL Logo - 16 by 16 pixels */
-	public static final ByteBuffer	LWJGLIcon16x16 = loadIcon(LWJGL_ICON_DATA_16x16);
-
-	/** LWJGL Logo - 32 by 32 pixels */
-	public static final ByteBuffer	LWJGLIcon32x32 = loadIcon(LWJGL_ICON_DATA_32x32);
-
-	/** Debug flag. */
-	public static final boolean DEBUG = getPrivilegedBoolean("org.lwjglx.util.Debug");
-
-	public static final boolean CHECKS = !getPrivilegedBoolean("org.lwjglx.util.NoChecks");
-
-	private static final int PLATFORM;
-
-	static {
-		final String osName = getPrivilegedProperty("os.name");
-		if ( osName.startsWith("Windows") )
-			PLATFORM = PLATFORM_WINDOWS;
-		else if ( osName.startsWith("Linux") || osName.startsWith("FreeBSD") || osName.startsWith("SunOS") || osName.startsWith("Unix") )
-			PLATFORM = PLATFORM_LINUX;
-		else if ( osName.startsWith("Mac OS X") || osName.startsWith("Darwin") )
-			PLATFORM = PLATFORM_MACOSX;
-		else
-			throw new LinkageError("Unknown platform: " + osName);
-	}
-
-	private static ByteBuffer loadIcon(String data) {
-		int len = data.length();
-		ByteBuffer bb = BufferUtils.createByteBuffer(len);
-		for(int i=0 ; i<len ; i++) {
-			bb.put(i, (byte)data.charAt(i));
-		}
-		return bb.asReadOnlyBuffer();
-	}
-
-	/**
-	 * @see #PLATFORM_WINDOWS
-	 * @see #PLATFORM_LINUX
-	 * @see #PLATFORM_MACOSX
-	 * @return the current platform type
-	 */
-	public static int getPlatform() {
-		return PLATFORM;
-	}
-
-
-	/**
-	 * @see #PLATFORM_WINDOWS_NAME
-	 * @see #PLATFORM_LINUX_NAME
-	 * @see #PLATFORM_MACOSX_NAME
-	 * @return current platform name
-	 */
-	public static String getPlatformName() {
-		switch (LWJGLUtil.getPlatform()) {
-			case LWJGLUtil.PLATFORM_LINUX:
-				return PLATFORM_LINUX_NAME;
-			case LWJGLUtil.PLATFORM_MACOSX:
-				return PLATFORM_MACOSX_NAME;
-			case LWJGLUtil.PLATFORM_WINDOWS:
-				return PLATFORM_WINDOWS_NAME;
-			default:
-				return "unknown";
-		}
-	}
-
-	/**
-	 * Locates the paths required by a library.
-	 *
-	 * @param libname Local Library Name to search the classloader with ("openal").
-	 * @param platform_lib_name The native library name ("libopenal.so")
-	 * @param classloader The classloader to ask for library paths
-	 * @return Paths to located libraries, if any
-	 */
-	public static String[] getLibraryPaths(String libname, String platform_lib_name, ClassLoader classloader) {
-		return getLibraryPaths(libname, new String[]{platform_lib_name}, classloader);
-	}
-
-	/**
-	 * Locates the paths required by a library.
-	 *
-	 * @param libname Local Library Name to search the classloader with ("openal").
-	 * @param platform_lib_names The list of possible library names ("libopenal.so")
-	 * @param classloader The classloader to ask for library paths
-	 * @return Paths to located libraries, if any
-	 */
-	public static String[] getLibraryPaths(String libname, String[] platform_lib_names, ClassLoader classloader) {
-		// need to pass path of possible locations of library to native side
-		List<String> possible_paths = new ArrayList<String>();
-
-		String classloader_path = getPathFromClassLoader(libname, classloader);
-		if (classloader_path != null) {
-			log("getPathFromClassLoader: Path found: " + classloader_path);
-			possible_paths.add(classloader_path);
-		}
-
-		for ( String platform_lib_name : platform_lib_names ) {
-			String lwjgl_classloader_path = getPathFromClassLoader("lwjgl", classloader);
-			if ( lwjgl_classloader_path != null ) {
-				log("getPathFromClassLoader: Path found: " + lwjgl_classloader_path);
-				possible_paths.add(lwjgl_classloader_path.substring(0, lwjgl_classloader_path.lastIndexOf(File.separator))
-				                   + File.separator + platform_lib_name);
-			}
-
-			// add Installer path
-			String alternative_path = getPrivilegedProperty("org.lwjgl.librarypath");
-			if ( alternative_path != null ) {
-				possible_paths.add(alternative_path + File.separator + platform_lib_name);
-			}
-
-			// Add all possible paths from java.library.path
-			String java_library_path = getPrivilegedProperty("java.library.path");
-
-			StringTokenizer st = new StringTokenizer(java_library_path, File.pathSeparator);
-			while ( st.hasMoreTokens() ) {
-				String path = st.nextToken();
-				possible_paths.add(path + File.separator + platform_lib_name);
-			}
-
-			//add current path
-			String current_dir = getPrivilegedProperty("user.dir");
-			possible_paths.add(current_dir + File.separator + platform_lib_name);
-
-			//add pure library (no path, let OS search)
-			possible_paths.add(platform_lib_name);
-		}
-
-		//create needed string array
-		return possible_paths.toArray(new String[possible_paths.size()]);
-	}
-
-	static void execPrivileged(final String[] cmd_array) throws Exception {
-		try {
-			Process process = AccessController.doPrivileged(new PrivilegedExceptionAction<Process>() {
-				public Process run() throws Exception {
-					return Runtime.getRuntime().exec(cmd_array);
-				}
-			});
-			// Close unused streams to make sure the child process won't hang
-			process.getInputStream().close();
-			process.getOutputStream().close();
-			process.getErrorStream().close();
-		} catch (PrivilegedActionException e) {
-			throw (Exception)e.getCause();
-		}
-	}
-
-	private static String getPrivilegedProperty(final String property_name) {
-		return AccessController.doPrivileged(new PrivilegedAction<String>() {
-			public String run() {
-				return System.getProperty(property_name);
-			}
-		});
-	}
-
-	/**
-	 * Tries to locate named library from the current ClassLoader
-	 * This method exists because native libraries are loaded from native code, and as such
-	 * is exempt from ClassLoader library loading rutines. It therefore always fails.
-	 * We therefore invoke the protected method of the ClassLoader to see if it can
-	 * locate it.
-	 *
-	 * @param libname Name of library to search for
-	 * @param classloader Classloader to use
-	 * @return Absolute path to library if found, otherwise null
-	 */
-	private static String getPathFromClassLoader(final String libname, final ClassLoader classloader) {
-		try {
-			log("getPathFromClassLoader: searching for: " + libname);
-			Class<?> c = classloader.getClass();
-			while (c != null) {
-				final Class<?> clazz = c;
-				try {
-					return AccessController.doPrivileged(new PrivilegedExceptionAction<String>() {
-						public String run() throws Exception {
-							Method findLibrary = clazz.getDeclaredMethod("findLibrary", String.class);
-							findLibrary.setAccessible(true);
-							String path = (String)findLibrary.invoke(classloader, libname);
-							return path;
-						}
-					});
-				} catch (PrivilegedActionException e) {
-					log("Failed to locate findLibrary method: " + e.getCause());
-					c = c.getSuperclass();
-				}
-			}
-		} catch (Exception e) {
-			log("Failure locating " + e + " using classloader:" + e);
-		}
-		return null;
-	}
-
-	/**
-	 * Gets a boolean property as a privileged action.
-	 */
-	public static boolean getPrivilegedBoolean(final String property_name) {
-		return AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
-			public Boolean run() {
-				return Boolean.getBoolean(property_name);
-			}
-		});
-	}
-
-	/**
-	 * Gets an integer property as a privileged action.
-	 *
-	 * @param property_name the integer property name
-	 *
-	 * @return the property value
-	 */
-	public static Integer getPrivilegedInteger(final String property_name) {
-		return AccessController.doPrivileged(new PrivilegedAction<Integer>() {
-			public Integer run() {
-				return Integer.getInteger(property_name);
-			}
-		});
-	}
-
-	/**
-	 * Gets an integer property as a privileged action.
-	 *
-	 * @param property_name the integer property name
-	 * @param default_val   the default value to use if the property is not defined
-	 *
-	 * @return the property value
-	 */
-	public static Integer getPrivilegedInteger(final String property_name, final int default_val) {
-		return AccessController.doPrivileged(new PrivilegedAction<Integer>() {
-			public Integer run() {
-				return Integer.getInteger(property_name, default_val);
-			}
-		});
-	}
-
-	/**
-	 * Prints the given message to System.err if DEBUG is true.
-	 *
-	 * @param msg Message to print
-	 */
-	public static void log(CharSequence msg) {
-		if (DEBUG) {
-			System.err.println("[LWJGL] " + msg);
-		}
-	}
-
-	/**
-	 * Method to determine if the current system is running a version of
-	 * Mac OS X better than the given version. This is only useful for Mac OS X
-	 * specific code and will not work for any other platform.
-	 */
-	public static boolean isMacOSXEqualsOrBetterThan(int major_required, int minor_required) {
-		String os_version = getPrivilegedProperty("os.version");
-		StringTokenizer version_tokenizer = new StringTokenizer(os_version, ".");
-		int major;
-		int minor;
-		try {
-			String major_str = version_tokenizer.nextToken();
-			String minor_str = version_tokenizer.nextToken();
-			major = Integer.parseInt(major_str);
-			minor = Integer.parseInt(minor_str);
-		} catch (Exception e) {
-			LWJGLUtil.log("Exception occurred while trying to determine OS version: " + e);
-			// Best guess, no
-			return false;
-		}
-		return major > major_required || (major == major_required && minor >= minor_required);
-	}
-
-	/**
-	 * Returns a map of public static final integer fields in the specified classes, to their String representations.
-	 * An optional filter can be specified to only include specific fields. The target map may be null, in which
-	 * case a new map is allocated and returned.
-	 * <p>
-	 * This method is useful when debugging to quickly identify values returned from the AL/GL/CL APIs.
-	 *
-	 * @param filter       the filter to use (optional)
-	 * @param target       the target map (optional)
-	 * @param tokenClasses an array of classes to get tokens from
-	 *
-	 * @return the token map
-	 */
-
-	public static Map<Integer, String> getClassTokens(final TokenFilter filter, final Map<Integer, String> target, final Class ... tokenClasses) {
-		return getClassTokens(filter, target, Arrays.asList(tokenClasses));
-	}
-
-	/**
-	 * Returns a map of public static final integer fields in the specified classes, to their String representations.
-	 * An optional filter can be specified to only include specific fields. The target map may be null, in which
-	 * case a new map is allocated and returned.
-	 * <p>
-	 * This method is useful when debugging to quickly identify values returned from the AL/GL/CL APIs.
-	 *
-	 * @param filter       the filter to use (optional)
-	 * @param target       the target map (optional)
-	 * @param tokenClasses the classes to get tokens from
-	 *
-	 * @return the token map
-	 */
-	public static Map<Integer, String> getClassTokens(final TokenFilter filter, Map<Integer, String> target, final Iterable<Class> tokenClasses) {
-		if ( target == null )
-			target = new HashMap<Integer, String>();
-
-		final int TOKEN_MODIFIERS = Modifier.PUBLIC | Modifier.STATIC | Modifier.FINAL;
-
-		for ( final Class tokenClass : tokenClasses ) {
-			for ( final Field field : tokenClass.getDeclaredFields() ) {
-				// Get only <public static final int> fields.
-				if ( (field.getModifiers() & TOKEN_MODIFIERS) == TOKEN_MODIFIERS && field.getType() == int.class ) {
-					try {
-						final int value = field.getInt(null);
-						if ( filter != null && !filter.accept(field, value) )
-							continue;
-
-						if ( target.containsKey(value) ) // Print colliding tokens in their hex representation.
-							target.put(value, toHexString(value));
-						else
-							target.put(value, field.getName());
-					} catch (IllegalAccessException e) {
-						// Ignore
-					}
-				}
-			}
-		}
-
-		return target;
-	}
-
-	/**
-	 * Returns a string representation of the integer argument as an
-	 * unsigned integer in base&nbsp;16. The string will be uppercase
-	 * and will have a leading '0x'.
-	 *
-	 * @param value the integer value
-	 *
-	 * @return the hex string representation
-	 */
-	public static String toHexString(final int value) {
-		return "0x" + Integer.toHexString(value).toUpperCase();
-	}
-
-	/** Simple interface for Field filtering. */
-	public interface TokenFilter {
-
-		/**
-		 * Should return true if the specified Field passes the filter.
-		 *
-		 * @param field the Field to test
-		 * @param value the integer value of the field
-		 *
-		 * @result true if the Field is accepted
-		 */
-		boolean accept(Field field, int value);
-
-	}
-
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/MemoryUtil.java b/src/embeddedlibs/org/lwjglx/MemoryUtil.java
deleted file mode 100644
index bcb22e2..0000000
--- a/src/embeddedlibs/org/lwjglx/MemoryUtil.java
+++ /dev/null
@@ -1,430 +0,0 @@
-/*
- * Copyright (c) 2002-2011 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx;
-
-import java.lang.reflect.Field;
-import java.nio.*;
-import java.nio.charset.*;
-
-/**
- * [INTERNAL USE ONLY]
- * <p/>
- * This class provides utility methods for passing buffers to JNI API calls.
- *
- * @author Spasi
- */
-public final class MemoryUtil {
-
-	private static final Charset ascii;
-	private static final Charset utf8;
-	private static final Charset utf16;
-
-	static {
-		ascii = Charset.forName("ISO-8859-1");
-		utf8 = Charset.forName("UTF-8");
-		utf16 = Charset.forName("UTF-16LE");
-	}
-
-	private static final Accessor memUtil;
-
-	static {
-		Accessor util;
-		try {
-			// Depends on java.nio.Buffer#address and sun.misc.Unsafe
-			util = loadAccessor("org.lwjgl.MemoryUtilSun$AccessorUnsafe");
-		} catch (Exception e0) {
-			try {
-				// Depends on java.nio.Buffer#address and sun.reflect.FieldAccessor
-				util = loadAccessor("org.lwjgl.MemoryUtilSun$AccessorReflectFast");
-			} catch (Exception e1) {
-				try {
-					// Depends on java.nio.Buffer#address
-					util = new AccessorReflect();
-				} catch (Exception e2) {
-					LWJGLUtil.log("Unsupported JVM detected, this will likely result in low performance. Please inform LWJGL developers.");
-					util = new AccessorJNI();
-				}
-			}
-		}
-
-		LWJGLUtil.log("MemoryUtil Accessor: " + util.getClass().getSimpleName());
-		memUtil = util;
-
-		/*
-		BENCHMARK RESULTS - Oracle Server VM:
-
-		Unsafe: 4ns
-		ReflectFast: 8ns
-		Reflect: 10ns
-		JNI: 82ns
-
-		BENCHMARK RESULTS - Oracle Client VM:
-
-		Unsafe: 5ns
-		ReflectFast: 81ns
-		Reflect: 85ns
-		JNI: 87ns
-
-		On non-Oracle VMs, Unsafe should be the fastest implementation as well. In the absence
-		of Unsafe, performance will depend on how reflection and JNI are implemented. For now
-		we'll go with what we see on the Oracle VM (that is, we'll prefer reflection over JNI).
-		 */
-	}
-
-	private MemoryUtil() {
-	}
-
-	/**
-	 * Returns the memory address of the specified buffer. [INTERNAL USE ONLY]
-	 *
-	 * @param buffer the buffer
-	 *
-	 * @return the memory address
-	 */
-	public static long getAddress0(Buffer buffer) { return memUtil.getAddress(buffer); }
-
-	public static long getAddress0Safe(Buffer buffer) { return buffer == null ? 0L : memUtil.getAddress(buffer); }
-
-	public static long getAddress0(PointerBuffer buffer) { return memUtil.getAddress(buffer.getBuffer()); }
-
-	public static long getAddress0Safe(PointerBuffer buffer) { return buffer == null ? 0L : memUtil.getAddress(buffer.getBuffer()); }
-
-	// --- [ API utilities ] ---
-
-	public static long getAddress(ByteBuffer buffer) { return getAddress(buffer, buffer.position()); }
-
-	public static long getAddress(ByteBuffer buffer, int position) { return getAddress0(buffer) + position; }
-
-	public static long getAddress(ShortBuffer buffer) { return getAddress(buffer, buffer.position()); }
-
-	public static long getAddress(ShortBuffer buffer, int position) { return getAddress0(buffer) + (position << 1); }
-
-	public static long getAddress(CharBuffer buffer) { return getAddress(buffer, buffer.position()); }
-
-	public static long getAddress(CharBuffer buffer, int position) { return getAddress0(buffer) + (position << 1); }
-
-	public static long getAddress(IntBuffer buffer) { return getAddress(buffer, buffer.position()); }
-
-	public static long getAddress(IntBuffer buffer, int position) { return getAddress0(buffer) + (position << 2); }
-
-	public static long getAddress(FloatBuffer buffer) { return getAddress(buffer, buffer.position()); }
-
-	public static long getAddress(FloatBuffer buffer, int position) { return getAddress0(buffer) + (position << 2); }
-
-	public static long getAddress(LongBuffer buffer) { return getAddress(buffer, buffer.position()); }
-
-	public static long getAddress(LongBuffer buffer, int position) { return getAddress0(buffer) + (position << 3); }
-
-	public static long getAddress(DoubleBuffer buffer) { return getAddress(buffer, buffer.position()); }
-
-	public static long getAddress(DoubleBuffer buffer, int position) { return getAddress0(buffer) + (position << 3); }
-
-	public static long getAddress(PointerBuffer buffer) { return getAddress(buffer, buffer.position()); }
-
-	public static long getAddress(PointerBuffer buffer, int position) { return getAddress0(buffer) + (position * PointerBuffer.getPointerSize()); }
-
-	// --- [ API utilities - Safe ] ---
-
-	public static long getAddressSafe(ByteBuffer buffer) { return buffer == null ? 0L : getAddress(buffer); }
-
-	public static long getAddressSafe(ByteBuffer buffer, int position) { return buffer == null ? 0L : getAddress(buffer, position); }
-
-	public static long getAddressSafe(ShortBuffer buffer) { return buffer == null ? 0L : getAddress(buffer); }
-
-	public static long getAddressSafe(ShortBuffer buffer, int position) { return buffer == null ? 0L : getAddress(buffer, position); }
-
-	public static long getAddressSafe(CharBuffer buffer) { return buffer == null ? 0L : getAddress(buffer); }
-
-	public static long getAddressSafe(CharBuffer buffer, int position) { return buffer == null ? 0L : getAddress(buffer, position); }
-
-	public static long getAddressSafe(IntBuffer buffer) { return buffer == null ? 0L : getAddress(buffer); }
-
-	public static long getAddressSafe(IntBuffer buffer, int position) { return buffer == null ? 0L : getAddress(buffer, position); }
-
-	public static long getAddressSafe(FloatBuffer buffer) { return buffer == null ? 0L : getAddress(buffer); }
-
-	public static long getAddressSafe(FloatBuffer buffer, int position) { return buffer == null ? 0L : getAddress(buffer, position); }
-
-	public static long getAddressSafe(LongBuffer buffer) { return buffer == null ? 0L : getAddress(buffer); }
-
-	public static long getAddressSafe(LongBuffer buffer, int position) { return buffer == null ? 0L : getAddress(buffer, position); }
-
-	public static long getAddressSafe(DoubleBuffer buffer) { return buffer == null ? 0L : getAddress(buffer); }
-
-	public static long getAddressSafe(DoubleBuffer buffer, int position) { return buffer == null ? 0L : getAddress(buffer, position); }
-
-	public static long getAddressSafe(PointerBuffer buffer) { return buffer == null ? 0L : getAddress(buffer); }
-
-	public static long getAddressSafe(PointerBuffer buffer, int position) { return buffer == null ? 0L : getAddress(buffer, position); }
-
-	// --- [ String utilities ] ---
-
-	/**
-	 * Returns a ByteBuffer containing the specified text ASCII encoded and null-terminated.
-	 * If text is null, null is returned.
-	 *
-	 * @param text the text to encode
-	 *
-	 * @return the encoded text or null
-	 *
-	 * @see String#getBytes()
-	 */
-	public static ByteBuffer encodeASCII(final CharSequence text) {
-		return encode(text, ascii);
-	}
-
-	/**
-	 * Returns a ByteBuffer containing the specified text UTF-8 encoded and null-terminated.
-	 * If text is null, null is returned.
-	 *
-	 * @param text the text to encode
-	 *
-	 * @return the encoded text or null
-	 *
-	 * @see String#getBytes()
-	 */
-	public static ByteBuffer encodeUTF8(final CharSequence text) {
-		return encode(text, utf8);
-	}
-
-	/**
-	 * Returns a ByteBuffer containing the specified text UTF-16LE encoded and null-terminated.
-	 * If text is null, null is returned.
-	 *
-	 * @param text the text to encode
-	 *
-	 * @return the encoded text
-	 */
-	public static ByteBuffer encodeUTF16(final CharSequence text) {
-		return encode(text, utf16);
-	}
-
-	/**
-	 * Wraps the specified text in a null-terminated CharBuffer and encodes it using the specified Charset.
-	 *
-	 * @param text    the text to encode
-	 * @param charset the charset to use for encoding
-	 *
-	 * @return the encoded text
-	 */
-	private static ByteBuffer encode(final CharSequence text, final Charset charset) {
-		if ( text == null )
-			return null;
-
-		return encode(CharBuffer.wrap(new CharSequenceNT(text)), charset);
-	}
-
-	/**
-	 * A {@link CharsetEncoder#encode(java.nio.CharBuffer)} implementation that uses {@link BufferUtils#createByteBuffer(int)}
-	 * instead of {@link ByteBuffer#allocate(int)}.
-	 *
-	 * @see CharsetEncoder#encode(java.nio.CharBuffer)
-	 */
-	private static ByteBuffer encode(final CharBuffer in, final Charset charset) {
-		final CharsetEncoder encoder = charset.newEncoder(); // encoders are not thread-safe, create a new one on every call
-
-		int n = (int)(in.remaining() * encoder.averageBytesPerChar());
-		ByteBuffer out = BufferUtils.createByteBuffer(n);
-
-		if ( n == 0 && in.remaining() == 0 )
-			return out;
-
-		encoder.reset();
-		while ( true ) {
-			CoderResult cr = in.hasRemaining() ? encoder.encode(in, out, true) : CoderResult.UNDERFLOW;
-			if ( cr.isUnderflow() )
-				cr = encoder.flush(out);
-
-			if ( cr.isUnderflow() )
-				break;
-
-			if ( cr.isOverflow() ) {
-				n = 2 * n + 1;    // Ensure progress; n might be 0!
-				ByteBuffer o = BufferUtils.createByteBuffer(n);
-				out.flip();
-				o.put(out);
-				out = o;
-				continue;
-			}
-
-			try {
-				cr.throwException();
-			} catch (CharacterCodingException e) {
-				throw new RuntimeException(e);
-			}
-		}
-		out.flip();
-		return out;
-	}
-
-	public static String decodeASCII(final ByteBuffer buffer) {
-		return decode(buffer, ascii);
-	}
-
-	public static String decodeUTF8(final ByteBuffer buffer) {
-		return decode(buffer, utf8);
-	}
-
-	public static String decodeUTF16(final ByteBuffer buffer) {
-		return decode(buffer, utf16);
-	}
-
-	private static String decode(final ByteBuffer buffer, final Charset charset) {
-		if ( buffer == null )
-			return null;
-
-		return decodeImpl(buffer, charset);
-	}
-
-	private static String decodeImpl(final ByteBuffer in, final Charset charset) {
-		final CharsetDecoder decoder = charset.newDecoder(); // decoders are not thread-safe, create a new one on every call
-
-		int n = (int)(in.remaining() * decoder.averageCharsPerByte());
-		CharBuffer out = BufferUtils.createCharBuffer(n);
-
-		if ( (n == 0) && (in.remaining() == 0) )
-			return "";
-
-		decoder.reset();
-		for (; ; ) {
-			CoderResult cr = in.hasRemaining() ? decoder.decode(in, out, true) : CoderResult.UNDERFLOW;
-			if ( cr.isUnderflow() )
-				cr = decoder.flush(out);
-
-			if ( cr.isUnderflow() )
-				break;
-			if ( cr.isOverflow() ) {
-				n = 2 * n + 1;    // Ensure progress; n might be 0!
-				CharBuffer o = BufferUtils.createCharBuffer(n);
-				out.flip();
-				o.put(out);
-				out = o;
-				continue;
-			}
-			try {
-				cr.throwException();
-			} catch (CharacterCodingException e) {
-				throw new RuntimeException(e);
-			}
-		}
-		out.flip();
-		return out.toString();
-	}
-
-	/** A null-terminated CharSequence. */
-	private static class CharSequenceNT implements CharSequence {
-
-		final CharSequence source;
-
-		CharSequenceNT(CharSequence source) {
-			this.source = source;
-		}
-
-		public int length() {
-			return source.length() + 1;
-
-		}
-
-		public char charAt(final int index) {
-			return index == source.length() ? '\0' : source.charAt(index);
-
-		}
-
-		public CharSequence subSequence(final int start, final int end) {
-			return new CharSequenceNT(source.subSequence(start, Math.min(end, source.length())));
-		}
-
-	}
-
-	interface Accessor {
-
-		long getAddress(Buffer buffer);
-
-	}
-
-	private static Accessor loadAccessor(final String className) throws Exception {
-		return (Accessor)Class.forName(className).newInstance();
-	}
-
-	/** Default implementation. */
-	private static class AccessorJNI implements Accessor {
-
-		public long getAddress(final Buffer buffer) {
-			return BufferUtils.getBufferAddress(buffer);
-		}
-
-	}
-
-	/** Implementation using reflection on ByteBuffer. */
-	private static class AccessorReflect implements Accessor {
-
-		private final Field address;
-
-		AccessorReflect() {
-			try {
-				address = getAddressField();
-			} catch (NoSuchFieldException e) {
-				throw new UnsupportedOperationException(e);
-			}
-			address.setAccessible(true);
-		}
-
-		public long getAddress(final Buffer buffer) {
-			try {
-				return address.getLong(buffer);
-			} catch (IllegalAccessException e) {
-				// cannot happen
-				return 0L;
-			}
-		}
-
-	}
-
-	static Field getAddressField() throws NoSuchFieldException {
-		return getDeclaredFieldRecursive(ByteBuffer.class, "address");
-	}
-
-	private static Field getDeclaredFieldRecursive(final Class<?> root, final String fieldName) throws NoSuchFieldException {
-		Class<?> type = root;
-
-		do {
-			try {
-				return type.getDeclaredField(fieldName);
-			} catch (NoSuchFieldException e) {
-				type = type.getSuperclass();
-			}
-		} while ( type != null );
-
-		throw new NoSuchFieldException(fieldName + " does not exist in " + root.getSimpleName() + " or any of its superclasses.");
-	}
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/PointerBuffer.java b/src/embeddedlibs/org/lwjglx/PointerBuffer.java
deleted file mode 100644
index d1fd7b0..0000000
--- a/src/embeddedlibs/org/lwjglx/PointerBuffer.java
+++ /dev/null
@@ -1,960 +0,0 @@
-/*
- * Copyright (c) 2002-2010 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx;
-
-import java.lang.reflect.Method;
-import java.nio.*;
-
-/**
- * This class is a container for architecture independent pointer data.
- * The interface mirrors the NIO LongBuffer API for convenience.
- *
- * @author Spasi
- */
-public class PointerBuffer implements Comparable {
-
-	private static final boolean is64Bit;
-
-	static {
-		// Use reflection so that we can compile this class for the Generator.
-		boolean is64 = false;
-		try {
-			Method m = Class.forName("org.lwjgl.Sys").getDeclaredMethod("is64Bit", (Class[])null);
-			is64 = (Boolean)m.invoke(null, (Object[])null);
-		} catch (Throwable t) {
-			// ignore
-		} finally {
-			is64Bit = is64;
-		}
-	}
-
-	protected final ByteBuffer pointers;
-
-	protected final Buffer     view;
-	protected final IntBuffer  view32;
-	protected final LongBuffer view64;
-
-	/**
-	 * Creates a new PointerBuffer with the specified capacity.
-	 *
-	 * @param capacity the PointerBuffer size, in number of pointers
-	 */
-	public PointerBuffer(final int capacity) {
-		this(BufferUtils.createByteBuffer(capacity * getPointerSize()));
-	}
-
-	/**
-	 * Creates a new PointerBuffer using the specified ByteBuffer as its pointer
-	 * data source. This is useful for users that do their own memory management
-	 * over a big ByteBuffer, instead of allocating many small ones.
-	 *
-	 * @param source the source buffer
-	 */
-	public PointerBuffer(final ByteBuffer source) {
-		if ( LWJGLUtil.CHECKS )
-			checkSource(source);
-
-		pointers = source.slice().order(source.order());
-
-		if ( is64Bit ) {
-			view32 = null;
-			view = view64 = pointers.asLongBuffer();
-		} else {
-			view = view32 = pointers.asIntBuffer();
-			view64 = null;
-		}
-	}
-
-	private static void checkSource(final ByteBuffer source) {
-		if ( !source.isDirect() )
-			throw new IllegalArgumentException("The source buffer is not direct.");
-
-		final int alignment = is64Bit ? 8 : 4;
-		if ( (MemoryUtil.getAddress0(source) + source.position()) % alignment != 0 || source.remaining() % alignment != 0 )
-			throw new IllegalArgumentException("The source buffer is not aligned to " + alignment + " bytes.");
-	}
-
-	/**
-	 * Returns the ByteBuffer that backs this PointerBuffer.
-	 *
-	 * @return the pointer ByteBuffer
-	 */
-	public ByteBuffer getBuffer() {
-		return pointers;
-	}
-
-	/** Returns true if the underlying architecture is 64bit. */
-	public static boolean is64Bit() {
-		return is64Bit;
-	}
-
-	/**
-	 * Returns the pointer size in bytes, based on the underlying architecture.
-	 *
-	 * @return The pointer size in bytes
-	 */
-	public static int getPointerSize() {
-		return is64Bit ? 8 : 4;
-	}
-
-	/**
-	 * Returns this buffer's capacity. </p>
-	 *
-	 * @return The capacity of this buffer
-	 */
-	public final int capacity() {
-		return view.capacity();
-	}
-
-	/**
-	 * Returns this buffer's position. </p>
-	 *
-	 * @return The position of this buffer
-	 */
-	public final int position() {
-		return view.position();
-	}
-
-	/**
-	 * Returns this buffer's position, in bytes. </p>
-	 *
-	 * @return The position of this buffer in bytes.
-	 */
-	public final int positionByte() {
-		return position() * getPointerSize();
-	}
-
-	/**
-	 * Sets this buffer's position.  If the mark is defined and larger than the
-	 * new position then it is discarded. </p>
-	 *
-	 * @param newPosition The new position value; must be non-negative
-	 *                    and no larger than the current limit
-	 *
-	 * @return This buffer
-	 *
-	 * @throws IllegalArgumentException If the preconditions on <tt>newPosition</tt> do not hold
-	 */
-	public final PointerBuffer position(int newPosition) {
-		view.position(newPosition);
-		return this;
-	}
-
-	/**
-	 * Returns this buffer's limit. </p>
-	 *
-	 * @return The limit of this buffer
-	 */
-	public final int limit() {
-		return view.limit();
-	}
-
-	/**
-	 * Sets this buffer's limit.  If the position is larger than the new limit
-	 * then it is set to the new limit.  If the mark is defined and larger than
-	 * the new limit then it is discarded. </p>
-	 *
-	 * @param newLimit The new limit value; must be non-negative
-	 *                 and no larger than this buffer's capacity
-	 *
-	 * @return This buffer
-	 *
-	 * @throws IllegalArgumentException If the preconditions on <tt>newLimit</tt> do not hold
-	 */
-	public final PointerBuffer limit(int newLimit) {
-		view.limit(newLimit);
-		return this;
-	}
-
-	/**
-	 * Sets this buffer's mark at its position. </p>
-	 *
-	 * @return This buffer
-	 */
-	public final PointerBuffer mark() {
-		view.mark();
-		return this;
-	}
-
-	/**
-	 * Resets this buffer's position to the previously-marked position.
-	 * <p/>
-	 * <p> Invoking this method neither changes nor discards the mark's
-	 * value. </p>
-	 *
-	 * @return This buffer
-	 *
-	 * @throws java.nio.InvalidMarkException If the mark has not been set
-	 */
-	public final PointerBuffer reset() {
-		view.reset();
-		return this;
-	}
-
-	/**
-	 * Clears this buffer.  The position is set to zero, the limit is set to
-	 * the capacity, and the mark is discarded.
-	 * <p/>
-	 * <p> Invoke this method before using a sequence of channel-read or
-	 * <i>put</i> operations to fill this buffer.  For example:
-	 * <p/>
-	 * <blockquote><pre>
-	 * buf.clear();     // Prepare buffer for reading
-	 * in.read(buf);    // Read data</pre></blockquote>
-	 * <p/>
-	 * <p> This method does not actually erase the data in the buffer, but it
-	 * is named as if it did because it will most often be used in situations
-	 * in which that might as well be the case. </p>
-	 *
-	 * @return This buffer
-	 */
-	public final PointerBuffer clear() {
-		view.clear();
-		return this;
-	}
-
-	/**
-	 * Flips this buffer.  The limit is set to the current position and then
-	 * the position is set to zero.  If the mark is defined then it is
-	 * discarded.
-	 * <p/>
-	 * <p> After a sequence of channel-read or <i>put</i> operations, invoke
-	 * this method to prepare for a sequence of channel-write or relative
-	 * <i>get</i> operations.  For example:
-	 * <p/>
-	 * <blockquote><pre>
-	 * buf.put(magic);    // Prepend header
-	 * in.read(buf);      // Read data into rest of buffer
-	 * buf.flip();        // Flip buffer
-	 * out.write(buf);    // Write header + data to channel</pre></blockquote>
-	 * <p/>
-	 * <p> This method is often used in conjunction with the {@link
-	 * java.nio.ByteBuffer#compact compact} method when transferring data from
-	 * one place to another.  </p>
-	 *
-	 * @return This buffer
-	 */
-	public final PointerBuffer flip() {
-		view.flip();
-		return this;
-	}
-
-	/**
-	 * Rewinds this buffer.  The position is set to zero and the mark is
-	 * discarded.
-	 * <p/>
-	 * <p> Invoke this method before a sequence of channel-write or <i>get</i>
-	 * operations, assuming that the limit has already been set
-	 * appropriately.  For example:
-	 * <p/>
-	 * <blockquote><pre>
-	 * out.write(buf);    // Write remaining data
-	 * buf.rewind();      // Rewind buffer
-	 * buf.get(array);    // Copy data into array</pre></blockquote>
-	 *
-	 * @return This buffer
-	 */
-	public final PointerBuffer rewind() {
-		view.rewind();
-		return this;
-	}
-
-	/**
-	 * Returns the number of elements between the current position and the
-	 * limit. </p>
-	 *
-	 * @return The number of elements remaining in this buffer
-	 */
-	public final int remaining() {
-		return view.remaining();
-	}
-
-	/**
-	 * Returns the number of bytes between the current position and the
-	 * limit. </p>
-	 *
-	 * @return The number of bytes remaining in this buffer
-	 */
-	public final int remainingByte() {
-		return remaining() * getPointerSize();
-	}
-
-	/**
-	 * Tells whether there are any elements between the current position and
-	 * the limit. </p>
-	 *
-	 * @return <tt>true</tt> if, and only if, there is at least one element
-	 *         remaining in this buffer
-	 */
-	public final boolean hasRemaining() {
-		return view.hasRemaining();
-	}
-
-	/**
-	 * Allocates a new pointer buffer.
-	 * <p/>
-	 * <p> The new buffer's position will be zero, its limit will be its
-	 * capacity, and its mark will be undefined.  </p>
-	 *
-	 * @param capacity The new buffer's capacity, in pointers
-	 *
-	 * @return The new pointer buffer
-	 *
-	 * @throws IllegalArgumentException If the <tt>capacity</tt> is a negative integer
-	 */
-	public static PointerBuffer allocateDirect(int capacity) {
-		return new PointerBuffer(capacity);
-	}
-
-	/**
-	 * This method is used in slice and duplicate instead of normal object construction,
-	 * so that subclasses can return themselves.
-	 *
-	 * @param source
-	 *
-	 * @return A new PointerBuffer instance
-	 */
-	protected PointerBuffer newInstance(final ByteBuffer source) {
-		return new PointerBuffer(source);
-	}
-
-	/**
-	 * Creates a new pointer buffer whose content is a shared subsequence of
-	 * this buffer's content.
-	 * <p/>
-	 * <p> The content of the new buffer will start at this buffer's current
-	 * position.  Changes to this buffer's content will be visible in the new
-	 * buffer, and vice versa; the two buffers' position, limit, and mark
-	 * values will be independent.
-	 * <p/>
-	 * <p> The new buffer's position will be zero, its capacity and its limit
-	 * will be the number of longs remaining in this buffer, and its mark
-	 * will be undefined.  The new buffer will be direct if, and only if, this
-	 * buffer is direct, and it will be read-only if, and only if, this buffer
-	 * is read-only.  </p>
-	 *
-	 * @return The new pointer buffer
-	 */
-	public PointerBuffer slice() {
-		final int pointerSize = getPointerSize();
-
-		pointers.position(view.position() * pointerSize);
-		pointers.limit(view.limit() * pointerSize);
-
-		try {
-			// We're slicing in the constructor.
-			return newInstance(pointers);
-		} finally {
-			pointers.clear();
-		}
-	}
-
-	/**
-	 * Creates a new pointer buffer that shares this buffer's content.
-	 * <p/>
-	 * <p> The content of the new buffer will be that of this buffer.  Changes
-	 * to this buffer's content will be visible in the new buffer, and vice
-	 * versa; the two buffers' position, limit, and mark values will be
-	 * independent.
-	 * <p/>
-	 * <p> The new buffer's capacity, limit and position will be
-	 * identical to those of this buffer.  The new buffer will be direct if,
-	 * and only if, this buffer is direct, and it will be read-only if, and
-	 * only if, this buffer is read-only.  </p>
-	 *
-	 * @return The new pointer buffer
-	 */
-	public PointerBuffer duplicate() {
-		final PointerBuffer buffer = newInstance(pointers);
-
-		buffer.position(view.position());
-		buffer.limit(view.limit());
-
-		return buffer;
-	}
-
-	/**
-	 * Creates a new, read-only pointer buffer that shares this buffer's
-	 * content.
-	 * <p/>
-	 * <p> The content of the new buffer will be that of this buffer.  Changes
-	 * to this buffer's content will be visible in the new buffer; the new
-	 * buffer itself, however, will be read-only and will not allow the shared
-	 * content to be modified.  The two buffers' position, limit, and mark
-	 * values will be independent.
-	 * <p/>
-	 * <p> The new buffer's capacity, limit and position will be
-	 * identical to those of this buffer.
-	 * <p/>
-	 * <p> If this buffer is itself read-only then this method behaves in
-	 * exactly the same way as the {@link #duplicate duplicate} method.  </p>
-	 *
-	 * @return The new, read-only pointer buffer
-	 */
-	public PointerBuffer asReadOnlyBuffer() {
-		final PointerBuffer buffer = new PointerBufferR(pointers);
-
-		buffer.position(view.position());
-		buffer.limit(view.limit());
-
-		return buffer;
-	}
-
-	public boolean isReadOnly() {
-		return false;
-	}
-
-	/**
-	 * Relative <i>get</i> method.  Reads the long at this buffer's
-	 * current position, and then increments the position. </p>
-	 *
-	 * @return The long at the buffer's current position
-	 *
-	 * @throws BufferUnderflowException If the buffer's current position is not smaller than its limit
-	 */
-	public long get() {
-		if ( is64Bit )
-			return view64.get();
-		else
-			return view32.get() & 0x00000000FFFFFFFFL;
-	}
-
-	/**
-	 * Relative <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.
-	 * <p/>
-	 * <p> Writes the given long into this buffer at the current
-	 * position, and then increments the position. </p>
-	 *
-	 * @param l The long to be written
-	 *
-	 * @return This buffer
-	 *
-	 * @throws BufferOverflowException If this buffer's current position is not smaller than its limit
-	 * @throws ReadOnlyBufferException If this buffer is read-only
-	 */
-	public PointerBuffer put(long l) {
-		if ( is64Bit )
-			view64.put(l);
-		else
-			view32.put((int)l);
-		return this;
-	}
-
-	/**
-	 * Convenience put that accepts PointerWrapper objects.
-	 *
-	 * @see #put(long)
-	 */
-	public PointerBuffer put(final PointerWrapper pointer) {
-		return put(pointer.getPointer());
-	}
-
-	/**
-	 * Convenience put on a target ByteBuffer.
-	 *
-	 * @param target the target ByteBuffer
-	 * @param l      the long value to be written
-	 */
-	public static void put(final ByteBuffer target, long l) {
-		if ( is64Bit )
-			target.putLong(l);
-		else
-			target.putInt((int)l);
-	}
-
-	/**
-	 * Absolute <i>get</i> method.  Reads the long at the given
-	 * index. </p>
-	 *
-	 * @param index The index from which the long will be read
-	 *
-	 * @return The long at the given index
-	 *
-	 * @throws IndexOutOfBoundsException If <tt>index</tt> is negative
-	 *                                   or not smaller than the buffer's limit
-	 */
-	public long get(int index) {
-		if ( is64Bit )
-			return view64.get(index);
-		else
-			return view32.get(index) & 0x00000000FFFFFFFFL;
-	}
-
-	/**
-	 * Absolute <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.
-	 * <p/>
-	 * <p> Writes the given long into this buffer at the given
-	 * index. </p>
-	 *
-	 * @param index The index at which the long will be written
-	 * @param l     The long value to be written
-	 *
-	 * @return This buffer
-	 *
-	 * @throws IndexOutOfBoundsException If <tt>index</tt> is negative
-	 *                                   or not smaller than the buffer's limit
-	 * @throws ReadOnlyBufferException   If this buffer is read-only
-	 */
-	public PointerBuffer put(int index, long l) {
-		if ( is64Bit )
-			view64.put(index, l);
-		else
-			view32.put(index, (int)l);
-		return this;
-	}
-
-	/**
-	 * Convenience put that accepts PointerWrapper objects.
-	 *
-	 * @see #put(int, long)
-	 */
-	public PointerBuffer put(int index, PointerWrapper pointer) {
-		return put(index, pointer.getPointer());
-	}
-
-	/**
-	 * Convenience put on a target ByteBuffer.
-	 *
-	 * @param target the target ByteBuffer
-	 * @param index  the index at which the long will be written
-	 * @param l      the long value to be written
-	 */
-	public static void put(final ByteBuffer target, int index, long l) {
-		if ( is64Bit )
-			target.putLong(index * 8, l);
-		else
-			target.putInt(index * 4, (int)l);
-	}
-
-	// -- Bulk get operations --
-
-	/**
-	 * Relative bulk <i>get</i> method.
-	 * <p/>
-	 * <p> This method transfers longs from this buffer into the given
-	 * destination array.  If there are fewer longs remaining in the
-	 * buffer than are required to satisfy the request, that is, if
-	 * <tt>length</tt>&nbsp;<tt>&gt;</tt>&nbsp;<tt>remaining()</tt>, then no
-	 * longs are transferred and a {@link BufferUnderflowException} is
-	 * thrown.
-	 * <p/>
-	 * <p> Otherwise, this method copies <tt>length</tt> longs from this
-	 * buffer into the given array, starting at the current position of this
-	 * buffer and at the given offset in the array.  The position of this
-	 * buffer is then incremented by <tt>length</tt>.
-	 * <p/>
-	 * <p> In other words, an invocation of this method of the form
-	 * <tt>src.get(dst,&nbsp;off,&nbsp;len)</tt> has exactly the same effect as
-	 * the loop
-	 * <p/>
-	 * <pre>
-	 *     for (int i = off; i < off + len; i++)
-	 *         dst[i] = src.get(); </pre>
-	 * <p/>
-	 * except that it first checks that there are sufficient longs in
-	 * this buffer and it is potentially much more efficient. </p>
-	 *
-	 * @param dst    The array into which longs are to be written
-	 * @param offset The offset within the array of the first long to be
-	 *               written; must be non-negative and no larger than
-	 *               <tt>dst.length</tt>
-	 * @param length The maximum number of longs to be written to the given
-	 *               array; must be non-negative and no larger than
-	 *               <tt>dst.length - offset</tt>
-	 *
-	 * @return This buffer
-	 *
-	 * @throws BufferUnderflowException  If there are fewer than <tt>length</tt> longs
-	 *                                   remaining in this buffer
-	 * @throws IndexOutOfBoundsException If the preconditions on the <tt>offset</tt> and <tt>length</tt>
-	 *                                   parameters do not hold
-	 */
-	public PointerBuffer get(long[] dst, int offset, int length) {
-		if ( is64Bit )
-			view64.get(dst, offset, length);
-		else {
-			checkBounds(offset, length, dst.length);
-			if ( length > view32.remaining() )
-				throw new BufferUnderflowException();
-			int end = offset + length;
-			for ( int i = offset; i < end; i++ )
-				dst[i] = view32.get() & 0x00000000FFFFFFFFL;
-		}
-
-		return this;
-	}
-
-	/**
-	 * Relative bulk <i>get</i> method.
-	 * <p/>
-	 * <p> This method transfers longs from this buffer into the given
-	 * destination array.  An invocation of this method of the form
-	 * <tt>src.get(a)</tt> behaves in exactly the same way as the invocation
-	 * <p/>
-	 * <pre>
-	 *     src.get(a, 0, a.length) </pre>
-	 *
-	 * @return This buffer
-	 *
-	 * @throws BufferUnderflowException If there are fewer than <tt>length</tt> longs
-	 *                                  remaining in this buffer
-	 */
-	public PointerBuffer get(long[] dst) {
-		return get(dst, 0, dst.length);
-	}
-
-	/**
-	 * Relative bulk <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.
-	 * <p/>
-	 * <p> This method transfers the longs remaining in the given source
-	 * buffer into this buffer.  If there are more longs remaining in the
-	 * source buffer than in this buffer, that is, if
-	 * <tt>src.remaining()</tt>&nbsp;<tt>&gt;</tt>&nbsp;<tt>remaining()</tt>,
-	 * then no longs are transferred and a {@link
-	 * BufferOverflowException} is thrown.
-	 * <p/>
-	 * <p> Otherwise, this method copies
-	 * <i>n</i>&nbsp;=&nbsp;<tt>src.remaining()</tt> longs from the given
-	 * buffer into this buffer, starting at each buffer's current position.
-	 * The positions of both buffers are then incremented by <i>n</i>.
-	 * <p/>
-	 * <p> In other words, an invocation of this method of the form
-	 * <tt>dst.put(src)</tt> has exactly the same effect as the loop
-	 * <p/>
-	 * <pre>
-	 *     while (src.hasRemaining())
-	 *         dst.put(src.get()); </pre>
-	 * <p/>
-	 * except that it first checks that there is sufficient space in this
-	 * buffer and it is potentially much more efficient. </p>
-	 *
-	 * @param src The source buffer from which longs are to be read;
-	 *            must not be this buffer
-	 *
-	 * @return This buffer
-	 *
-	 * @throws BufferOverflowException  If there is insufficient space in this buffer
-	 *                                  for the remaining longs in the source buffer
-	 * @throws IllegalArgumentException If the source buffer is this buffer
-	 * @throws ReadOnlyBufferException  If this buffer is read-only
-	 */
-	public PointerBuffer put(PointerBuffer src) {
-		if ( is64Bit )
-			view64.put(src.view64);
-		else
-			view32.put(src.view32);
-		return this;
-	}
-
-	/**
-	 * Relative bulk <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.
-	 * <p/>
-	 * <p> This method transfers longs into this buffer from the given
-	 * source array.  If there are more longs to be copied from the array
-	 * than remain in this buffer, that is, if
-	 * <tt>length</tt>&nbsp;<tt>&gt;</tt>&nbsp;<tt>remaining()</tt>, then no
-	 * longs are transferred and a {@link BufferOverflowException} is
-	 * thrown.
-	 * <p/>
-	 * <p> Otherwise, this method copies <tt>length</tt> longs from the
-	 * given array into this buffer, starting at the given offset in the array
-	 * and at the current position of this buffer.  The position of this buffer
-	 * is then incremented by <tt>length</tt>.
-	 * <p/>
-	 * <p> In other words, an invocation of this method of the form
-	 * <tt>dst.put(src,&nbsp;off,&nbsp;len)</tt> has exactly the same effect as
-	 * the loop
-	 * <p/>
-	 * <pre>
-	 *     for (int i = off; i < off + len; i++)
-	 *         dst.put(a[i]); </pre>
-	 * <p/>
-	 * except that it first checks that there is sufficient space in this
-	 * buffer and it is potentially much more efficient. </p>
-	 *
-	 * @param src    The array from which longs are to be read
-	 * @param offset The offset within the array of the first long to be read;
-	 *               must be non-negative and no larger than <tt>array.length</tt>
-	 * @param length The number of longs to be read from the given array;
-	 *               must be non-negative and no larger than
-	 *               <tt>array.length - offset</tt>
-	 *
-	 * @return This buffer
-	 *
-	 * @throws BufferOverflowException   If there is insufficient space in this buffer
-	 * @throws IndexOutOfBoundsException If the preconditions on the <tt>offset</tt> and <tt>length</tt>
-	 *                                   parameters do not hold
-	 * @throws ReadOnlyBufferException   If this buffer is read-only
-	 */
-	public PointerBuffer put(long[] src, int offset, int length) {
-		if ( is64Bit )
-			view64.put(src, offset, length);
-		else {
-			checkBounds(offset, length, src.length);
-			if ( length > view32.remaining() )
-				throw new BufferOverflowException();
-			int end = offset + length;
-			for ( int i = offset; i < end; i++ )
-				view32.put((int)src[i]);
-		}
-
-		return this;
-	}
-
-	/**
-	 * Relative bulk <i>put</i> method&nbsp;&nbsp;<i>(optional operation)</i>.
-	 * <p/>
-	 * <p> This method transfers the entire content of the given source
-	 * long array into this buffer.  An invocation of this method of the
-	 * form <tt>dst.put(a)</tt> behaves in exactly the same way as the
-	 * invocation
-	 * <p/>
-	 * <pre>
-	 *     dst.put(a, 0, a.length) </pre>
-	 *
-	 * @return This buffer
-	 *
-	 * @throws BufferOverflowException If there is insufficient space in this buffer
-	 * @throws ReadOnlyBufferException If this buffer is read-only
-	 */
-	public final PointerBuffer put(long[] src) {
-		return put(src, 0, src.length);
-	}
-
-	/**
-	 * Compacts this buffer&nbsp;&nbsp;<i>(optional operation)</i>.
-	 * <p/>
-	 * <p> The longs between the buffer's current position and its limit,
-	 * if any, are copied to the beginning of the buffer.  That is, the
-	 * long at index <i>p</i>&nbsp;=&nbsp;<tt>position()</tt> is copied
-	 * to index zero, the long at index <i>p</i>&nbsp;+&nbsp;1 is copied
-	 * to index one, and so forth until the long at index
-	 * <tt>limit()</tt>&nbsp;-&nbsp;1 is copied to index
-	 * <i>n</i>&nbsp;=&nbsp;<tt>limit()</tt>&nbsp;-&nbsp;<tt>1</tt>&nbsp;-&nbsp;<i>p</i>.
-	 * The buffer's position is then set to <i>n+1</i> and its limit is set to
-	 * its capacity.  The mark, if defined, is discarded.
-	 * <p/>
-	 * <p> The buffer's position is set to the number of longs copied,
-	 * rather than to zero, so that an invocation of this method can be
-	 * followed immediately by an invocation of another relative <i>put</i>
-	 * method. </p>
-	 *
-	 * @return This buffer
-	 *
-	 * @throws ReadOnlyBufferException If this buffer is read-only
-	 */
-	public PointerBuffer compact() {
-		if ( is64Bit )
-			view64.compact();
-		else
-			view32.compact();
-		return this;
-	}
-
-	/**
-	 * Retrieves this buffer's byte order.
-	 * <p/>
-	 * <p> The byte order of a pointer buffer created by allocation or by
-	 * wrapping an existing <tt>long</tt> array is the {@link
-	 * ByteOrder#nativeOrder </code>native order<code>} of the underlying
-	 * hardware.  The byte order of a pointer buffer created as a <a
-	 * href="ByteBuffer.html#views">view</a> of a byte buffer is that of the
-	 * byte buffer at the moment that the view is created.  </p>
-	 *
-	 * @return This buffer's byte order
-	 */
-	public ByteOrder order() {
-		if ( is64Bit )
-			return view64.order();
-		else
-			return view32.order();
-	}
-
-	/**
-	 * Returns a string summarizing the state of this buffer.  </p>
-	 *
-	 * @return A summary string
-	 */
-	public String toString() {
-		StringBuilder sb = new StringBuilder(48);
-		sb.append(getClass().getName());
-		sb.append("[pos=");
-		sb.append(position());
-		sb.append(" lim=");
-		sb.append(limit());
-		sb.append(" cap=");
-		sb.append(capacity());
-		sb.append("]");
-		return sb.toString();
-	}
-
-	/**
-	 * Returns the current hash code of this buffer.
-	 * <p/>
-	 * <p> The hash code of a pointer buffer depends only upon its remaining
-	 * elements; that is, upon the elements from <tt>position()</tt> up to, and
-	 * including, the element at <tt>limit()</tt>&nbsp;-&nbsp;<tt>1</tt>.
-	 * <p/>
-	 * <p> Because buffer hash codes are content-dependent, it is inadvisable
-	 * to use buffers as keys in hash maps or similar data structures unless it
-	 * is known that their contents will not change.  </p>
-	 *
-	 * @return The current hash code of this buffer
-	 */
-	public int hashCode() {
-		int h = 1;
-		int p = position();
-		for ( int i = limit() - 1; i >= p; i-- )
-			h = 31 * h + (int)get(i);
-		return h;
-	}
-
-	/**
-	 * Tells whether or not this buffer is equal to another object.
-	 * <p/>
-	 * <p> Two pointer buffers are equal if, and only if,
-	 * <p/>
-	 * <p><ol>
-	 * <p/>
-	 * <li><p> They have the same element type,  </p></li>
-	 * <p/>
-	 * <li><p> They have the same number of remaining elements, and
-	 * </p></li>
-	 * <p/>
-	 * <li><p> The two sequences of remaining elements, considered
-	 * independently of their starting positions, are pointwise equal.
-	 * </p></li>
-	 * <p/>
-	 * </ol>
-	 * <p/>
-	 * <p> A pointer buffer is not equal to any other type of object.  </p>
-	 *
-	 * @param ob The object to which this buffer is to be compared
-	 *
-	 * @return <tt>true</tt> if, and only if, this buffer is equal to the
-	 *         given object
-	 */
-	public boolean equals(Object ob) {
-		if ( !(ob instanceof PointerBuffer) )
-			return false;
-		PointerBuffer that = (PointerBuffer)ob;
-		if ( this.remaining() != that.remaining() )
-			return false;
-		int p = this.position();
-		for ( int i = this.limit() - 1, j = that.limit() - 1; i >= p; i--, j-- ) {
-			long v1 = this.get(i);
-			long v2 = that.get(j);
-			if ( v1 != v2 ) {
-				return false;
-			}
-		}
-		return true;
-	}
-
-	/**
-	 * Compares this buffer to another.
-	 * <p/>
-	 * <p> Two pointer buffers are compared by comparing their sequences of
-	 * remaining elements lexicographically, without regard to the starting
-	 * position of each sequence within its corresponding buffer.
-	 * <p/>
-	 * <p> A pointer buffer is not comparable to any other type of object.
-	 *
-	 * @return A negative integer, zero, or a positive integer as this buffer
-	 *         is less than, equal to, or greater than the given buffer
-	 */
-	public int compareTo(Object o) {
-		final PointerBuffer that = (PointerBuffer)o;
-		int n = this.position() + Math.min(this.remaining(), that.remaining());
-		for ( int i = this.position(), j = that.position(); i < n; i++, j++ ) {
-			long v1 = this.get(i);
-			long v2 = that.get(j);
-			if ( v1 == v2 )
-				continue;
-			if ( v1 < v2 )
-				return -1;
-			return +1;
-		}
-		return this.remaining() - that.remaining();
-	}
-
-	private static void checkBounds(int off, int len, int size) {
-		if ( (off | len | (off + len) | (size - (off + len))) < 0 )
-			throw new IndexOutOfBoundsException();
-	}
-
-	/**
-	 * Read-only version of PointerBuffer.
-	 *
-	 * @author Spasi
-	 */
-	private static final class PointerBufferR extends PointerBuffer {
-
-		PointerBufferR(final ByteBuffer source) {
-			super(source);
-		}
-
-		public boolean isReadOnly() {
-			return true;
-		}
-
-		protected PointerBuffer newInstance(final ByteBuffer source) {
-			return new PointerBufferR(source);
-		}
-
-		public PointerBuffer asReadOnlyBuffer() {
-			return duplicate();
-		}
-
-		public PointerBuffer put(final long l) {
-			throw new ReadOnlyBufferException();
-		}
-
-		public PointerBuffer put(final int index, final long l) {
-			throw new ReadOnlyBufferException();
-		}
-
-		public PointerBuffer put(final PointerBuffer src) {
-			throw new ReadOnlyBufferException();
-		}
-
-		public PointerBuffer put(final long[] src, final int offset, final int length) {
-			throw new ReadOnlyBufferException();
-		}
-
-		public PointerBuffer compact() {
-			throw new ReadOnlyBufferException();
-		}
-
-	}
-
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/PointerWrapper.java b/src/embeddedlibs/org/lwjglx/PointerWrapper.java
deleted file mode 100644
index 9d0878c..0000000
--- a/src/embeddedlibs/org/lwjglx/PointerWrapper.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx;
-
-/**
- * A common interface for classes that wrap pointer addresses.
- *
- * @author Spasi
- */
-public interface PointerWrapper {
-
-	long getPointer();
-
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/PointerWrapperAbstract.java b/src/embeddedlibs/org/lwjglx/PointerWrapperAbstract.java
deleted file mode 100644
index f46aea7..0000000
--- a/src/embeddedlibs/org/lwjglx/PointerWrapperAbstract.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (c) 2002-2010 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx;
-
-/**
- * Base PointerWrapper implementation.
- *
- * @author Spasi
- */
-public abstract class PointerWrapperAbstract implements PointerWrapper {
-
-	protected final long pointer;
-
-	protected PointerWrapperAbstract(final long pointer) {
-		this.pointer = pointer;
-	}
-
-	/**
-	 * Returns true if this object represents a valid pointer.
-	 * The pointer might be invalid because it is NULL or because
-	 * some other action has deleted the object that this pointer
-	 * represents.
-	 *
-	 * @return true if the pointer is valid
-	 */
-	public boolean isValid() {
-		return pointer != 0;
-	}
-
-	/**
-	 * Checks if the pointer is valid and throws an IllegalStateException if
-	 * it is not. This method is a NO-OP, unless the org.lwjglx.util.Debug
-	 * property has been set to true.
-	 */
-	public final void checkValid() {
-		if ( LWJGLUtil.DEBUG && !isValid() )
-			throw new IllegalStateException("This " + getClass().getSimpleName() + " pointer is not valid.");
-	}
-
-	public final long getPointer() {
-		checkValid();
-		return pointer;
-	}
-
-	public boolean equals(final Object o) {
-		if ( this == o ) return true;
-		if ( !(o instanceof PointerWrapperAbstract) ) return false;
-
-		final PointerWrapperAbstract that = (PointerWrapperAbstract)o;
-
-		if ( pointer != that.pointer ) return false;
-
-		return true;
-	}
-
-	public int hashCode() {
-		return (int)(pointer ^ (pointer >>> 32));
-	}
-
-	public String toString() {
-		return getClass().getSimpleName() + " pointer (0x" + Long.toHexString(pointer).toUpperCase() + ")";
-	}
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/Sys.java b/src/embeddedlibs/org/lwjglx/Sys.java
deleted file mode 100644
index e49b5ef..0000000
--- a/src/embeddedlibs/org/lwjglx/Sys.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package org.lwjglx;
-
-import static org.lwjgl.glfw.GLFW.glfwInit;
-
-import org.lwjgl.opengl.GL11;
-import org.lwjgl.glfw.GLFW;
-
-import java.awt.Desktop;
-import java.net.URI;
-
-import javax.swing.JOptionPane;
-import javax.swing.UIManager;
-
-public class Sys {
-
-    static {
-        if (!glfwInit())
-            throw new IllegalStateException("Unable to initialize glfw");
-    }
-
-    public static void initialize() {
-
-    }
-
-    /**
-     * Returns the LWJGL version.
-     */
-    public static String getVersion() {
-        return org.lwjgl.Version.getVersion();
-    }
-
-    /**
-     * Obtains the number of ticks that the hires timer does in a second. This method is fast;
-     * it should be called as frequently as possible, as it recalibrates the timer.
-     *
-     * @return timer resolution in ticks per second or 0 if no timer is present.
-     */
-    public static long getTimerResolution() {
-        return 1000;
-    }
-
-    /**
-     * Gets the current value of the hires timer, in ticks. When the Sys class is first loaded
-     * the hires timer is reset to 0. If no hires timer is present then this method will always
-     * return 0.<p><strong>NOTEZ BIEN</strong> that the hires timer WILL wrap around.
-     *
-     * @return the current hires time, in ticks (always >= 0)
-     */
-    public static long getTime() {
-        return (long) (GLFW.glfwGetTime() * 1000);
-    }
-
-    public static long getNanoTime() {
-        return (long) (GLFW.glfwGetTime() * (1000L * 1000L * 1000L));
-    }
-
-    public static boolean openURL(String url) {
-        if (!Desktop.isDesktopSupported()) return false;
-
-        Desktop desktop = Desktop.getDesktop();
-        if (!desktop.isSupported(Desktop.Action.BROWSE)) return false;
-
-        try {
-            desktop.browse(new URI(url));
-            return true;
-        } catch (Exception ex) {
-            return false;
-        }
-    }
-
-    public static void alert(String title, String message) {
-        try {
-            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
-        } catch (Exception e) {
-            LWJGLUtil.log("Caught exception while setting LAF: " + e);
-        }
-        JOptionPane.showMessageDialog(null, message, title, JOptionPane.WARNING_MESSAGE);
-    }
-}
diff --git a/src/embeddedlibs/org/lwjglx/input/Cursor.java b/src/embeddedlibs/org/lwjglx/input/Cursor.java
deleted file mode 100644
index 90b90f2..0000000
--- a/src/embeddedlibs/org/lwjglx/input/Cursor.java
+++ /dev/null
@@ -1,258 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.input;
-
-import java.nio.IntBuffer;
-
-import org.lwjglx.BufferChecks;
-import org.lwjglx.BufferUtils;
-import org.lwjglx.LWJGLException;
-import org.lwjglx.LWJGLUtil;
-import org.lwjglx.Sys;
-
-/**
- *
- * A class representing a native cursor. Instances of this
- * class can be used with Mouse.setCursor(), if available.
- *
- * @author elias_naur <elias_naur@users.sourceforge.net>
- * @version $Revision$
- * $Id$
- */
-
-public class Cursor {
-	/** 1 bit transparency for native cursor */
-	public static final int		CURSOR_ONE_BIT_TRANSPARENCY	= 1;
-
-	/** 8 bit alhpa native cursor */
-	public static final int		CURSOR_8_BIT_ALPHA					= 2;
-
-	/** animation native cursor */
-	public static final int		CURSOR_ANIMATION						= 4;
-
-	/** First element to display */
-	private final CursorElement[] cursors;
-
-	/** Index into list of cursors */
-	private int index;
-
-	private boolean destroyed;
-
-	/**
-	 * Constructs a new Cursor, with the given parameters. Mouse must have been created before you can create
-	 * Cursor objects. Cursor images are in ARGB format, but only one bit transparancy is guaranteed to be supported.
-	 * So to maximize portability, lwjgl applications should only create cursor images with 0x00 or 0xff as alpha values.
-	 * The constructor will copy the images and delays, so there's no need to keep them around.
-	 *
-	 * @param width cursor image width
-	 * @param height cursor image height
-	 * @param xHotspot the x coordinate of the cursor hotspot
-	 * @param yHotspot the y coordinate of the cursor hotspot
-	 * @param numImages number of cursor images specified. Must be 1 if animations are not supported.
-	 * @param images A buffer containing the images. The origin is at the lower left corner, like OpenGL.
-	 * @param delays An int buffer of animation frame delays, if numImages is greater than 1, else null
-	 * @throws LWJGLException if the cursor could not be created for any reason
-	 */
-	public Cursor(int width, int height, int xHotspot, int yHotspot, int numImages, IntBuffer images, IntBuffer delays) throws LWJGLException {
-		// TODO
-		cursors = null;
-	}
-
-	/**
-	 * Gets the minimum size of a native cursor. Can only be called if
-	 * The Mouse is created and cursor caps includes at least
-	 * CURSOR_ONE_BIT_TRANSPARANCY.
-	 *
-	 * @return the maximum size of a native cursor
-	 */
-	public static int getMinCursorSize() {
-		// TODO
-		return 0;
-	}
-
-	/**
-	 * Gets the maximum size of a native cursor. Can only be called if
-	 * The Mouse is created and cursor caps includes at least
-	 * CURSOR_ONE_BIT_TRANSPARANCY.
-	 *
-	 * @return the maximum size of a native cursor
-	 */
-	public static int getMaxCursorSize() {
-		// TODO
-		return 0;
-	}
-
-	/**
-	 * Get the capabilities of the native cursor. Return a bit mask of the native cursor capabilities.
-	 * The CURSOR_ONE_BIT_TRANSPARANCY indicates support for cursors with one bit transparancy,
-	 * the CURSOR_8_BIT_ALPHA indicates support for 8 bit alpha and CURSOR_ANIMATION indicates
-	 * support for cursor animations.
-	 *
-	 * @return A bit mask with native cursor capabilities.
-	 */
-	public static int getCapabilities() {
-		// TODO
-		return 0;
-	}
-
-	/**
-	 * Creates the actual cursor, using a platform specific class
-	 */
-	private static CursorElement[] createCursors(int width, int height, int xHotspot, int yHotspot, int numImages, IntBuffer images, IntBuffer delays) throws LWJGLException {
-		// TODO
-		return null;
-	}
-	
-	/**
-	 * Convert an IntBuffer image of ARGB format into ABGR
-	 *
-	 * @param imageBuffer image to convert
-	 */
-	private static void convertARGBtoABGR(IntBuffer imageBuffer) {
-		for (int i = 0; i < imageBuffer.limit(); i++) {
-			int argbColor = imageBuffer.get(i);
-			
-			byte alpha = (byte)(argbColor >>> 24);
-	        byte blue = (byte)(argbColor >>> 16);
-	        byte green = (byte)(argbColor >>> 8);
-	        byte red = (byte)argbColor;
-	        
-	        int abgrColor = ((alpha & 0xff) << 24 ) + ((red & 0xff) << 16 ) + ((green & 0xff) << 8 ) + ((blue & 0xff) ); 
-	        
-	        imageBuffer.put(i, abgrColor);
-		}
-	}
-
-	/**
-	 * Flips the images so they're oriented according to opengl
-	 *
-	 * @param width Width of image
-	 * @param height Height of images
-	 * @param numImages How many images to flip
-	 * @param images Source images
-	 * @param images_copy Destination images
-	 */
-	private static void flipImages(int width, int height, int numImages, IntBuffer images, IntBuffer images_copy) {
-		for (int i = 0; i < numImages; i++) {
-			int start_index = i*width*height;
-			flipImage(width, height, start_index, images, images_copy);
-		}
-	}
-
-	/**
-	 * @param width Width of image
-	 * @param height Height of images
-	 * @param start_index index into source buffer to copy to
-	 * @param images Source images
-	 * @param images_copy Destination images
-	 */
-	private static void flipImage(int width, int height, int start_index, IntBuffer images, IntBuffer images_copy) {
-		for (int y = 0; y < height>>1; y++) {
-			int index_y_1 = y*width + start_index;
-			int index_y_2 = (height - y - 1)*width + start_index;
-			for (int x = 0; x < width; x++) {
-				int index1 = index_y_1 + x;
-				int index2 = index_y_2 + x;
-				int temp_pixel = images.get(index1 + images.position());
-				images_copy.put(index1, images.get(index2 + images.position()));
-				images_copy.put(index2, temp_pixel);
-			}
-		}
-	}
-
-	/**
-	 * Gets the native handle associated with the cursor object.
-	 */
-	Object getHandle() {
-		checkValid();
-		return cursors[index].cursorHandle;
-	}
-
-	private void checkValid() {
-		if (destroyed)
-			throw new IllegalStateException("The cursor is destroyed");
-	}
-
-	/**
-	 * Destroy the native cursor. If the cursor is current,
-	 * the current native cursor is set to null (the default
-	 * OS cursor)
-	 */
-	public void destroy() {
-		// TODO
-	}
-
-	/**
-	 * Sets the timout property to the time it should be changed
-	 */
-	protected void setTimeout() {
-		checkValid();
-		cursors[index].timeout = System.currentTimeMillis() + cursors[index].delay;
-	}
-
-	/**
-	 * Determines whether this cursor has timed out
-	 * @return true if the this cursor has timed out, false if not
-	 */
-	protected boolean hasTimedOut() {
-		checkValid();
-		return cursors.length > 1 && cursors[index].timeout < System.currentTimeMillis();
-	}
-
-	/**
-	 * Changes to the next cursor
-	 */
-	protected void nextCursor() {
-		checkValid();
-		index = ++index % cursors.length;
-	}
-
-	/**
-	 * A single cursor element, used when animating
-	 */
-	private static class CursorElement {
-		/** Handle to cursor */
-		final Object cursorHandle;
-
-		/** How long a delay this element should have */
-		final long delay;
-
-		/** Absolute time this element times out */
-		long timeout;
-
-		CursorElement(Object cursorHandle, long delay, long timeout) {
-			this.cursorHandle = cursorHandle;
-			this.delay = delay;
-			this.timeout = timeout;
-		}
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/input/EventQueue.java b/src/embeddedlibs/org/lwjglx/input/EventQueue.java
deleted file mode 100644
index 0626e6c..0000000
--- a/src/embeddedlibs/org/lwjglx/input/EventQueue.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package org.lwjglx.input;
-
-/**
- * Internal utility class to keep track of event positions in an array.
- * When the array is full the position will wrap to the beginning.
- */
-class EventQueue {
-	
-	private int maxEvents = 4096;
-	private int eventCount = 0;
-	private int currentEventPos = -1;
-	private int nextEventPos = 0;
-	
-	EventQueue(int maxEvents) {
-		this.maxEvents = maxEvents;
-	}
-
-	/**
-	 * add event to the queue
-	 */
-	void add() {
-		eventCount++; // increment event count
-		if (eventCount > maxEvents) eventCount = maxEvents; // cap max events
-		
-		nextEventPos++; // increment next event position
-		if (nextEventPos == maxEvents) nextEventPos = 0; // wrap next event position
-		
-		if (nextEventPos == currentEventPos) currentEventPos++; // skip oldest event is queue full
-		if (currentEventPos == maxEvents) currentEventPos = 0; // wrap current event position
-	}
-	
-	/**
-	 * Increment the event queue
-	 * @return - true if there is an event available
-	 */
-	boolean next() {
-		if (eventCount == 0) return false;
-		
-		eventCount--; // decrement event count
-		currentEventPos++; // increment current event position
-		if (currentEventPos == maxEvents) currentEventPos = 0; // wrap current event position
-		
-		return true;
-	}
-	
-	int getMaxEvents() {
-		return maxEvents;
-	}
-	
-	int getCurrentPos() {
-		return currentEventPos;
-	}
-	
-	int getNextPos() {
-		return nextEventPos;
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/input/KeyCodes.java b/src/embeddedlibs/org/lwjglx/input/KeyCodes.java
deleted file mode 100644
index 8fd3d9e..0000000
--- a/src/embeddedlibs/org/lwjglx/input/KeyCodes.java
+++ /dev/null
@@ -1,321 +0,0 @@
-package org.lwjglx.input;
-
-import org.lwjgl.glfw.GLFW;
-
-public class KeyCodes {
-	
-	public static int toLwjglKey(int glfwKeyCode) {
-		
-		switch(glfwKeyCode) {
-		
-		case GLFW.GLFW_KEY_ESCAPE	: return Keyboard.KEY_ESCAPE;
-		case GLFW.GLFW_KEY_BACKSPACE: return Keyboard.KEY_BACK;
-		case GLFW.GLFW_KEY_TAB		: return Keyboard.KEY_TAB;
-		case GLFW.GLFW_KEY_ENTER	: return Keyboard.KEY_RETURN;
-		case GLFW.GLFW_KEY_SPACE	: return Keyboard.KEY_SPACE;
-		
-		case GLFW.GLFW_KEY_LEFT_CONTROL	: return Keyboard.KEY_LCONTROL;
-		case GLFW.GLFW_KEY_LEFT_SHIFT	: return Keyboard.KEY_LSHIFT;
-		case GLFW.GLFW_KEY_LEFT_ALT		: return Keyboard.KEY_LMENU;
-		case GLFW.GLFW_KEY_LEFT_SUPER	: return Keyboard.KEY_LMETA;
-		
-		case GLFW.GLFW_KEY_RIGHT_CONTROL: return Keyboard.KEY_RCONTROL;
-		case GLFW.GLFW_KEY_RIGHT_SHIFT	: return Keyboard.KEY_RSHIFT;
-		case GLFW.GLFW_KEY_RIGHT_ALT	: return Keyboard.KEY_RMENU;
-		case GLFW.GLFW_KEY_RIGHT_SUPER	: return Keyboard.KEY_RMETA;
-		
-		case GLFW.GLFW_KEY_1		: return Keyboard.KEY_1;
-		case GLFW.GLFW_KEY_2		: return Keyboard.KEY_2;
-		case GLFW.GLFW_KEY_3		: return Keyboard.KEY_3;
-		case GLFW.GLFW_KEY_4		: return Keyboard.KEY_4;
-		case GLFW.GLFW_KEY_5		: return Keyboard.KEY_5;
-		case GLFW.GLFW_KEY_6		: return Keyboard.KEY_6;
-		case GLFW.GLFW_KEY_7		: return Keyboard.KEY_7;
-		case GLFW.GLFW_KEY_8		: return Keyboard.KEY_8;
-		case GLFW.GLFW_KEY_9		: return Keyboard.KEY_9;
-		case GLFW.GLFW_KEY_0		: return Keyboard.KEY_0;
-		
-		case GLFW.GLFW_KEY_A		: return Keyboard.KEY_A;
-		case GLFW.GLFW_KEY_B		: return Keyboard.KEY_B;
-		case GLFW.GLFW_KEY_C		: return Keyboard.KEY_C;
-		case GLFW.GLFW_KEY_D		: return Keyboard.KEY_D;
-		case GLFW.GLFW_KEY_E		: return Keyboard.KEY_E;
-		case GLFW.GLFW_KEY_F		: return Keyboard.KEY_F;
-		case GLFW.GLFW_KEY_G		: return Keyboard.KEY_G;
-		case GLFW.GLFW_KEY_H		: return Keyboard.KEY_H;
-		case GLFW.GLFW_KEY_I		: return Keyboard.KEY_I;
-		case GLFW.GLFW_KEY_J		: return Keyboard.KEY_J;
-		case GLFW.GLFW_KEY_K		: return Keyboard.KEY_K;
-		case GLFW.GLFW_KEY_L		: return Keyboard.KEY_L;
-		case GLFW.GLFW_KEY_M		: return Keyboard.KEY_M;
-		case GLFW.GLFW_KEY_N		: return Keyboard.KEY_N;
-		case GLFW.GLFW_KEY_O		: return Keyboard.KEY_O;
-		case GLFW.GLFW_KEY_P		: return Keyboard.KEY_P;
-		case GLFW.GLFW_KEY_Q		: return Keyboard.KEY_Q;
-		case GLFW.GLFW_KEY_R		: return Keyboard.KEY_R;
-		case GLFW.GLFW_KEY_S		: return Keyboard.KEY_S;
-		case GLFW.GLFW_KEY_T		: return Keyboard.KEY_T;
-		case GLFW.GLFW_KEY_U		: return Keyboard.KEY_U;
-		case GLFW.GLFW_KEY_V		: return Keyboard.KEY_V;
-		case GLFW.GLFW_KEY_W		: return Keyboard.KEY_W;
-		case GLFW.GLFW_KEY_X		: return Keyboard.KEY_X;
-		case GLFW.GLFW_KEY_Y		: return Keyboard.KEY_Y;
-		case GLFW.GLFW_KEY_Z		: return Keyboard.KEY_Z;
-		
-		case GLFW.GLFW_KEY_UP		: return Keyboard.KEY_UP;
-		case GLFW.GLFW_KEY_DOWN		: return Keyboard.KEY_DOWN;
-		case GLFW.GLFW_KEY_LEFT		: return Keyboard.KEY_LEFT;
-		case GLFW.GLFW_KEY_RIGHT	: return Keyboard.KEY_RIGHT;
-		
-		case GLFW.GLFW_KEY_INSERT	: return Keyboard.KEY_INSERT;
-		case GLFW.GLFW_KEY_DELETE	: return Keyboard.KEY_DELETE;
-		case GLFW.GLFW_KEY_HOME		: return Keyboard.KEY_HOME;
-		case GLFW.GLFW_KEY_END		: return Keyboard.KEY_END;
-		case GLFW.GLFW_KEY_PAGE_UP	: return Keyboard.KEY_PRIOR;
-		case GLFW.GLFW_KEY_PAGE_DOWN: return Keyboard.KEY_NEXT;
-		
-		case GLFW.GLFW_KEY_F1		: return Keyboard.KEY_F1;
-		case GLFW.GLFW_KEY_F2		: return Keyboard.KEY_F2;
-		case GLFW.GLFW_KEY_F3		: return Keyboard.KEY_F3;
-		case GLFW.GLFW_KEY_F4		: return Keyboard.KEY_F4;
-		case GLFW.GLFW_KEY_F5		: return Keyboard.KEY_F5;
-		case GLFW.GLFW_KEY_F6		: return Keyboard.KEY_F6;
-		case GLFW.GLFW_KEY_F7		: return Keyboard.KEY_F7;
-		case GLFW.GLFW_KEY_F8		: return Keyboard.KEY_F8;
-		case GLFW.GLFW_KEY_F9		: return Keyboard.KEY_F9;
-		case GLFW.GLFW_KEY_F10		: return Keyboard.KEY_F10;
-		case GLFW.GLFW_KEY_F11		: return Keyboard.KEY_F11;
-		case GLFW.GLFW_KEY_F12		: return Keyboard.KEY_F12;
-		case GLFW.GLFW_KEY_F13		: return Keyboard.KEY_F13;
-		case GLFW.GLFW_KEY_F14		: return Keyboard.KEY_F14;
-		case GLFW.GLFW_KEY_F15		: return Keyboard.KEY_F15;
-		case GLFW.GLFW_KEY_F16		: return Keyboard.KEY_F16;
-		case GLFW.GLFW_KEY_F17		: return Keyboard.KEY_F17;
-		case GLFW.GLFW_KEY_F18		: return Keyboard.KEY_F18;
-		case GLFW.GLFW_KEY_F19		: return Keyboard.KEY_F19;
-		
-		case GLFW.GLFW_KEY_KP_1		: return Keyboard.KEY_NUMPAD1;
-		case GLFW.GLFW_KEY_KP_2		: return Keyboard.KEY_NUMPAD2;
-		case GLFW.GLFW_KEY_KP_3		: return Keyboard.KEY_NUMPAD3;
-		case GLFW.GLFW_KEY_KP_4		: return Keyboard.KEY_NUMPAD4;
-		case GLFW.GLFW_KEY_KP_5		: return Keyboard.KEY_NUMPAD5;
-		case GLFW.GLFW_KEY_KP_6		: return Keyboard.KEY_NUMPAD6;
-		case GLFW.GLFW_KEY_KP_7		: return Keyboard.KEY_NUMPAD7;
-		case GLFW.GLFW_KEY_KP_8		: return Keyboard.KEY_NUMPAD8;
-		case GLFW.GLFW_KEY_KP_9		: return Keyboard.KEY_NUMPAD9;
-		case GLFW.GLFW_KEY_KP_0		: return Keyboard.KEY_NUMPAD0;
-		
-		case GLFW.GLFW_KEY_KP_ADD	: return Keyboard.KEY_ADD;
-		case GLFW.GLFW_KEY_KP_SUBTRACT	: return Keyboard.KEY_SUBTRACT;
-		case GLFW.GLFW_KEY_KP_MULTIPLY	: return Keyboard.KEY_MULTIPLY;
-		case GLFW.GLFW_KEY_KP_DIVIDE: return Keyboard.KEY_DIVIDE;
-		case GLFW.GLFW_KEY_KP_DECIMAL	: return Keyboard.KEY_DECIMAL;
-		case GLFW.GLFW_KEY_KP_EQUAL	: return Keyboard.KEY_NUMPADEQUALS;
-		case GLFW.GLFW_KEY_KP_ENTER	: return Keyboard.KEY_NUMPADENTER;
-		case GLFW.GLFW_KEY_NUM_LOCK	: return Keyboard.KEY_NUMLOCK;
-		
-		case GLFW.GLFW_KEY_SEMICOLON: return Keyboard.KEY_SEMICOLON;
-		case GLFW.GLFW_KEY_BACKSLASH: return Keyboard.KEY_BACKSLASH;
-		case GLFW.GLFW_KEY_COMMA	: return Keyboard.KEY_COMMA;
-		case GLFW.GLFW_KEY_PERIOD	: return Keyboard.KEY_PERIOD;
-		case GLFW.GLFW_KEY_SLASH	: return Keyboard.KEY_SLASH;
-		case GLFW.GLFW_KEY_GRAVE_ACCENT	: return Keyboard.KEY_GRAVE;
-
-		case GLFW.GLFW_KEY_CAPS_LOCK: return Keyboard.KEY_CAPITAL;
-		case GLFW.GLFW_KEY_SCROLL_LOCK	: return Keyboard.KEY_SCROLL;
-		
-		case GLFW.GLFW_KEY_WORLD_1	: return Keyboard.KEY_CIRCUMFLEX; // TODO not sure if correct
-		case GLFW.GLFW_KEY_PAUSE	: return Keyboard.KEY_PAUSE;
-		
-		case GLFW.GLFW_KEY_MINUS 	: return Keyboard.KEY_MINUS;
-		case GLFW.GLFW_KEY_EQUAL 	: return Keyboard.KEY_EQUALS;
-		case GLFW.GLFW_KEY_LEFT_BRACKET	: return Keyboard.KEY_LBRACKET;
-		case GLFW.GLFW_KEY_RIGHT_BRACKET: return Keyboard.KEY_RBRACKET;
-		case GLFW.GLFW_KEY_APOSTROPHE	: return Keyboard.KEY_APOSTROPHE;
-//		public static final int KEY_AT              = 0x91; /*                     (NEC PC98) */
-//		public static final int KEY_COLON           = 0x92; /*                     (NEC PC98) */
-//		public static final int KEY_UNDERLINE       = 0x93; /*                     (NEC PC98) */
-
-//		public static final int KEY_KANA            = 0x70; /* (Japanese keyboard)            */
-//		public static final int KEY_CONVERT         = 0x79; /* (Japanese keyboard)            */
-//		public static final int KEY_NOCONVERT       = 0x7B; /* (Japanese keyboard)            */
-//		public static final int KEY_YEN             = 0x7D; /* (Japanese keyboard)            */
-//		public static final int KEY_CIRCUMFLEX      = 0x90; /* (Japanese keyboard)            */
-//		public static final int KEY_KANJI           = 0x94; /* (Japanese keyboard)            */
-//		public static final int KEY_STOP            = 0x95; /*                     (NEC PC98) */
-//		public static final int KEY_AX              = 0x96; /*                     (Japan AX) */
-//		public static final int KEY_UNLABELED       = 0x97; /*                        (J3100) */
-//		public static final int KEY_SECTION         = 0xA7; /* Section symbol (Mac) */
-//		public static final int KEY_NUMPADCOMMA     = 0xB3; /* , on numeric keypad (NEC PC98) */
-//		public static final int KEY_SYSRQ           = 0xB7;
-//		public static final int KEY_FUNCTION        = 0xC4; /* Function (Mac) */
-//		public static final int KEY_CLEAR           = 0xDA; /* Clear key (Mac) */
-
-//		public static final int KEY_APPS            = 0xDD; /* AppMenu key */
-//		public static final int KEY_POWER           = 0xDE;
-//		public static final int KEY_SLEEP           = 0xDF;
-
-		default: 	System.out.println("UNKNOWN GLFW KEY CODE: " + glfwKeyCode);
-					return Keyboard.KEY_NONE;
-		}
-	}
-	
-	public static int toGlfwKey(int lwjglKeyCode) {
-		
-		switch(lwjglKeyCode) {
-		
-		case Keyboard.KEY_ESCAPE	: return GLFW.GLFW_KEY_ESCAPE;
-		case Keyboard.KEY_BACK		: return GLFW.GLFW_KEY_BACKSPACE;
-		case Keyboard.KEY_TAB		: return GLFW.GLFW_KEY_TAB;
-		case Keyboard.KEY_RETURN	: return GLFW.GLFW_KEY_ENTER;
-		case Keyboard.KEY_SPACE		: return GLFW.GLFW_KEY_SPACE;
-		
-		case Keyboard.KEY_LCONTROL	: return GLFW.GLFW_KEY_LEFT_CONTROL;
-		case Keyboard.KEY_LSHIFT	: return GLFW.GLFW_KEY_LEFT_SHIFT;
-		case Keyboard.KEY_LMENU		: return GLFW.GLFW_KEY_LEFT_ALT;
-		case Keyboard.KEY_LMETA		: return GLFW.GLFW_KEY_LEFT_SUPER;
-		
-		case Keyboard.KEY_RCONTROL	: return GLFW.GLFW_KEY_RIGHT_CONTROL;
-		case Keyboard.KEY_RSHIFT	: return GLFW.GLFW_KEY_RIGHT_SHIFT;
-		case Keyboard.KEY_RMENU		: return GLFW.GLFW_KEY_RIGHT_ALT;
-		case Keyboard.KEY_RMETA		: return GLFW.GLFW_KEY_RIGHT_SUPER;
-		
-		case Keyboard.KEY_1			: return GLFW.GLFW_KEY_1;
-		case Keyboard.KEY_2			: return GLFW.GLFW_KEY_2;
-		case Keyboard.KEY_3			: return GLFW.GLFW_KEY_3;
-		case Keyboard.KEY_4			: return GLFW.GLFW_KEY_4;
-		case Keyboard.KEY_5			: return GLFW.GLFW_KEY_5;
-		case Keyboard.KEY_6			: return GLFW.GLFW_KEY_6;
-		case Keyboard.KEY_7			: return GLFW.GLFW_KEY_7;
-		case Keyboard.KEY_8			: return GLFW.GLFW_KEY_8;
-		case Keyboard.KEY_9			: return GLFW.GLFW_KEY_9;
-		case Keyboard.KEY_0			: return GLFW.GLFW_KEY_0;
-		
-		case Keyboard.KEY_A			: return GLFW.GLFW_KEY_A;
-		case Keyboard.KEY_B			: return GLFW.GLFW_KEY_B;
-		case Keyboard.KEY_C			: return GLFW.GLFW_KEY_C;
-		case Keyboard.KEY_D			: return GLFW.GLFW_KEY_D;
-		case Keyboard.KEY_E			: return GLFW.GLFW_KEY_E;
-		case Keyboard.KEY_F			: return GLFW.GLFW_KEY_F;
-		case Keyboard.KEY_G			: return GLFW.GLFW_KEY_G;
-		case Keyboard.KEY_H			: return GLFW.GLFW_KEY_H;
-		case Keyboard.KEY_I			: return GLFW.GLFW_KEY_I;
-		case Keyboard.KEY_J			: return GLFW.GLFW_KEY_J;
-		case Keyboard.KEY_K			: return GLFW.GLFW_KEY_K;
-		case Keyboard.KEY_L			: return GLFW.GLFW_KEY_L;
-		case Keyboard.KEY_M			: return GLFW.GLFW_KEY_M;
-		case Keyboard.KEY_N			: return GLFW.GLFW_KEY_N;
-		case Keyboard.KEY_O			: return GLFW.GLFW_KEY_O;
-		case Keyboard.KEY_P			: return GLFW.GLFW_KEY_P;
-		case Keyboard.KEY_Q			: return GLFW.GLFW_KEY_Q;
-		case Keyboard.KEY_R			: return GLFW.GLFW_KEY_R;
-		case Keyboard.KEY_S			: return GLFW.GLFW_KEY_S;
-		case Keyboard.KEY_T			: return GLFW.GLFW_KEY_T;
-		case Keyboard.KEY_U			: return GLFW.GLFW_KEY_U;
-		case Keyboard.KEY_V			: return GLFW.GLFW_KEY_V;
-		case Keyboard.KEY_W			: return GLFW.GLFW_KEY_W;
-		case Keyboard.KEY_X			: return GLFW.GLFW_KEY_X;
-		case Keyboard.KEY_Y			: return GLFW.GLFW_KEY_Y;
-		case Keyboard.KEY_Z			: return GLFW.GLFW_KEY_Z;
-		
-		case Keyboard.KEY_UP		: return GLFW.GLFW_KEY_UP;
-		case Keyboard.KEY_DOWN		: return GLFW.GLFW_KEY_DOWN;
-		case Keyboard.KEY_LEFT		: return GLFW.GLFW_KEY_LEFT;
-		case Keyboard.KEY_RIGHT		: return GLFW.GLFW_KEY_RIGHT;
-		
-		case Keyboard.KEY_INSERT	: return GLFW.GLFW_KEY_INSERT;
-		case Keyboard.KEY_DELETE	: return GLFW.GLFW_KEY_DELETE;
-		case Keyboard.KEY_HOME		: return GLFW.GLFW_KEY_HOME;
-		case Keyboard.KEY_END		: return GLFW.GLFW_KEY_END;
-		case Keyboard.KEY_PRIOR		: return GLFW.GLFW_KEY_PAGE_UP;
-		case Keyboard.KEY_NEXT		: return GLFW.GLFW_KEY_PAGE_DOWN;
-		
-		case Keyboard.KEY_F1		: return GLFW.GLFW_KEY_F1;
-		case Keyboard.KEY_F2		: return GLFW.GLFW_KEY_F2;
-		case Keyboard.KEY_F3		: return GLFW.GLFW_KEY_F3;
-		case Keyboard.KEY_F4		: return GLFW.GLFW_KEY_F4;
-		case Keyboard.KEY_F5		: return GLFW.GLFW_KEY_F5;
-		case Keyboard.KEY_F6		: return GLFW.GLFW_KEY_F6;
-		case Keyboard.KEY_F7		: return GLFW.GLFW_KEY_F7;
-		case Keyboard.KEY_F8		: return GLFW.GLFW_KEY_F8;
-		case Keyboard.KEY_F9		: return GLFW.GLFW_KEY_F9;
-		case Keyboard.KEY_F10		: return GLFW.GLFW_KEY_F10;
-		case Keyboard.KEY_F11		: return GLFW.GLFW_KEY_F11;
-		case Keyboard.KEY_F12		: return GLFW.GLFW_KEY_F12;
-		case Keyboard.KEY_F13		: return GLFW.GLFW_KEY_F13;
-		case Keyboard.KEY_F14		: return GLFW.GLFW_KEY_F14;
-		case Keyboard.KEY_F15		: return GLFW.GLFW_KEY_F15;
-		case Keyboard.KEY_F16		: return GLFW.GLFW_KEY_F16;
-		case Keyboard.KEY_F17		: return GLFW.GLFW_KEY_F17;
-		case Keyboard.KEY_F18		: return GLFW.GLFW_KEY_F18;
-		case Keyboard.KEY_F19		: return GLFW.GLFW_KEY_F19;
-		
-		case Keyboard.KEY_NUMPAD1	: return GLFW.GLFW_KEY_KP_1;
-		case Keyboard.KEY_NUMPAD2	: return GLFW.GLFW_KEY_KP_2;
-		case Keyboard.KEY_NUMPAD3	: return GLFW.GLFW_KEY_KP_3;
-		case Keyboard.KEY_NUMPAD4	: return GLFW.GLFW_KEY_KP_4;
-		case Keyboard.KEY_NUMPAD5	: return GLFW.GLFW_KEY_KP_5;
-		case Keyboard.KEY_NUMPAD6	: return GLFW.GLFW_KEY_KP_6;
-		case Keyboard.KEY_NUMPAD7	: return GLFW.GLFW_KEY_KP_7;
-		case Keyboard.KEY_NUMPAD8	: return GLFW.GLFW_KEY_KP_8;
-		case Keyboard.KEY_NUMPAD9	: return GLFW.GLFW_KEY_KP_9;
-		case Keyboard.KEY_NUMPAD0	: return GLFW.GLFW_KEY_KP_0;
-		
-		case Keyboard.KEY_ADD		: return GLFW.GLFW_KEY_KP_ADD;
-		case Keyboard.KEY_SUBTRACT	: return GLFW.GLFW_KEY_KP_SUBTRACT;
-		case Keyboard.KEY_MULTIPLY	: return GLFW.GLFW_KEY_KP_MULTIPLY;
-		case Keyboard.KEY_DIVIDE	: return GLFW.GLFW_KEY_KP_DIVIDE;
-		case Keyboard.KEY_DECIMAL	: return GLFW.GLFW_KEY_KP_DECIMAL;
-		case Keyboard.KEY_NUMPADEQUALS	: return GLFW.GLFW_KEY_KP_EQUAL;
-		case Keyboard.KEY_NUMPADENTER	: return GLFW.GLFW_KEY_KP_ENTER;
-		case Keyboard.KEY_NUMLOCK	: return GLFW.GLFW_KEY_NUM_LOCK;
-		
-		case Keyboard.KEY_SEMICOLON	: return GLFW.GLFW_KEY_SEMICOLON;
-		case Keyboard.KEY_BACKSLASH	: return GLFW.GLFW_KEY_BACKSLASH;
-		case Keyboard.KEY_COMMA		: return GLFW.GLFW_KEY_COMMA;
-		case Keyboard.KEY_PERIOD	: return GLFW.GLFW_KEY_PERIOD;
-		case Keyboard.KEY_SLASH		: return GLFW.GLFW_KEY_SLASH;
-		case Keyboard.KEY_GRAVE		: return GLFW.GLFW_KEY_GRAVE_ACCENT;
-
-		case Keyboard.KEY_CAPITAL	: return GLFW.GLFW_KEY_CAPS_LOCK;
-		case Keyboard.KEY_SCROLL	: return GLFW.GLFW_KEY_SCROLL_LOCK;
-		
-		case Keyboard.KEY_PAUSE		: return GLFW.GLFW_KEY_PAUSE;
-		case Keyboard.KEY_CIRCUMFLEX: return GLFW.GLFW_KEY_WORLD_1; // TODO not sure if correct
-
-		case Keyboard.KEY_MINUS		: return GLFW.GLFW_KEY_MINUS;
-		case Keyboard.KEY_EQUALS	: return GLFW.GLFW_KEY_EQUAL;
-		case Keyboard.KEY_LBRACKET	: return GLFW.GLFW_KEY_LEFT_BRACKET;
-		case Keyboard.KEY_RBRACKET	: return GLFW.GLFW_KEY_RIGHT_BRACKET;
-		case Keyboard.KEY_APOSTROPHE: return GLFW.GLFW_KEY_APOSTROPHE;
-//		public static final int KEY_AT              = 0x91; /*                     (NEC PC98) */
-//		public static final int KEY_COLON           = 0x92; /*                     (NEC PC98) */
-//		public static final int KEY_UNDERLINE       = 0x93; /*                     (NEC PC98) */
-
-//		public static final int KEY_KANA            = 0x70; /* (Japanese keyboard)            */
-//		public static final int KEY_CONVERT         = 0x79; /* (Japanese keyboard)            */
-//		public static final int KEY_NOCONVERT       = 0x7B; /* (Japanese keyboard)            */
-//		public static final int KEY_YEN             = 0x7D; /* (Japanese keyboard)            */
-		
-//		public static final int KEY_CIRCUMFLEX      = 0x90; /* (Japanese keyboard)            */
-//		public static final int KEY_KANJI           = 0x94; /* (Japanese keyboard)            */
-//		public static final int KEY_STOP            = 0x95; /*                     (NEC PC98) */
-//		public static final int KEY_AX              = 0x96; /*                     (Japan AX) */
-//		public static final int KEY_UNLABELED       = 0x97; /*                        (J3100) */
-//		public static final int KEY_SECTION         = 0xA7; /* Section symbol (Mac) */
-//		public static final int KEY_NUMPADCOMMA     = 0xB3; /* , on numeric keypad (NEC PC98) */
-//		public static final int KEY_SYSRQ           = 0xB7;
-//		public static final int KEY_FUNCTION        = 0xC4; /* Function (Mac) */
-		
-//		public static final int KEY_CLEAR           = 0xDA; /* Clear key (Mac) */
-
-//		public static final int KEY_APPS            = 0xDD; /* AppMenu key */
-//		public static final int KEY_POWER           = 0xDE;
-//		public static final int KEY_SLEEP           = 0xDF;
-
-		default: 	System.out.println("UNKNOWN LWJGL KEY CODE: " + lwjglKeyCode);
-					return GLFW.GLFW_KEY_UNKNOWN;
-		}
-	}
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/input/Keyboard.java b/src/embeddedlibs/org/lwjglx/input/Keyboard.java
deleted file mode 100644
index 3d9b9b3..0000000
--- a/src/embeddedlibs/org/lwjglx/input/Keyboard.java
+++ /dev/null
@@ -1,291 +0,0 @@
-package org.lwjglx.input;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.lwjgl.glfw.GLFW;
-import org.lwjglx.LWJGLException;
-import org.lwjglx.Sys;
-import org.lwjglx.opengl.Display;
-
-public class Keyboard {
-	
-	/**
-	 * The special character meaning that no
-	 * character was translated for the event.
-	 */
-	public static final int CHAR_NONE          = '\0';
-
-	/**
-	 * The special keycode meaning that only the
-	 * translated character is valid.
-	 */
-	public static final int KEY_NONE            = 0x00;
-
-	public static final int KEY_ESCAPE          = 0x01;
-	public static final int KEY_1               = 0x02;
-	public static final int KEY_2               = 0x03;
-	public static final int KEY_3               = 0x04;
-	public static final int KEY_4               = 0x05;
-	public static final int KEY_5               = 0x06;
-	public static final int KEY_6               = 0x07;
-	public static final int KEY_7               = 0x08;
-	public static final int KEY_8               = 0x09;
-	public static final int KEY_9               = 0x0A;
-	public static final int KEY_0               = 0x0B;
-	public static final int KEY_MINUS           = 0x0C; /* - on main keyboard */
-	public static final int KEY_EQUALS          = 0x0D;
-	public static final int KEY_BACK            = 0x0E; /* backspace */
-	public static final int KEY_TAB             = 0x0F;
-	public static final int KEY_Q               = 0x10;
-	public static final int KEY_W               = 0x11;
-	public static final int KEY_E               = 0x12;
-	public static final int KEY_R               = 0x13;
-	public static final int KEY_T               = 0x14;
-	public static final int KEY_Y               = 0x15;
-	public static final int KEY_U               = 0x16;
-	public static final int KEY_I               = 0x17;
-	public static final int KEY_O               = 0x18;
-	public static final int KEY_P               = 0x19;
-	public static final int KEY_LBRACKET        = 0x1A;
-	public static final int KEY_RBRACKET        = 0x1B;
-	public static final int KEY_RETURN          = 0x1C; /* Enter on main keyboard */
-	public static final int KEY_LCONTROL        = 0x1D;
-	public static final int KEY_A               = 0x1E;
-	public static final int KEY_S               = 0x1F;
-	public static final int KEY_D               = 0x20;
-	public static final int KEY_F               = 0x21;
-	public static final int KEY_G               = 0x22;
-	public static final int KEY_H               = 0x23;
-	public static final int KEY_J               = 0x24;
-	public static final int KEY_K               = 0x25;
-	public static final int KEY_L               = 0x26;
-	public static final int KEY_SEMICOLON       = 0x27;
-	public static final int KEY_APOSTROPHE      = 0x28;
-	public static final int KEY_GRAVE           = 0x29; /* accent grave */
-	public static final int KEY_LSHIFT          = 0x2A;
-	public static final int KEY_BACKSLASH       = 0x2B;
-	public static final int KEY_Z               = 0x2C;
-	public static final int KEY_X               = 0x2D;
-	public static final int KEY_C               = 0x2E;
-	public static final int KEY_V               = 0x2F;
-	public static final int KEY_B               = 0x30;
-	public static final int KEY_N               = 0x31;
-	public static final int KEY_M               = 0x32;
-	public static final int KEY_COMMA           = 0x33;
-	public static final int KEY_PERIOD          = 0x34; /* . on main keyboard */
-	public static final int KEY_SLASH           = 0x35; /* / on main keyboard */
-	public static final int KEY_RSHIFT          = 0x36;
-	public static final int KEY_MULTIPLY        = 0x37; /* * on numeric keypad */
-	public static final int KEY_LMENU           = 0x38; /* left Alt */
-	public static final int KEY_SPACE           = 0x39;
-	public static final int KEY_CAPITAL         = 0x3A;
-	public static final int KEY_F1              = 0x3B;
-	public static final int KEY_F2              = 0x3C;
-	public static final int KEY_F3              = 0x3D;
-	public static final int KEY_F4              = 0x3E;
-	public static final int KEY_F5              = 0x3F;
-	public static final int KEY_F6              = 0x40;
-	public static final int KEY_F7              = 0x41;
-	public static final int KEY_F8              = 0x42;
-	public static final int KEY_F9              = 0x43;
-	public static final int KEY_F10             = 0x44;
-	public static final int KEY_NUMLOCK         = 0x45;
-	public static final int KEY_SCROLL          = 0x46; /* Scroll Lock */
-	public static final int KEY_NUMPAD7         = 0x47;
-	public static final int KEY_NUMPAD8         = 0x48;
-	public static final int KEY_NUMPAD9         = 0x49;
-	public static final int KEY_SUBTRACT        = 0x4A; /* - on numeric keypad */
-	public static final int KEY_NUMPAD4         = 0x4B;
-	public static final int KEY_NUMPAD5         = 0x4C;
-	public static final int KEY_NUMPAD6         = 0x4D;
-	public static final int KEY_ADD             = 0x4E; /* + on numeric keypad */
-	public static final int KEY_NUMPAD1         = 0x4F;
-	public static final int KEY_NUMPAD2         = 0x50;
-	public static final int KEY_NUMPAD3         = 0x51;
-	public static final int KEY_NUMPAD0         = 0x52;
-	public static final int KEY_DECIMAL         = 0x53; /* . on numeric keypad */
-	public static final int KEY_F11             = 0x57;
-	public static final int KEY_F12             = 0x58;
-	public static final int KEY_F13             = 0x64; /*                     (NEC PC98) */
-	public static final int KEY_F14             = 0x65; /*                     (NEC PC98) */
-	public static final int KEY_F15             = 0x66; /*                     (NEC PC98) */
-	public static final int KEY_F16             = 0x67; /* Extended Function keys - (Mac) */
-	public static final int KEY_F17             = 0x68;
-	public static final int KEY_F18             = 0x69;
-	public static final int KEY_KANA            = 0x70; /* (Japanese keyboard)            */
-	public static final int KEY_F19             = 0x71; /* Extended Function keys - (Mac) */
-	public static final int KEY_CONVERT         = 0x79; /* (Japanese keyboard)            */
-	public static final int KEY_NOCONVERT       = 0x7B; /* (Japanese keyboard)            */
-	public static final int KEY_YEN             = 0x7D; /* (Japanese keyboard)            */
-	public static final int KEY_NUMPADEQUALS    = 0x8D; /* = on numeric keypad (NEC PC98) */
-	public static final int KEY_CIRCUMFLEX      = 0x90; /* (Japanese keyboard)            */
-	public static final int KEY_AT              = 0x91; /*                     (NEC PC98) */
-	public static final int KEY_COLON           = 0x92; /*                     (NEC PC98) */
-	public static final int KEY_UNDERLINE       = 0x93; /*                     (NEC PC98) */
-	public static final int KEY_KANJI           = 0x94; /* (Japanese keyboard)            */
-	public static final int KEY_STOP            = 0x95; /*                     (NEC PC98) */
-	public static final int KEY_AX              = 0x96; /*                     (Japan AX) */
-	public static final int KEY_UNLABELED       = 0x97; /*                        (J3100) */
-	public static final int KEY_NUMPADENTER     = 0x9C; /* Enter on numeric keypad */
-	public static final int KEY_RCONTROL        = 0x9D;
-	public static final int KEY_SECTION         = 0xA7; /* Section symbol (Mac) */
-	public static final int KEY_NUMPADCOMMA     = 0xB3; /* , on numeric keypad (NEC PC98) */
-	public static final int KEY_DIVIDE          = 0xB5; /* / on numeric keypad */
-	public static final int KEY_SYSRQ           = 0xB7;
-	public static final int KEY_RMENU           = 0xB8; /* right Alt */
-	public static final int KEY_FUNCTION        = 0xC4; /* Function (Mac) */
-	public static final int KEY_PAUSE           = 0xC5; /* Pause */
-	public static final int KEY_HOME            = 0xC7; /* Home on arrow keypad */
-	public static final int KEY_UP              = 0xC8; /* UpArrow on arrow keypad */
-	public static final int KEY_PRIOR           = 0xC9; /* PgUp on arrow keypad */
-	public static final int KEY_LEFT            = 0xCB; /* LeftArrow on arrow keypad */
-	public static final int KEY_RIGHT           = 0xCD; /* RightArrow on arrow keypad */
-	public static final int KEY_END             = 0xCF; /* End on arrow keypad */
-	public static final int KEY_DOWN            = 0xD0; /* DownArrow on arrow keypad */
-	public static final int KEY_NEXT            = 0xD1; /* PgDn on arrow keypad */
-	public static final int KEY_INSERT          = 0xD2; /* Insert on arrow keypad */
-	public static final int KEY_DELETE          = 0xD3; /* Delete on arrow keypad */
-	public static final int KEY_CLEAR           = 0xDA; /* Clear key (Mac) */
-	public static final int KEY_LMETA           = 0xDB; /* Left Windows/Option key */
-	public static final int KEY_LWIN            = KEY_LMETA; /* Left Windows key */
-	public static final int KEY_RMETA            = 0xDC; /* Right Windows/Option key */
-	public static final int KEY_RWIN            = KEY_RMETA; /* Right Windows key */
-	public static final int KEY_APPS            = 0xDD; /* AppMenu key */
-	public static final int KEY_POWER           = 0xDE;
-	public static final int KEY_SLEEP           = 0xDF;
-
-	
-	private static EventQueue queue = new EventQueue(4096);
-	//private static int maxEvents = 32;
-	
-	//private static int eventCount = 0;
-	//private static int currentEventPos = -1;
-	//private static int nextEventPos = 0;
-	
-	private static int[] keyEvents = new int[queue.getMaxEvents()];
-	private static boolean[] keyEventStates = new boolean[queue.getMaxEvents()];
-	private static long[] nanoTimeEvents = new long[queue.getMaxEvents()];
-	private static char[] keyEventChars = new char[256];
-	
-	public static final int KEYBOARD_SIZE = 256;
-	
-	private static final String[] keyName = new String[KEYBOARD_SIZE];
-	private static final Map<String, Integer> keyMap = new HashMap<String, Integer>(253);
-	
-	static {
-		// Use reflection to find out key names
-		Field[] fields = Keyboard.class.getFields();
-		try {
-			for ( Field field : fields ) {
-				if ( Modifier.isStatic(field.getModifiers())
-				     && Modifier.isPublic(field.getModifiers())
-				     && Modifier.isFinal(field.getModifiers())
-				     && field.getType().equals(int.class)
-				     && field.getName().startsWith("KEY_")
-				     && !field.getName().endsWith("WIN") ) { /* Don't use deprecated names */
-
-					int key = field.getInt(null);
-					String name = field.getName().substring(4);
-					keyName[key] = name;
-					keyMap.put(name, key);
-				}
-
-			}
-		} catch (Exception e) {
-		}
-
-	}
-	
-	public static void addKeyEvent(int key, boolean pressed) {
-		//eventCount++;
-		//if (eventCount > maxEvents) eventCount = maxEvents;
-		
-		keyEvents[queue.getNextPos()] = KeyCodes.toLwjglKey(key);
-		keyEventStates[queue.getNextPos()] = pressed;
-		
-		nanoTimeEvents[queue.getNextPos()] = Sys.getNanoTime();
-		
-		queue.add();
-		/*nextEventPos++;
-		if (nextEventPos == maxEvents) nextEventPos = 0;
-		
-		if (currentEventPos == nextEventPos) currentEventPos++;
-		if (currentEventPos == maxEvents) currentEventPos = 0;*/
-	}
-	
-	public static void addCharEvent(int key, char c) {
-		int index = KeyCodes.toLwjglKey(key);
-		keyEventChars[index] = c;
-	}
-	
-	public static void create() throws LWJGLException {
-		
-	}
-            
-	public static boolean isKeyDown(int key) {
-		return GLFW.glfwGetKey(Display.getWindow(), KeyCodes.toGlfwKey(key)) == GLFW.GLFW_PRESS;
-	}
-	
-	public static void poll() {
-		// TODO
-	}
-	
-	public static void enableRepeatEvents(boolean enable) {
-
-	}
-	
-	public static boolean isRepeatEvent() {
-		// TODO
-		return false;
-	}
-	
-	public static boolean next() {
-		return queue.next();
-		/*if (eventCount == 0) return false;
-		
-		eventCount--;
-		currentEventPos++;
-		if (currentEventPos == maxEvents) currentEventPos = 0;
-		
-		return true;*/
-	}
-	
-	public static int getEventKey() {
-		return keyEvents[queue.getCurrentPos()];
-	}
-	
-	public static char getEventCharacter() {
-		return keyEventChars[getEventKey()];
-	}
-	
-	public static boolean getEventKeyState() {
-		return keyEventStates[queue.getCurrentPos()];
-	}
-	
-	public static long getEventNanoseconds() {
-		return nanoTimeEvents[queue.getCurrentPos()];
-	}
-	
-	public static String getKeyName(int key) {
-		return keyName[key];
-	}
-	
-	public static int getKeyIndex(java.lang.String keyName) {
-		Integer ret = keyMap.get(keyName);
-		if (ret == null)
-			return KEY_NONE;
-		else
-			return ret;
-	}
-	
-	public static boolean isCreated() {
-		return Display.isCreated();
-	}
-	
-	public static void destroy() {
-		
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/input/Mouse.java b/src/embeddedlibs/org/lwjglx/input/Mouse.java
deleted file mode 100644
index 1515210..0000000
--- a/src/embeddedlibs/org/lwjglx/input/Mouse.java
+++ /dev/null
@@ -1,211 +0,0 @@
-package org.lwjglx.input;
-
-import org.lwjgl.glfw.GLFW;
-import org.lwjglx.LWJGLException;
-import org.lwjglx.Sys;
-import org.lwjglx.opengl.Display;
-
-import javax.vecmath.Vector2d;
-
-public class Mouse {
-
-    private static boolean grabbed = false;
-
-    private static int lastX = 0;
-    private static int lastY = 0;
-
-    private static int latestX = 0;
-    private static int latestY = 0;
-
-    private static int x = 0;
-    private static int y = 0;
-
-    private static EventQueue queue = new EventQueue(4096);
-
-    private static int[] buttonEvents = new int[queue.getMaxEvents()];
-    private static boolean[] buttonEventStates = new boolean[queue.getMaxEvents()];
-    private static int[] xEvents = new int[queue.getMaxEvents()];
-    private static int[] yEvents = new int[queue.getMaxEvents()];
-    private static int[] lastxEvents = new int[queue.getMaxEvents()];
-    private static int[] lastyEvents = new int[queue.getMaxEvents()];
-    private static long[] nanoTimeEvents = new long[queue.getMaxEvents()];
-
-    private static boolean clipPostionToDisplay = true;
-
-    private static int xScroll, yScroll;
-
-    private static boolean hasScroll;
-
-
-    public static void addMoveEvent(double mouseX, double mouseY) {
-        latestX = (int) mouseX;
-        latestY = Display.getHeight() - (int) mouseY;
-
-        lastxEvents[queue.getNextPos()] = xEvents[queue.getNextPos()];
-        lastyEvents[queue.getNextPos()] = yEvents[queue.getNextPos()];
-
-        xEvents[queue.getNextPos()] = latestX;
-        yEvents[queue.getNextPos()] = latestY;
-
-        buttonEvents[queue.getNextPos()] = -1;
-        buttonEventStates[queue.getNextPos()] = false;
-
-        nanoTimeEvents[queue.getNextPos()] = Sys.getNanoTime();
-
-        queue.add();
-    }
-
-    public static void addWheelEvent(double xoffset, double yoffset) {
-
-        if (queue.getCurrentPos() == -1)
-            return;
-
-        xScroll = (int) xoffset;
-        yScroll = (int) yoffset;
-        hasScroll = true;
-    }
-
-    public static void addButtonEvent(int button, boolean pressed) {
-        lastxEvents[queue.getNextPos()] = xEvents[queue.getNextPos()];
-        lastyEvents[queue.getNextPos()] = yEvents[queue.getNextPos()];
-
-        xEvents[queue.getNextPos()] = latestX;
-        yEvents[queue.getNextPos()] = latestY;
-
-        buttonEvents[queue.getNextPos()] = button;
-        buttonEventStates[queue.getNextPos()] = pressed;
-
-        nanoTimeEvents[queue.getNextPos()] = Sys.getNanoTime();
-
-        queue.add();
-    }
-
-    public static void poll() {
-        lastX = x;
-        lastY = y;
-
-        if (!grabbed && clipPostionToDisplay) {
-            if (latestX < 0) latestX = 0;
-            if (latestY < 0) latestY = 0;
-            if (latestX > Display.getWidth() - 1) latestX = Display.getWidth() - 1;
-            if (latestY > Display.getHeight() - 1) latestY = Display.getHeight() - 1;
-        }
-
-        x = latestX;
-        y = latestY;
-
-    }
-
-    public static void create() throws LWJGLException {
-    }
-
-    public static boolean isCreated() {
-        return Display.isCreated();
-    }
-
-    public static void setGrabbed(boolean grab) {
-        GLFW.glfwSetInputMode(Display.getWindow(),
-                GLFW.GLFW_CURSOR,
-                grab ? GLFW.GLFW_CURSOR_DISABLED : GLFW.GLFW_CURSOR_NORMAL);
-        grabbed = grab;
-    }
-
-    public static boolean isGrabbed() {
-        return grabbed;
-    }
-
-    public static boolean isButtonDown(int button) {
-        return GLFW.glfwGetMouseButton(Display.getWindow(), button) == GLFW.GLFW_PRESS;
-    }
-
-    public static boolean next() {
-        boolean has = hasScroll;
-        hasScroll = false;
-        return has || queue.next();
-    }
-
-    public static int getEventX() {
-        return xEvents[queue.getCurrentPos()];
-    }
-
-    public static int getEventY() {
-        return yEvents[queue.getCurrentPos()];
-    }
-
-    public static int getEventDX() {
-        return xEvents[queue.getCurrentPos()] - lastxEvents[queue.getCurrentPos()];
-    }
-
-    public static int getEventDY() {
-        return yEvents[queue.getCurrentPos()] - lastyEvents[queue.getCurrentPos()];
-    }
-
-    public static long getEventNanoseconds() {
-        return nanoTimeEvents[queue.getCurrentPos()];
-    }
-
-    public static int getEventButton() {
-        return buttonEvents[queue.getCurrentPos()];
-    }
-
-    public static boolean getEventButtonState() {
-        return buttonEventStates[queue.getCurrentPos()];
-    }
-
-    public static int getEventDWheel() {
-        int retV = yScroll;
-        yScroll = 0;
-        return retV;
-    }
-
-    public static int getX() {
-        return x;
-    }
-
-    public static int getY() {
-        return y;
-    }
-
-    public static int getDX() {
-        return x - lastX;
-    }
-
-    public static int getDY() {
-        return y - lastY;
-    }
-
-    public static int getDWheel() {
-        int retV = yScroll;
-        yScroll = 0;
-        return retV;
-    }
-
-    public static int getButtonCount() {
-        return 8; // max mouse buttons supported by GLFW
-    }
-
-    public static void setClipMouseCoordinatesToWindow(boolean clip) {
-        clipPostionToDisplay = clip;
-    }
-
-    public static void setCursorPosition(int new_x, int new_y) {
-        GLFW.glfwSetCursorPos(Display.getWindow(), new_x, new_y);
-    }
-
-    public static Cursor setNativeCursor(Cursor cursor) throws LWJGLException {
-        // TODO
-        System.out.println("TODO: Implement Mouse.setNativeCursor(Cursor)");
-        return null;
-    }
-
-    public static void destroy() {
-
-    }
-
-    public static boolean isInsideWindow() {
-
-        return Display.getX() < getX() && Display.getY() < getY()
-                && Display.getHeight() + Display.getY() > getY()
-                && Display.getWidth() + Display.getX() > getX();
-    }
-}
diff --git a/src/embeddedlibs/org/lwjglx/opengl/AWTGLCanvas.java b/src/embeddedlibs/org/lwjglx/opengl/AWTGLCanvas.java
deleted file mode 100644
index bc07278..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/AWTGLCanvas.java
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-import org.lwjglx.LWJGLException;
-import org.lwjglx.PointerBuffer;
-
-import java.awt.*;
-import java.awt.event.ComponentEvent;
-import java.awt.event.ComponentListener;
-import java.awt.event.HierarchyEvent;
-import java.awt.event.HierarchyListener;
-
-public class AWTGLCanvas extends Canvas implements Drawable, ComponentListener, HierarchyListener {
-
-	private static final long serialVersionUID = 1L;
-
-	public void setPixelFormat(final PixelFormatLWJGL pf) throws LWJGLException {
-		throw new UnsupportedOperationException();
-	}
-
-	public void setPixelFormat(final PixelFormatLWJGL pf, final ContextAttribs attribs) throws LWJGLException {
-		throw new UnsupportedOperationException();
-	}
-
-	public PixelFormatLWJGL getPixelFormat() {
-		return null;
-	}
-
-	public ContextGL getContext() {
-		return null;
-	}
-
-	public ContextGL createSharedContext() throws LWJGLException {
-		return null;
-	}
-
-	public void checkGLError() {
-		
-	}
-
-	public void initContext(final float r, final float g, final float b) {
-		
-	}
-
-	public AWTGLCanvas() throws LWJGLException {
-		
-	}
-
-	public AWTGLCanvas(PixelFormat pixel_format) throws LWJGLException {
-		
-	}
-
-	public AWTGLCanvas(GraphicsDevice device, PixelFormat pixel_format) throws LWJGLException {
-		
-	}
-
-	public AWTGLCanvas(GraphicsDevice device, PixelFormat pixel_format, Drawable drawable) throws LWJGLException {
-		
-	}
-
-	public AWTGLCanvas(GraphicsDevice device, PixelFormat pixel_format, Drawable drawable, ContextAttribs attribs) throws LWJGLException {
-		
-	}
-
-	public void addNotify() {
-		
-	}
-
-	public void removeNotify() {
-		
-	}
-
-	public void setSwapInterval(int swap_interval) {
-		
-	}
-
-	public void setVSyncEnabled(boolean enabled) {
-		
-	}
-
-	public void swapBuffers() throws LWJGLException {
-		
-	}
-
-	public boolean isCurrent() throws LWJGLException {
-		return false;
-	}
-
-	public void makeCurrent() throws LWJGLException {
-		
-	}
-
-	public void releaseContext() throws LWJGLException {
-		
-	}
-
-	public final void destroy() {
-		
-	}
-
-	public final void setCLSharingProperties(final PointerBuffer properties) throws LWJGLException {
-		
-	}
-
-	protected void initGL() {
-	
-	}
-
-	protected void paintGL() {
-	
-	}
-
-	public final void paint(Graphics g) {
-		
-	}
-
-	protected void exceptionOccurred(LWJGLException exception) {
-		
-	}
-
-	public void update(Graphics g) {
-		
-	}
-
-	public void componentShown(ComponentEvent e) {
-	
-	}
-
-	public void componentHidden(ComponentEvent e) {
-	
-	}
-
-	public void componentResized(ComponentEvent e) {
-		
-	}
-
-	public void componentMoved(ComponentEvent e) {
-		
-	}
-
-	public void setLocation(int x, int y) {
-		
-	}
-
-	public void setLocation(Point p) {
-		
-	}
-
-	public void setSize(Dimension d) {
-		
-	}
-
-	public void setSize(int width, int height) {
-		
-	}
-
-	public void setBounds(int x, int y, int width, int height) {
-		
-	}
-
-	public void hierarchyChanged(HierarchyEvent e) {
-		
-	}
-
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/opengl/Context.java b/src/embeddedlibs/org/lwjglx/opengl/Context.java
deleted file mode 100644
index 1896a3b..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/Context.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (c) 2002-2011 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-import org.lwjglx.LWJGLException;
-
-/**
- * @author Spasi
- * @since 14/5/2011
- */
-interface Context {
-
-	boolean isCurrent() throws LWJGLException;
-
-	void makeCurrent() throws LWJGLException;
-
-	void releaseCurrent() throws LWJGLException;
-
-	void releaseDrawable() throws LWJGLException;
-
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/opengl/ContextAttribs.java b/src/embeddedlibs/org/lwjglx/opengl/ContextAttribs.java
deleted file mode 100644
index f57be2e..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/ContextAttribs.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-public final class ContextAttribs {
-
-	public ContextAttribs() {
-		
-	}
-
-	public ContextAttribs(final int majorVersion, final int minorVersion) {
-		
-	}
-
-	public int getMajorVersion() {
-		return 0;
-	}
-
-	public int getMinorVersion() {
-		return 0;
-	}
-
-	public int getLayerPlane() {
-		return 0;
-	}
-
-	public boolean isDebug() {
-		return false;
-	}
-
-	public boolean isForwardCompatible() {
-		return false;
-	}
-
-	public boolean isProfileCore() {
-		return false;
-	}
-
-	public boolean isProfileCompatibility() {
-		return false;
-	}
-
-	public boolean isProfileES() {
-		return false;
-	}
-
-	public ContextAttribs withLayer(final int layerPlane) {
-		return null;
-	}
-
-	public ContextAttribs withDebug(final boolean debug) {
-		return null;
-	}
-
-	public ContextAttribs withForwardCompatible(final boolean forwardCompatible) {
-		return null;
-	}
-
-	public ContextAttribs withProfileCore(final boolean profileCore) {
-		return null;
-	}
-
-	public ContextAttribs withProfileCompatibility(final boolean profileCompatibility) {
-		return null;
-	}
-
-	public ContextAttribs withProfileES(final boolean profileES) {
-		return null;
-	}
-
-	public ContextAttribs withLoseContextOnReset(final boolean loseContextOnReset) {
-		return null;
-	}
-
-	public ContextAttribs withContextResetIsolation(final boolean contextResetIsolation) {
-		return null;
-	}
-
-	public String toString() {
-		return null;
-	}
-
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/opengl/ContextCapabilities.java b/src/embeddedlibs/org/lwjglx/opengl/ContextCapabilities.java
deleted file mode 100644
index ff472c4..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/ContextCapabilities.java
+++ /dev/null
@@ -1,405 +0,0 @@
-package org.lwjglx.opengl;
-
-import org.lwjgl.opengl.GL;
-import org.lwjgl.opengl.GLCapabilities;
-
-import java.lang.reflect.Field;
-
-public class ContextCapabilities {
-	
-	GLCapabilities cap = GL.getCapabilities();
-	
-	public ContextCapabilities() {
-		
-		Field[] fields = cap.getClass().getFields();
-		
-		try {
-			for ( Field field : fields ) {
-				
-				String name = field.getName();
-				
-				if (name.startsWith("GL_") || name.startsWith("OpenGL")) {
-					
-					boolean value = field.getBoolean(cap);
-					
-					try {
-						Field f = this.getClass().getField(name);
-						f.setBoolean(this, value);
-					} catch (Exception e) {
-					}
-				}
-			}
-		} catch (Exception e) {
-			System.out.println(e);
-		}
-	}
-	
-	public boolean GL_AMD_blend_minmax_factor;
-	public boolean GL_AMD_conservative_depth;
-	public boolean GL_AMD_debug_output;
-	public boolean GL_AMD_depth_clamp_separate;
-	public boolean GL_AMD_draw_buffers_blend;
-	public boolean GL_AMD_interleaved_elements;
-	public boolean GL_AMD_multi_draw_indirect;
-	public boolean GL_AMD_name_gen_delete;
-	public boolean GL_AMD_performance_monitor;
-	public boolean GL_AMD_pinned_memory;
-	public boolean GL_AMD_query_buffer_object;
-	public boolean GL_AMD_sample_positions;
-	public boolean GL_AMD_seamless_cubemap_per_texture;
-	public boolean GL_AMD_shader_atomic_counter_ops;
-	public boolean GL_AMD_shader_stencil_export;
-	public boolean GL_AMD_shader_trinary_minmax;
-	public boolean GL_AMD_sparse_texture;
-	public boolean GL_AMD_stencil_operation_extended;
-	public boolean GL_AMD_texture_texture4;
-	public boolean GL_AMD_transform_feedback3_lines_triangles;
-	public boolean GL_AMD_vertex_shader_layer;
-	public boolean GL_AMD_vertex_shader_tessellator;
-	public boolean GL_AMD_vertex_shader_viewport_index;
-	public boolean GL_APPLE_aux_depth_stencil;
-	public boolean GL_APPLE_client_storage;
-	public boolean GL_APPLE_element_array;
-	public boolean GL_APPLE_fence;
-	public boolean GL_APPLE_float_pixels;
-	public boolean GL_APPLE_flush_buffer_range;
-	public boolean GL_APPLE_object_purgeable;
-	public boolean GL_APPLE_packed_pixels;
-	public boolean GL_APPLE_rgb_422;
-	public boolean GL_APPLE_row_bytes;
-	public boolean GL_APPLE_texture_range;
-	public boolean GL_APPLE_vertex_array_object;
-	public boolean GL_APPLE_vertex_array_range;
-	public boolean GL_APPLE_vertex_program_evaluators;
-	public boolean GL_APPLE_ycbcr_422;
-	public boolean GL_ARB_ES2_compatibility;
-	public boolean GL_ARB_ES3_compatibility;
-	public boolean GL_ARB_arrays_of_arrays;
-	public boolean GL_ARB_base_instance;
-	public boolean GL_ARB_bindless_texture;
-	public boolean GL_ARB_blend_func_extended;
-	public boolean GL_ARB_buffer_storage;
-	public boolean GL_ARB_cl_event;
-	public boolean GL_ARB_clear_buffer_object;
-	public boolean GL_ARB_clear_texture;
-	public boolean GL_ARB_color_buffer_float;
-	public boolean GL_ARB_compatibility;
-	public boolean GL_ARB_compressed_texture_pixel_storage;
-	public boolean GL_ARB_compute_shader;
-	public boolean GL_ARB_compute_variable_group_size;
-	public boolean GL_ARB_conservative_depth;
-	public boolean GL_ARB_copy_buffer;
-	public boolean GL_ARB_copy_image;
-	public boolean GL_ARB_debug_output;
-	public boolean GL_ARB_depth_buffer_float;
-	public boolean GL_ARB_depth_clamp;
-	public boolean GL_ARB_depth_texture;
-	public boolean GL_ARB_draw_buffers;
-	public boolean GL_ARB_draw_buffers_blend;
-	public boolean GL_ARB_draw_elements_base_vertex;
-	public boolean GL_ARB_draw_indirect;
-	public boolean GL_ARB_draw_instanced;
-	public boolean GL_ARB_enhanced_layouts;
-	public boolean GL_ARB_explicit_attrib_location;
-	public boolean GL_ARB_explicit_uniform_location;
-	public boolean GL_ARB_fragment_coord_conventions;
-	public boolean GL_ARB_fragment_layer_viewport;
-	public boolean GL_ARB_fragment_program;
-	public boolean GL_ARB_fragment_program_shadow;
-	public boolean GL_ARB_fragment_shader;
-	public boolean GL_ARB_framebuffer_no_attachments;
-	public boolean GL_ARB_framebuffer_object;
-	public boolean GL_ARB_framebuffer_sRGB;
-	public boolean GL_ARB_geometry_shader4;
-	public boolean GL_ARB_get_program_binary;
-	public boolean GL_ARB_gpu_shader5;
-	public boolean GL_ARB_gpu_shader_fp64;
-	public boolean GL_ARB_half_float_pixel;
-	public boolean GL_ARB_half_float_vertex;
-	public boolean GL_ARB_imaging;
-	public boolean GL_ARB_indirect_parameters;
-	public boolean GL_ARB_instanced_arrays;
-	public boolean GL_ARB_internalformat_query;
-	public boolean GL_ARB_internalformat_query2;
-	public boolean GL_ARB_invalidate_subdata;
-	public boolean GL_ARB_map_buffer_alignment;
-	public boolean GL_ARB_map_buffer_range;
-	public boolean GL_ARB_matrix_palette;
-	public boolean GL_ARB_multi_bind;
-	public boolean GL_ARB_multi_draw_indirect;
-	public boolean GL_ARB_multisample;
-	public boolean GL_ARB_multitexture;
-	public boolean GL_ARB_occlusion_query;
-	public boolean GL_ARB_occlusion_query2;
-	public boolean GL_ARB_pixel_buffer_object;
-	public boolean GL_ARB_point_parameters;
-	public boolean GL_ARB_point_sprite;
-	public boolean GL_ARB_program_interface_query;
-	public boolean GL_ARB_provoking_vertex;
-	public boolean GL_ARB_query_buffer_object;
-	public boolean GL_ARB_robust_buffer_access_behavior;
-	public boolean GL_ARB_robustness;
-	public boolean GL_ARB_robustness_isolation;
-	public boolean GL_ARB_sample_shading;
-	public boolean GL_ARB_sampler_objects;
-	public boolean GL_ARB_seamless_cube_map;
-	public boolean GL_ARB_seamless_cubemap_per_texture;
-	public boolean GL_ARB_separate_shader_objects;
-	public boolean GL_ARB_shader_atomic_counters;
-	public boolean GL_ARB_shader_bit_encoding;
-	public boolean GL_ARB_shader_draw_parameters;
-	public boolean GL_ARB_shader_group_vote;
-	public boolean GL_ARB_shader_image_load_store;
-	public boolean GL_ARB_shader_image_size;
-	public boolean GL_ARB_shader_objects;
-	public boolean GL_ARB_shader_precision;
-	public boolean GL_ARB_shader_stencil_export;
-	public boolean GL_ARB_shader_storage_buffer_object;
-	public boolean GL_ARB_shader_subroutine;
-	public boolean GL_ARB_shader_texture_lod;
-	public boolean GL_ARB_shading_language_100;
-	public boolean GL_ARB_shading_language_420pack;
-	public boolean GL_ARB_shading_language_include;
-	public boolean GL_ARB_shading_language_packing;
-	public boolean GL_ARB_shadow;
-	public boolean GL_ARB_shadow_ambient;
-	public boolean GL_ARB_sparse_texture;
-	public boolean GL_ARB_stencil_texturing;
-	public boolean GL_ARB_sync;
-	public boolean GL_ARB_tessellation_shader;
-	public boolean GL_ARB_texture_border_clamp;
-	public boolean GL_ARB_texture_buffer_object;
-	public boolean GL_ARB_texture_buffer_object_rgb32;
-	public boolean GL_ARB_texture_buffer_range;
-	public boolean GL_ARB_texture_compression;
-	public boolean GL_ARB_texture_compression_bptc;
-	public boolean GL_ARB_texture_compression_rgtc;
-	public boolean GL_ARB_texture_cube_map;
-	public boolean GL_ARB_texture_cube_map_array;
-	public boolean GL_ARB_texture_env_add;
-	public boolean GL_ARB_texture_env_combine;
-	public boolean GL_ARB_texture_env_crossbar;
-	public boolean GL_ARB_texture_env_dot3;
-	public boolean GL_ARB_texture_float;;
-	public boolean GL_ARB_texture_gather;
-	public boolean GL_ARB_texture_mirror_clamp_to_edge;
-	public boolean GL_ARB_texture_mirrored_repeat;
-	public boolean GL_ARB_texture_multisample;
-	public boolean GL_ARB_texture_non_power_of_two;
-	public boolean GL_ARB_texture_query_levels;
-	public boolean GL_ARB_texture_query_lod;
-	public boolean GL_ARB_texture_rectangle;
-	public boolean GL_ARB_texture_rg;
-	public boolean GL_ARB_texture_rgb10_a2ui;
-	public boolean GL_ARB_texture_stencil8;
-	public boolean GL_ARB_texture_storage;
-	public boolean GL_ARB_texture_storage_multisample;
-	public boolean GL_ARB_texture_swizzle;
-	public boolean GL_ARB_texture_view;
-	public boolean GL_ARB_timer_query;
-	public boolean GL_ARB_transform_feedback2;
-	public boolean GL_ARB_transform_feedback3;
-	public boolean GL_ARB_transform_feedback_instanced;
-	public boolean GL_ARB_transpose_matrix;
-	public boolean GL_ARB_uniform_buffer_object;
-	public boolean GL_ARB_vertex_array_bgra;
-	public boolean GL_ARB_vertex_array_object;
-	public boolean GL_ARB_vertex_attrib_64bit;
-	public boolean GL_ARB_vertex_attrib_binding;
-	public boolean GL_ARB_vertex_blend;
-	public boolean GL_ARB_vertex_buffer_object;
-	public boolean GL_ARB_vertex_program;
-	public boolean GL_ARB_vertex_shader;
-	public boolean GL_ARB_vertex_type_10f_11f_11f_rev;
-	public boolean GL_ARB_vertex_type_2_10_10_10_rev;
-	public boolean GL_ARB_viewport_array;
-	public boolean GL_ARB_window_pos;
-	public boolean GL_ATI_draw_buffers;
-	public boolean GL_ATI_element_array;
-	public boolean GL_ATI_envmap_bumpmap;
-	public boolean GL_ATI_fragment_shader;
-	public boolean GL_ATI_map_object_buffer;
-	public boolean GL_ATI_meminfo;
-	public boolean GL_ATI_pn_triangles;
-	public boolean GL_ATI_separate_stencil;
-	public boolean GL_ATI_shader_texture_lod;
-	public boolean GL_ATI_text_fragment_shader;
-	public boolean GL_ATI_texture_compression_3dc;
-	public boolean GL_ATI_texture_env_combine3;
-	public boolean GL_ATI_texture_float;
-	public boolean GL_ATI_texture_mirror_once;
-	public boolean GL_ATI_vertex_array_object;
-	public boolean GL_ATI_vertex_attrib_array_object;
-	public boolean GL_ATI_vertex_streams;
-	public boolean GL_EXT_abgr;
-	public boolean GL_EXT_bgra;
-	public boolean GL_EXT_bindable_uniform;
-	public boolean GL_EXT_blend_color;
-	public boolean GL_EXT_blend_equation_separate;
-	public boolean GL_EXT_blend_func_separate;
-	public boolean GL_EXT_blend_minmax;
-	public boolean GL_EXT_blend_subtract;
-	public boolean GL_EXT_Cg_shader;
-	public boolean GL_EXT_compiled_vertex_array;
-	public boolean GL_EXT_depth_bounds_test;
-	public boolean GL_EXT_direct_state_access;
-	public boolean GL_EXT_draw_buffers2;
-	public boolean GL_EXT_draw_instanced;
-	public boolean GL_EXT_draw_range_elements;
-	public boolean GL_EXT_fog_coord;
-	public boolean GL_EXT_framebuffer_blit;
-	public boolean GL_EXT_framebuffer_multisample;
-	public boolean GL_EXT_framebuffer_multisample_blit_scaled;
-	public boolean GL_EXT_framebuffer_object;
-	public boolean GL_EXT_framebuffer_sRGB;
-	public boolean GL_EXT_geometry_shader4;
-	public boolean GL_EXT_gpu_program_parameters;
-	public boolean GL_EXT_gpu_shader4;
-	public boolean GL_EXT_multi_draw_arrays;
-	public boolean GL_EXT_packed_depth_stencil;
-	public boolean GL_EXT_packed_float;
-	public boolean GL_EXT_packed_pixels;
-	public boolean GL_EXT_paletted_texture;
-	public boolean GL_EXT_pixel_buffer_object;
-	public boolean GL_EXT_point_parameters;
-	public boolean GL_EXT_provoking_vertex;
-	public boolean GL_EXT_rescale_normal;
-	public boolean GL_EXT_secondary_color;
-	public boolean GL_EXT_separate_shader_objects;
-	public boolean GL_EXT_separate_specular_color;
-	public boolean GL_EXT_shader_image_load_store;
-	public boolean GL_EXT_shadow_funcs;
-	public boolean GL_EXT_shared_texture_palette;
-	public boolean GL_EXT_stencil_clear_tag;
-	public boolean GL_EXT_stencil_two_side;
-	public boolean GL_EXT_stencil_wrap;
-	public boolean GL_EXT_texture_3d;
-	public boolean GL_EXT_texture_array;
-	public boolean GL_EXT_texture_buffer_object;
-	public boolean GL_EXT_texture_compression_latc;
-	public boolean GL_EXT_texture_compression_rgtc;
-	public boolean GL_EXT_texture_compression_s3tc;
-	public boolean GL_EXT_texture_env_combine;
-	public boolean GL_EXT_texture_env_dot3;
-	public boolean GL_EXT_texture_filter_anisotropic;
-	public boolean GL_EXT_texture_integer;
-	public boolean GL_EXT_texture_lod_bias;
-	public boolean GL_EXT_texture_mirror_clamp;
-	public boolean GL_EXT_texture_rectangle;
-	public boolean GL_EXT_texture_sRGB;
-	public boolean GL_EXT_texture_sRGB_decode;
-	public boolean GL_EXT_texture_shared_exponent;
-	public boolean GL_EXT_texture_snorm;
-	public boolean GL_EXT_texture_swizzle;
-	public boolean GL_EXT_timer_query;
-	public boolean GL_EXT_transform_feedback;
-	public boolean GL_EXT_vertex_array_bgra;
-	public boolean GL_EXT_vertex_attrib_64bit;
-	public boolean GL_EXT_vertex_shader;
-	public boolean GL_EXT_vertex_weighting;
-	public boolean OpenGL11;
-	public boolean OpenGL12;
-	public boolean OpenGL13;
-	public boolean OpenGL14;
-	public boolean OpenGL15;
-	public boolean OpenGL20;
-	public boolean OpenGL21;
-	public boolean OpenGL30;
-	public boolean OpenGL31;
-	public boolean OpenGL32;
-	public boolean OpenGL33;
-	public boolean OpenGL40;
-	public boolean OpenGL41;
-	public boolean OpenGL42;
-	public boolean OpenGL43;
-	public boolean OpenGL44;
-	public boolean GL_GREMEDY_frame_terminator;
-	public boolean GL_GREMEDY_string_marker;
-	public boolean GL_HP_occlusion_test;
-	public boolean GL_IBM_rasterpos_clip;
-	public boolean GL_INTEL_map_texture;
-	public boolean GL_KHR_debug;
-	public boolean GL_KHR_texture_compression_astc_ldr;
-	public boolean GL_NVX_gpu_memory_info;
-	public boolean GL_NV_bindless_multi_draw_indirect;
-	public boolean GL_NV_bindless_texture;
-	public boolean GL_NV_blend_equation_advanced;
-	public boolean GL_NV_blend_square;
-	public boolean GL_NV_compute_program5;
-	public boolean GL_NV_conditional_render;
-	public boolean GL_NV_copy_depth_to_color;
-	public boolean GL_NV_copy_image;
-	public boolean GL_NV_deep_texture3D;
-	public boolean GL_NV_depth_buffer_float;
-	public boolean GL_NV_depth_clamp;
-	public boolean GL_NV_draw_texture;
-	public boolean GL_NV_evaluators;
-	public boolean GL_NV_explicit_multisample;
-	public boolean GL_NV_fence;
-	public boolean GL_NV_float_buffer;
-	public boolean GL_NV_fog_distance;
-	public boolean GL_NV_fragment_program;
-	public boolean GL_NV_fragment_program2;
-	public boolean GL_NV_fragment_program4;
-	public boolean GL_NV_fragment_program_option;
-	public boolean GL_NV_framebuffer_multisample_coverage;
-	public boolean GL_NV_geometry_program4;
-	public boolean GL_NV_geometry_shader4;
-	public boolean GL_NV_gpu_program4;
-	public boolean GL_NV_gpu_program5;
-	public boolean GL_NV_gpu_program5_mem_extended;
-	public boolean GL_NV_gpu_shader5;
-	public boolean GL_NV_half_float;
-	public boolean GL_NV_light_max_exponent;
-	public boolean GL_NV_multisample_coverage;
-	public boolean GL_NV_multisample_filter_hint;
-	public boolean GL_NV_occlusion_query;
-	public boolean GL_NV_packed_depth_stencil;
-	public boolean GL_NV_parameter_buffer_object;
-	public boolean GL_NV_parameter_buffer_object2;
-	public boolean GL_NV_path_rendering;
-	public boolean GL_NV_pixel_data_range;
-	public boolean GL_NV_point_sprite;
-	public boolean GL_NV_present_video;
-	public boolean GL_NV_primitive_restart;
-	public boolean GL_NV_register_combiners;
-	public boolean GL_NV_register_combiners2;
-	public boolean GL_NV_shader_atomic_counters;
-	public boolean GL_NV_shader_atomic_float;
-	public boolean GL_NV_shader_buffer_load;
-	public boolean GL_NV_shader_buffer_store;
-	public boolean GL_NV_shader_storage_buffer_object;
-	public boolean GL_NV_tessellation_program5;
-	public boolean GL_NV_texgen_reflection;
-	public boolean GL_NV_texture_barrier;
-	public boolean GL_NV_texture_compression_vtc;
-	public boolean GL_NV_texture_env_combine4;
-	public boolean GL_NV_texture_expand_normal;
-	public boolean GL_NV_texture_multisample;
-	public boolean GL_NV_texture_rectangle;
-	public boolean GL_NV_texture_shader;
-	public boolean GL_NV_texture_shader2;
-	public boolean GL_NV_texture_shader3;
-	public boolean GL_NV_transform_feedback;
-	public boolean GL_NV_transform_feedback2;
-	public boolean GL_NV_vertex_array_range;
-	public boolean GL_NV_vertex_array_range2;
-	public boolean GL_NV_vertex_attrib_integer_64bit;
-	public boolean GL_NV_vertex_buffer_unified_memory;
-	public boolean GL_NV_vertex_program;
-	public boolean GL_NV_vertex_program1_1;
-	public boolean GL_NV_vertex_program2;
-	public boolean GL_NV_vertex_program2_option;
-	public boolean GL_NV_vertex_program3;
-	public boolean GL_NV_vertex_program4;
-	public boolean GL_NV_video_capture;
-	public boolean GL_SGIS_generate_mipmap;
-	public boolean GL_SGIS_texture_lod;
-	public boolean GL_SUN_slice_accum;
-	
-	public static void main(String[] arg) {
-		System.out.println("START!");
-		new ContextCapabilities();
-	}
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/opengl/ContextGL.java b/src/embeddedlibs/org/lwjglx/opengl/ContextGL.java
deleted file mode 100644
index a226bab..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/ContextGL.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-import org.lwjglx.LWJGLException;
-import org.lwjglx.PointerBuffer;
-
-/**
- * <p/>
- * Context encapsulates an OpenGL context.
- * <p/>
- * <p/>
- * This class is thread-safe.
- *
- * @author elias_naur <elias_naur@users.sourceforge.net>
- * @version $Revision$
- *          $Id$
- */
-final class ContextGL implements Context {
-
-	public void releaseCurrent() throws LWJGLException {
-		
-	}
-
-	public synchronized void releaseDrawable() throws LWJGLException {
-		
-	}
-
-	public synchronized void update() {
-		
-	}
-
-	public static void swapBuffers() throws LWJGLException {
-		
-	}
-
-	public synchronized void makeCurrent() throws LWJGLException {
-		
-	}
-
-	public synchronized boolean isCurrent() throws LWJGLException {
-		return false;
-	}
-
-	public static void setSwapInterval(int value) {
-		
-	}
-
-	public synchronized void forceDestroy() throws LWJGLException {
-		
-	}
-
-	public synchronized void destroy() throws LWJGLException {
-		
-	}
-
-	public synchronized void setCLSharingProperties(final PointerBuffer properties) throws LWJGLException {
-		
-	}
-
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/opengl/Display.java b/src/embeddedlibs/org/lwjglx/opengl/Display.java
deleted file mode 100644
index c1f91b4..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/Display.java
+++ /dev/null
@@ -1,502 +0,0 @@
-package org.lwjglx.opengl;
-
-import static org.lwjgl.glfw.GLFW.*;
-import static org.lwjgl.opengl.GL11.GL_FALSE;
-import static org.lwjgl.opengl.GL11.GL_TRUE;
-import static org.lwjgl.system.MemoryUtil.NULL;
-import static org.lwjgl.glfw.Callbacks.*;
-
-import java.nio.ByteBuffer;
-import java.nio.IntBuffer;
-
-import org.lwjgl.BufferUtils;
-import org.lwjgl.opengl.GL;
-import org.lwjgl.opengl.GL11;
-import org.lwjgl.glfw.GLFW;
-import org.lwjgl.glfw.GLFWCharCallback;
-import org.lwjgl.glfw.GLFWCursorPosCallback;
-import org.lwjgl.glfw.GLFWKeyCallback;
-import org.lwjgl.glfw.GLFWMouseButtonCallback;
-import org.lwjgl.glfw.GLFWWindowFocusCallback;
-import org.lwjgl.glfw.GLFWWindowIconifyCallback;
-import org.lwjgl.glfw.GLFWWindowPosCallback;
-import org.lwjgl.glfw.GLFWWindowRefreshCallback;
-import org.lwjgl.glfw.*;
-import org.lwjgl.opengl.GLCapabilities;
-import org.lwjglx.LWJGLException;
-import org.lwjglx.Sys;
-import org.lwjglx.input.Keyboard;
-import org.lwjglx.input.Mouse;
-
-public class Display {
-
-    private static String windowTitle = "Game";
-
-    private static GLCapabilities context;
-
-    private static boolean displayCreated = false;
-    private static boolean displayFocused = false;
-    private static boolean displayVisible = true;
-    private static boolean displayDirty = false;
-    private static boolean displayResizable = false;
-
-    private static DisplayMode mode = new DisplayMode(640, 480);
-    private static DisplayMode desktopDisplayMode = new DisplayMode(640, 480);
-
-    private static int latestEventKey = 0;
-
-    private static int displayX = 0;
-    private static int displayY = 0;
-
-    private static boolean displayResized = false;
-    private static int displayWidth = 0;
-    private static int displayHeight = 0;
-    private static int displayFramebufferWidth = 0;
-    private static int displayFramebufferHeight = 0;
-
-    private static boolean latestResized = false;
-    private static int latestWidth = 0;
-    private static int latestHeight = 0;
-
-    static {
-        Sys.initialize(); // init using dummy sys method
-
-        long monitor = glfwGetPrimaryMonitor();
-        GLFWVidMode vidmode = glfwGetVideoMode(monitor);
-
-        assert vidmode != null;
-        int monitorWidth = vidmode.width();
-        int monitorHeight = vidmode.height();
-        int monitorBitPerPixel = vidmode.redBits() + vidmode.greenBits() + vidmode.blueBits();
-        int monitorRefreshRate = vidmode.refreshRate();
-
-        desktopDisplayMode = new DisplayMode(monitorWidth, monitorHeight, monitorBitPerPixel, monitorRefreshRate);
-    }
-
-    public static void create(PixelFormat pixel_format, Drawable shared_drawable) throws LWJGLException {
-        System.out.println("TODO: Implement Display.create(PixelFormat, Drawable)"); // TODO
-        create();
-    }
-
-    public static void create(PixelFormat pixel_format, ContextAttribs attribs) throws LWJGLException {
-        System.out.println("TODO: Implement Display.create(PixelFormat, ContextAttribs)"); // TODO
-        create();
-    }
-
-    public static void create(PixelFormat pixel_format) throws LWJGLException {
-        System.out.println("TODO: Implement Display.create(PixelFormat)"); // TODO
-        create();
-    }
-
-    public static <xoffset> void create() throws LWJGLException {
-        long monitor = glfwGetPrimaryMonitor();
-        GLFWVidMode vidmode = glfwGetVideoMode(monitor);
-
-        assert vidmode != null;
-        int monitorWidth = vidmode.width();
-        int monitorHeight = vidmode.height();
-        int monitorBitPerPixel = vidmode.redBits() + vidmode.greenBits() + vidmode.blueBits();
-        int monitorRefreshRate = vidmode.refreshRate();
-
-        desktopDisplayMode = new DisplayMode(monitorWidth, monitorHeight, monitorBitPerPixel, monitorRefreshRate);
-
-        glfwDefaultWindowHints();
-        glfwWindowHint(GLFW_VISIBLE, GL_FALSE);
-        glfwWindowHint(GLFW_RESIZABLE, displayResizable ? GL_TRUE : GL_FALSE);
-        glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);
-
-
-        Window.handle = glfwCreateWindow(mode.getWidth(), mode.getHeight(), windowTitle, NULL, NULL);
-        if (Window.handle == 0L)
-            throw new IllegalStateException("Failed to create Display window");
-
-
-        Window.keyCallback = new GLFWKeyCallback() {
-            @Override
-            public void invoke(long window, int key, int scancode, int action, int mods) {
-                latestEventKey = key;
-
-                if (action == GLFW_RELEASE || action == GLFW.GLFW_PRESS) {
-                    Keyboard.addKeyEvent(key, action == GLFW.GLFW_PRESS ? true : false);
-                }
-            }
-        };
-
-        Window.charCallback = new GLFWCharCallback() {
-            @Override
-            public void invoke(long window, int codepoint) {
-                Keyboard.addCharEvent(latestEventKey, (char) codepoint);
-            }
-        };
-
-        Window.cursorPosCallback = new GLFWCursorPosCallback() {
-            @Override
-            public void invoke(long window, double xpos, double ypos) {
-                Mouse.addMoveEvent(xpos, ypos);
-            }
-        };
-
-        Window.mouseButtonCallback = new GLFWMouseButtonCallback() {
-            @Override
-            public void invoke(long window, int button, int action, int mods) {
-                Mouse.addButtonEvent(button, action == GLFW.GLFW_PRESS ? true : false);
-            }
-        };
-
-        Window.scrollCallback = new GLFWScrollCallback() {
-            @Override
-            public void invoke(long l, double v, double v1) {
-                Mouse.addWheelEvent(v, v1);
-            }
-        };
-
-        Window.windowFocusCallback = new GLFWWindowFocusCallback() {
-            @Override
-            public void invoke(long window, boolean focused) {
-                displayFocused = focused;
-            }
-        };
-
-        Window.windowIconifyCallback = new GLFWWindowIconifyCallback() {
-            @Override
-            public void invoke(long window, boolean iconified) {
-                displayVisible = !iconified;
-            }
-        };
-
-        Window.windowSizeCallback = new GLFWWindowSizeCallback() {
-            @Override
-            public void invoke(long window, int width, int height) {
-                latestResized = true;
-                latestWidth = width;
-                latestHeight = height;
-            }
-        };
-
-        Window.windowPosCallback = new GLFWWindowPosCallback() {
-            @Override
-            public void invoke(long window, int xpos, int ypos) {
-                displayX = xpos;
-                displayY = ypos;
-            }
-        };
-
-        Window.windowRefreshCallback = new GLFWWindowRefreshCallback() {
-            @Override
-            public void invoke(long window) {
-                displayDirty = true;
-            }
-        };
-
-        Window.framebufferSizeCallback = new GLFWFramebufferSizeCallback() {
-            @Override
-            public void invoke(long window, int width, int height) {
-                displayFramebufferWidth = width;
-                displayFramebufferHeight = height;
-            }
-        };
-
-
-
-        Window.setCallbacks();
-
-        displayWidth = mode.getWidth();
-        displayHeight = mode.getHeight();
-
-        IntBuffer fbw = BufferUtils.createIntBuffer(1);
-        IntBuffer fbh = BufferUtils.createIntBuffer(1);
-        GLFW.glfwGetFramebufferSize(Window.handle, fbw, fbh);
-        displayFramebufferWidth = fbw.get(0);
-        displayFramebufferHeight = fbh.get(0);
-
-        glfwSetWindowPos(
-                Window.handle,
-                (monitorWidth - mode.getWidth()) / 2,
-                (monitorHeight - mode.getHeight()) / 2
-        );
-
-        displayX = (monitorWidth - mode.getWidth()) / 2;
-        displayY = (monitorHeight - mode.getHeight()) / 2;
-
-        glfwMakeContextCurrent(Window.handle);
-        context = GL.createCapabilities();
-
-        glfwSwapInterval(1);
-        glfwShowWindow(Window.handle);
-
-        displayCreated = true;
-    }
-
-    public static boolean isCreated() {
-        return displayCreated;
-    }
-
-    public static boolean isActive() {
-        return displayFocused;
-    }
-
-    public static boolean isVisible() {
-        return displayVisible;
-    }
-
-    public static GLCapabilities getContext() {
-        return context;
-    }
-
-    public static void setLocation(int new_x, int new_y) {
-        System.out.println("TODO: Implement Display.setLocation(int, int)");
-    }
-
-    public static void setVSyncEnabled(boolean sync) {
-        if (!sync)
-            glfwSwapInterval(0);
-        else
-            glfwSwapInterval(1);
-    }
-
-    public static long getWindow() {
-        return Window.handle;
-    }
-
-    public static void update() {
-        update(true);
-    }
-
-    public static void update(boolean processMessages) {
-        try {
-            swapBuffers();
-            displayDirty = false;
-        } catch (LWJGLException e) {
-            throw new RuntimeException(e);
-        }
-
-        if (processMessages) processMessages();
-    }
-
-    public static void processMessages() {
-        glfwPollEvents();
-        Keyboard.poll();
-        Mouse.poll();
-
-        if (latestResized) {
-            latestResized = false;
-            displayResized = true;
-            displayWidth = latestWidth;
-            displayHeight = latestHeight;
-        } else {
-            displayResized = false;
-        }
-    }
-
-    public static void swapBuffers() throws LWJGLException {
-        glfwSwapBuffers(Window.handle);
-    }
-
-    public static void destroy() {
-        Window.releaseCallbacks();
-        glfwDestroyWindow(Window.handle);
-		
-		/*try {
-			glfwTerminate();
-		} catch (Throwable t) {
-			t.printStackTrace();
-		}*/
-        displayCreated = false;
-    }
-
-    public static void setDisplayMode(DisplayMode dm) throws LWJGLException {
-        mode = dm;
-    }
-
-    public static DisplayMode getDisplayMode() {
-        return mode;
-    }
-
-    public static DisplayMode[] getAvailableDisplayModes() throws LWJGLException {
-        IntBuffer count = BufferUtils.createIntBuffer(1);
-        GLFWVidMode.Buffer modes = GLFW.glfwGetVideoModes(glfwGetPrimaryMonitor());
-
-        DisplayMode[] displayModes = new DisplayMode[count.get(0)];
-
-        for (int i = 0; i < count.get(0); i++) {
-            modes.position(i * GLFWVidMode.SIZEOF);
-
-            int w = modes.width();
-            int h = modes.height();
-            int b = modes.redBits() + modes.greenBits()
-                    + modes.blueBits();
-            int r = modes.refreshRate();
-
-            displayModes[i] = new DisplayMode(w, h, b, r);
-        }
-
-        return displayModes;
-    }
-
-    public static DisplayMode getDesktopDisplayMode() {
-        return desktopDisplayMode;
-    }
-
-    public static boolean wasResized() {
-        return displayResized;
-    }
-
-    public static int getX() {
-        return displayX;
-    }
-
-    public static int getY() {
-        return displayY;
-    }
-
-    public static int getWidth() {
-        return displayWidth;
-    }
-
-    public static int getHeight() {
-        return displayHeight;
-    }
-
-    public static int getFramebufferWidth() {
-        return displayFramebufferWidth;
-    }
-
-    public static int getFramebufferHeight() {
-        return displayFramebufferHeight;
-    }
-
-    public static void setTitle(String title) {
-        windowTitle = title;
-    }
-
-    public static boolean isCloseRequested() {
-        return glfwWindowShouldClose(Window.handle);
-    }
-
-    public static boolean isDirty() {
-        return displayDirty;
-    }
-
-    public static void setInitialBackground(float red, float green, float blue) {
-        // TODO
-        System.out.println("TODO: Implement Display.setInitialBackground(float, float, float)");
-    }
-
-    public static int setIcon(java.nio.ByteBuffer[] icons) {
-        // TODO
-        System.out.println("TODO: Implement Display.setIcon(ByteBuffer[])");
-        return 0;
-    }
-
-    public static void setResizable(boolean resizable) {
-        displayResizable = resizable;
-        // TODO
-    }
-
-    public static boolean isResizable() {
-        return displayResizable;
-    }
-
-    public static void setDisplayModeAndFullscreen(DisplayMode mode) throws LWJGLException {
-        // TODO
-        System.out.println("TODO: Implement Display.setDisplayModeAndFullscreen(DisplayMode)");
-    }
-
-    public static void setFullscreen(boolean fullscreen) throws LWJGLException {
-        // TODO
-    }
-
-    public static boolean isFullscreen() {
-        // TODO
-        return false;
-    }
-
-    public static void setParent(java.awt.Canvas parent) throws LWJGLException {
-        // Do nothing as set parent not supported
-    }
-
-    public static void releaseContext() throws LWJGLException {
-        glfwMakeContextCurrent(0);
-    }
-
-//    public static boolean isCurrent() throws LWJGLException {
-//        return context;
-//    }
-
-    public static void makeCurrent() throws LWJGLException {
-        glfwMakeContextCurrent(Window.handle);
-    }
-
-    public static java.lang.String getAdapter() {
-        // TODO
-        return "GeNotSupportedAdapter";
-    }
-
-    public static java.lang.String getVersion() {
-        // TODO
-        return "1.0 NOT SUPPORTED";
-    }
-
-    /**
-     * An accurate sync method that will attempt to run at a constant frame rate.
-     * It should be called once every frame.
-     *
-     * @param fps - the desired frame rate, in frames per second
-     */
-    public static void sync(int fps) {
-        Sync.sync(fps);
-    }
-
-    public static Drawable getDrawable() {
-        return null;
-    }
-
-    static DisplayImplementation getImplementation() {
-        return null;
-    }
-
-    private static class Window {
-        static long handle;
-
-        static GLFWKeyCallback keyCallback;
-        static GLFWCharCallback charCallback;
-        static GLFWCursorPosCallback cursorPosCallback;
-        static GLFWMouseButtonCallback mouseButtonCallback;
-        static GLFWWindowFocusCallback windowFocusCallback;
-        static GLFWWindowIconifyCallback windowIconifyCallback;
-        static GLFWWindowSizeCallback windowSizeCallback;
-        static GLFWWindowPosCallback windowPosCallback;
-        static GLFWWindowRefreshCallback windowRefreshCallback;
-        static GLFWFramebufferSizeCallback framebufferSizeCallback;
-        static GLFWScrollCallback scrollCallback;
-
-        public static void setCallbacks() {
-            glfwSetKeyCallback(handle, keyCallback);
-            glfwSetCharCallback(handle, charCallback);
-            glfwSetCursorPosCallback(handle, cursorPosCallback);
-            glfwSetMouseButtonCallback(handle, mouseButtonCallback);
-            glfwSetWindowFocusCallback(handle, windowFocusCallback);
-            glfwSetWindowIconifyCallback(handle, windowIconifyCallback);
-            glfwSetWindowSizeCallback(handle, windowSizeCallback);
-            glfwSetWindowPosCallback(handle, windowPosCallback);
-            glfwSetWindowRefreshCallback(handle, windowRefreshCallback);
-            glfwSetFramebufferSizeCallback(handle, framebufferSizeCallback);
-            glfwSetScrollCallback(handle, scrollCallback);
-        }
-
-        public static void releaseCallbacks() {
-            keyCallback.free();
-            charCallback.free();
-            cursorPosCallback.free();
-            mouseButtonCallback.free();
-            windowFocusCallback.free();
-            windowIconifyCallback.free();
-            windowSizeCallback.free();
-            windowPosCallback.free();
-            windowRefreshCallback.free();
-            framebufferSizeCallback.free();
-            scrollCallback.free();;
-        }
-    }
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/opengl/DisplayImplementation.java b/src/embeddedlibs/org/lwjglx/opengl/DisplayImplementation.java
deleted file mode 100644
index 0890cdd..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/DisplayImplementation.java
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-/**
- * This is the Display implementation interface. Display delegates
- * to implementors of this interface. There is one DisplayImplementation
- * for each supported platform.
- * @author elias_naur
- */
-
-import java.nio.ByteBuffer;
-import java.nio.FloatBuffer;
-import java.nio.IntBuffer;
-import java.awt.Canvas;
-
-import org.lwjglx.LWJGLException;
-
-interface DisplayImplementation extends InputImplementation {
-
-	void createWindow(DrawableLWJGL drawable, DisplayMode mode, Canvas parent, int x, int y) throws LWJGLException;
-
-	void destroyWindow();
-
-	void switchDisplayMode(DisplayMode mode) throws LWJGLException;
-
-	/**
-	 * Reset the display mode to whatever it was when LWJGL was initialized.
-	 * Fails silently.
-	 */
-	void resetDisplayMode();
-
-	/**
-	 * Return the length of the gamma ramp arrays. Returns 0 if gamma settings are
-	 * unsupported.
-	 *
-	 * @return the length of each gamma ramp array, or 0 if gamma settings are unsupported.
-	 */
-	int getGammaRampLength();
-
-	/**
-	 * Method to set the gamma ramp.
-	 */
-	void setGammaRamp(FloatBuffer gammaRamp) throws LWJGLException;
-
-	/**
-	 * Get the driver adapter string. This is a unique string describing the actual card's hardware, eg. "Geforce2", "PS2",
-	 * "Radeon9700". If the adapter cannot be determined, this function returns null.
-	 * @return a String
-	 */
-	String getAdapter();
-
-	/**
-	 * Get the driver version. This is a vendor/adapter specific version string. If the version cannot be determined,
-	 * this function returns null.
-	 * @return a String
-	 */
-	String getVersion();
-
-	/**
-	 * Initialize and return the current display mode.
-	 */
-	DisplayMode init() throws LWJGLException;
-
-	/**
-	 * Implementation of setTitle(). This will read the window's title member
-	 * and stash it in the native title of the window.
-	 */
-	void setTitle(String title);
-
-	boolean isCloseRequested();
-
-	boolean isVisible();
-	boolean isActive();
-
-	boolean isDirty();
-
-	/**
-	 * Create the native PeerInfo.
-	 * @throws LWJGLException
-	 */
-	PeerInfo createPeerInfo(PixelFormat pixel_format, ContextAttribs attribs) throws LWJGLException;
-
-//	void destroyPeerInfo();
-
-	/**
-	 * Updates the windows internal state. This must be called at least once per video frame
-	 * to handle window close requests, moves, paints, etc.
-	 */
-	void update();
-
-	void reshape(int x, int y, int width, int height);
-
-	/**
-	 * Method for getting displaymodes
-	 */
-	DisplayMode[] getAvailableDisplayModes() throws LWJGLException;
-
-	/* Pbuffer */
-	int getPbufferCapabilities();
-
-	/**
-	 * Method to test for buffer integrity
-	 */
-	boolean isBufferLost(PeerInfo handle);
-
-	/**
-	 * Method to create a Pbuffer
-	 */
-	PeerInfo createPbuffer(int width, int height, PixelFormat pixel_format, ContextAttribs attribs,
-			IntBuffer pixelFormatCaps,
-			IntBuffer pBufferAttribs) throws LWJGLException;
-
-	void setPbufferAttrib(PeerInfo handle, int attrib, int value);
-
-	void bindTexImageToPbuffer(PeerInfo handle, int buffer);
-
-	void releaseTexImageFromPbuffer(PeerInfo handle, int buffer);
-
-	/**
-	 * Sets one or more icons for the Display.
-	 * <ul>
-	 * <li>On Windows you should supply at least one 16x16 icon and one 32x32.</li>
-	 * <li>Linux (and similar platforms) expect one 32x32 icon.</li>
-	 * <li>Mac OS X should be supplied one 128x128 icon</li>
-	 * </ul>
-	 * The implementation will use the supplied ByteBuffers with image data in RGBA and perform any conversions nescesarry for the specific platform.
-	 *
-	 * @param icons Array of icons in RGBA mode
-	 * @return number of icons used.
-	 */
-	int setIcon(ByteBuffer[] icons);
-
-	/**
-	 * Enable or disable the Display window to be resized.
-	 *
-	 * @param resizable set to true to make the Display window resizable;
-	 * false to disable resizing on the Display window.
-	 */
-	void setResizable(boolean resizable);
-
-	/**
-	 * @return true if the Display window has been resized since this method was last called.
-	 */
-	boolean wasResized();
-
-	/**
-	 * @return this method will return the width of the Display window.
-	 */
-	int getWidth();
-
-	/**
-	 * @return this method will return the height of the Display window.
-	 */
-	int getHeight();
-	
-	/**
-	 * @return this method will return the top-left x position of the Display window.
-	 */
-	int getX();
-
-	/**
-	 * @return this method will return the top-left y position of the Display window.
-	 */
-	int getY();
-	
-	/**
-	 * @return this method will return the pixel scale factor of the Display window useful for high resolution modes.
-	 */
-	float getPixelScaleFactor();
-}
diff --git a/src/embeddedlibs/org/lwjglx/opengl/DisplayMode.java b/src/embeddedlibs/org/lwjglx/opengl/DisplayMode.java
deleted file mode 100644
index a2720da..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/DisplayMode.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-/**
- *
- * This class encapsulates the properties for a given display mode.
- * This class is not instantiable, and is aquired from the <code>Display.
- * getAvailableDisplayModes()</code> method.
- *
- * @author cix_foo <cix_foo@users.sourceforge.net>
- * @version $Revision$
- * $Id$
- */
-
-public final class DisplayMode {
-
-	/** properties of the display mode */
-	private final int width, height, bpp, freq;
-	/** If true, this instance can be used for fullscreen modes */
-	private final boolean fullscreen;
-
-	/**
-	 * Construct a display mode. DisplayModes constructed through the
-	 * public constructor can only be used to specify the dimensions of
-	 * the Display in windowed mode. To get the available DisplayModes for
-	 * fullscreen modes, use Display.getAvailableDisplayModes().
-	 *
-	 * @param width The Display width.
-	 * @param height The Display height.
-	 * @see Display
-	 */
-	public DisplayMode(int width, int height) {
-		this(width, height, 0, 0, false);
-	}
-
-	DisplayMode(int width, int height, int bpp, int freq) {
-		this(width, height, bpp, freq, true);
-	}
-
-	private DisplayMode(int width, int height, int bpp, int freq, boolean fullscreen) {
-		this.width = width;
-		this.height = height;
-		this.bpp = bpp;
-		this.freq = freq;
-		this.fullscreen = fullscreen;
-	}
-
-	/** True if this instance can be used for fullscreen modes */
-	public boolean isFullscreenCapable() {
-		return fullscreen;
-	}
-
-	public int getWidth() {
-		return width;
-	}
-
-	public int getHeight() {
-		return height;
-	}
-
-	public int getBitsPerPixel() {
-		return bpp;
-	}
-
-	public int getFrequency() {
-		return freq;
-	}
-
-	/**
-	 * Tests for <code>DisplayMode</code> equality
-	 *
-	 * @see java.lang.Object#equals(Object)
-	 */
-	public boolean equals(Object obj) {
-		if (obj == null || !(obj instanceof DisplayMode)) {
-			return false;
-		}
-
-		DisplayMode dm = (DisplayMode) obj;
-		return dm.width == width
-			&& dm.height == height
-			&& dm.bpp == bpp
-			&& dm.freq == freq;
-	}
-
-	/**
-	 * Retrieves the hashcode for this object
-	 *
-	 * @see java.lang.Object#hashCode()
-	 */
-	public int hashCode() {
-		return width ^ height ^ freq ^ bpp;
-	}
-
-	/**
-	 * Retrieves a String representation of this <code>DisplayMode</code>
-	 *
-	 * @see java.lang.Object#toString()
-	 */
-	public String toString() {
-		StringBuilder sb = new StringBuilder(32);
-		sb.append(width);
-		sb.append(" x ");
-		sb.append(height);
-		sb.append(" x ");
-		sb.append(bpp);
-		sb.append(" @");
-		sb.append(freq);
-		sb.append("Hz");
-		return sb.toString();
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/opengl/Drawable.java b/src/embeddedlibs/org/lwjglx/opengl/Drawable.java
deleted file mode 100644
index a87ca25..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/Drawable.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-import org.lwjglx.LWJGLException;
-import org.lwjglx.PointerBuffer;
-
-/**
- * The Drawable interface describes an OpenGL drawable with an associated
- * Context.
- *
- * @author elias_naur
- */
-
-public interface Drawable {
-
-	/** Returns true if the Drawable's context is current in the current thread. */
-	boolean isCurrent() throws LWJGLException;
-
-	/**
-	 * Makes the Drawable's context current in the current thread.
-	 *
-	 * @throws LWJGLException
-	 */
-	void makeCurrent() throws LWJGLException;
-
-	/**
-	 * If the Drawable's context is current in the current thread, no context will be current after a call to this method.
-	 *
-	 * @throws LWJGLException
-	 */
-	void releaseContext() throws LWJGLException;
-
-	/** Destroys the Drawable. */
-	void destroy();
-
-	/**
-	 * Sets the appropriate khr_gl_sharing properties in the target <code>PointerBuffer</code>,
-	 * so that if it is used in a <code>clCreateContext(FromType)</code> call, the created CL
-	 * context will be sharing objects with this <code>Drawable</code>'s GL context. After a
-	 * call to this method, the target buffer position will have advanced by 2 to 4 positions,
-	 * depending on the implementation.
-	 *
-	 * @param properties The target properties buffer. It must have at least 4 positions remaining.
-	 */
-	void setCLSharingProperties(PointerBuffer properties) throws LWJGLException;
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/opengl/DrawableGL.java b/src/embeddedlibs/org/lwjglx/opengl/DrawableGL.java
deleted file mode 100644
index e48696e..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/DrawableGL.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Copyright (c) 2002-2011 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-import org.lwjglx.LWJGLException;
-import org.lwjglx.LWJGLUtil;
-import org.lwjglx.PointerBuffer;
-
-import static org.lwjgl.opengl.GL11.*;
-
-/** @author Spasi */
-abstract class DrawableGL implements DrawableLWJGL {
-
-	/** The PixelFormat used to create the drawable. */
-	protected PixelFormat pixel_format;
-
-	/** Handle to the native GL rendering context */
-	protected PeerInfo peer_info;
-
-	/** The OpenGL Context. */
-	protected ContextGL context;
-
-	protected DrawableGL() {
-	}
-
-	public void setPixelFormat(final PixelFormatLWJGL pf) throws LWJGLException {
-		throw new UnsupportedOperationException();
-	}
-
-	public void setPixelFormat(final PixelFormatLWJGL pf, final ContextAttribs attribs) throws LWJGLException {
-		this.pixel_format = (PixelFormat)pf;
-		//this.peer_info = Display.getImplementation().createPeerInfo(pixel_format, attribs);
-	}
-
-	public PixelFormatLWJGL getPixelFormat() {
-		return pixel_format;
-	}
-
-	public ContextGL getContext() {
-		synchronized ( GlobalLock.lock ) {
-			return context;
-		}
-	}
-
-	public ContextGL createSharedContext() throws LWJGLException {
-		synchronized ( GlobalLock.lock ) {
-			//checkDestroyed();
-			//return new ContextGL(peer_info, context.getContextAttribs(), context);
-			return null;
-		}
-	}
-
-	public void checkGLError() {
-		Util.checkGLError();
-	}
-
-	public void setSwapInterval(final int swap_interval) {
-		ContextGL.setSwapInterval(swap_interval);
-	}
-
-	public void swapBuffers() throws LWJGLException {
-		ContextGL.swapBuffers();
-	}
-
-	public void initContext(final float r, final float g, final float b) {
-		// set background clear color
-		glClearColor(r, g, b, 0.0f);
-		// Clear window to avoid the desktop "showing through"
-		glClear(GL_COLOR_BUFFER_BIT);
-	}
-
-	public boolean isCurrent() throws LWJGLException {
-		synchronized ( GlobalLock.lock ) {
-			checkDestroyed();
-			return context.isCurrent();
-		}
-	}
-
-	public void makeCurrent() throws LWJGLException {
-		synchronized ( GlobalLock.lock ) {
-			checkDestroyed();
-			context.makeCurrent();
-		}
-	}
-
-	public void releaseContext() throws LWJGLException {
-		synchronized ( GlobalLock.lock ) {
-			checkDestroyed();
-			if ( context.isCurrent() )
-				context.releaseCurrent();
-		}
-	}
-
-	public void destroy() {
-		synchronized ( GlobalLock.lock ) {
-			if ( context == null )
-				return;
-
-			try {
-				releaseContext();
-
-				context.forceDestroy();
-				context = null;
-
-				if ( peer_info != null ) {
-					peer_info.destroy();
-					peer_info = null;
-				}
-			} catch (LWJGLException e) {
-				LWJGLUtil.log("Exception occurred while destroying Drawable: " + e);
-			}
-		}
-	}
-
-	public void setCLSharingProperties(final PointerBuffer properties) throws LWJGLException {
-		synchronized ( GlobalLock.lock ) {
-			checkDestroyed();
-			context.setCLSharingProperties(properties);
-		}
-	}
-
-	protected final void checkDestroyed() {
-		if ( context == null )
-			throw new IllegalStateException("The Drawable has no context available.");
-	}
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/opengl/DrawableLWJGL.java b/src/embeddedlibs/org/lwjglx/opengl/DrawableLWJGL.java
deleted file mode 100644
index 1f70b4f..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/DrawableLWJGL.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (c) 2002-2011 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-import org.lwjglx.LWJGLException;
-
-/**
- * [INTERNAL USE ONLY]
- *
- * @author Spasi
- */
-interface DrawableLWJGL extends Drawable {
-
-	void setPixelFormat(PixelFormatLWJGL pf) throws LWJGLException;
-
-	void setPixelFormat(PixelFormatLWJGL pf, ContextAttribs attribs) throws LWJGLException;
-
-	PixelFormatLWJGL getPixelFormat();
-
-	/**
-	 * [INTERNAL USE ONLY] Returns the Drawable's Context.
-	 *
-	 * @return the Drawable's Context
-	 */
-	Context getContext();
-
-	/**
-	 * [INTERNAL USE ONLY] Creates a new Context that is shared with the Drawable's Context.
-	 *
-	 * @return a Context shared with the Drawable's Context.
-	 */
-	Context createSharedContext() throws LWJGLException;
-
-	void checkGLError();
-
-	void setSwapInterval(int swap_interval);
-
-	void swapBuffers() throws LWJGLException;
-
-	void initContext(final float r, final float g, final float b);
-
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/opengl/GL15x.java b/src/embeddedlibs/org/lwjglx/opengl/GL15x.java
deleted file mode 100644
index 8a01663..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/GL15x.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package org.lwjglx.opengl;
-
-import java.nio.ByteBuffer;
-
-import org.lwjgl.BufferUtils;
-import org.lwjgl.PointerBuffer;
-import org.lwjgl.opengl.GL15;
-
-//public class GL15x {
-//
-//	public static ByteBuffer glGetBufferPointer(int target, int pname) {
-//		int size = GL15.glGetBufferParameteri(target, GL15.GL_BUFFER_SIZE);
-//
-//		PointerBuffer pb = BufferUtils.createPointerBuffer(1);
-//		GL15.glGetBufferPointer(target, pname, pb);
-//
-//		return pb.getByteBuffer(0, size);
-//	}
-//
-//}
diff --git a/src/embeddedlibs/org/lwjglx/opengl/GL20x.java b/src/embeddedlibs/org/lwjglx/opengl/GL20x.java
deleted file mode 100644
index 9104038..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/GL20x.java
+++ /dev/null
@@ -1,63 +0,0 @@
-//package org.lwjglx.opengl;
-//
-//import java.nio.ByteBuffer;
-//import java.nio.IntBuffer;
-//import java.nio.ShortBuffer;
-//
-//import org.lwjgl.BufferUtils;
-//import org.lwjgl.PointerBuffer;
-//import org.lwjgl.opengl.GL11;
-//import org.lwjgl.opengl.GL20;
-//import org.lwjgl.system.MemoryUtil;
-//
-//public class GL20x {
-//
-//	public static void glVertexAttribPointer(int index, int size,
-//											 boolean unsigned, boolean normalized,
-//											 int stride, ByteBuffer buffer) {
-//		int type = unsigned ? GL11.GL_UNSIGNED_BYTE : GL11.GL_BYTE;
-//		GL20.glVertexAttribPointer(index, size, type, normalized, stride, buffer);
-//	}
-//
-//	public static void glVertexAttribPointer(int index, int size,
-//											 boolean unsigned, boolean normalized,
-//											 int stride, ShortBuffer buffer) {
-//		int type = unsigned ? GL11.GL_UNSIGNED_SHORT : GL11.GL_SHORT;
-//		GL20.nglVertexAttribPointer(index, size, type, normalized, stride, MemoryUtil.memAddress(buffer));
-//	}
-//
-//	public static void glVertexAttribPointer(int index, int size,
-//			 								 boolean unsigned, boolean normalized,
-//			 								 int stride, IntBuffer buffer) {
-//		int type = unsigned ? GL11.GL_UNSIGNED_INT : GL11.GL_INT;
-//		GL20.nglVertexAttribPointer(index, size, type, normalized, stride, MemoryUtil.memAddress(buffer));
-//}
-//
-//	public static String glGetActiveAttrib(int program, int index, int maxLength,
-//            							   IntBuffer sizeType) {
-//		//TODO check if correct
-//		IntBuffer type = BufferUtils.createIntBuffer(1);
-//		String s = GL20.glGetActiveAttrib(program, index, maxLength, sizeType, type);
-//		sizeType.put(type.get(0));
-//		return s;
-//	}
-//
-//	public static String glGetActiveUniform(int program, int index, int maxLength,
-//													  IntBuffer sizeType) {
-//		//TODO if correct
-//		IntBuffer type = BufferUtils.createIntBuffer(1);
-//		String s = GL20.glGetActiveUniform(program, index, maxLength, sizeType, type);
-//		sizeType.put(type.get(0));
-//		return s;
-//	}
-//
-//	public static void glShaderSource(int shader, java.nio.ByteBuffer string) {
-//		PointerBuffer strings = BufferUtils.createPointerBuffer(1);
-//		IntBuffer lengths = BufferUtils.createIntBuffer(1);
-//
-//		strings.put(0, string);
-//		lengths.put(0, new String(string.array()).length());//source.length());
-//		org.lwjgl.opengl.GL20.glShaderSource(shader, strings, lengths);
-//	}
-//
-//}
diff --git a/src/embeddedlibs/org/lwjglx/opengl/GLContext.java b/src/embeddedlibs/org/lwjglx/opengl/GLContext.java
deleted file mode 100644
index cec6e19..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/GLContext.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package org.lwjglx.opengl;
-
-
-public class GLContext {
-	
-	private static ContextCapabilities contextCapabilities = new ContextCapabilities();
-	
-	public static ContextCapabilities getCapabilities() {
-		return contextCapabilities;
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/opengl/GLSync.java b/src/embeddedlibs/org/lwjglx/opengl/GLSync.java
deleted file mode 100644
index 17f4f14..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/GLSync.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-import org.lwjglx.PointerWrapperAbstract;
-
-/**
- * This class is a wrapper around a GLsync pointer.
- *
- * @author spasi <spasi@users.sourceforge.net>
- */
-public final class GLSync extends PointerWrapperAbstract {
-
-	GLSync(final long sync) {
-		super(sync);
-	}
-
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/opengl/GlobalLock.java b/src/embeddedlibs/org/lwjglx/opengl/GlobalLock.java
deleted file mode 100644
index 2bb430d..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/GlobalLock.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-/**
- * This class contains the global lock that LWJGL will use to
- * synchronize access to Display.
- */
-final class GlobalLock {
-	static final Object lock = new Object();
-}
diff --git a/src/embeddedlibs/org/lwjglx/opengl/InputImplementation.java b/src/embeddedlibs/org/lwjglx/opengl/InputImplementation.java
deleted file mode 100644
index aebd147..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/InputImplementation.java
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-/**
- * This is the input implementation interface. Mouse and Keyboard delegates
- * to implementors of this interface. There is one InputImplementation
- * for each supported platform.
- * @author elias_naur
- */
-
-import java.nio.ByteBuffer;
-import java.nio.IntBuffer;
-
-import org.lwjglx.LWJGLException;
-
-public interface InputImplementation {
-	/*
-	 * Mouse methods
-	 */
-	/** Query of wheel support */
-	boolean hasWheel();
-
-	/** Query of button count */
-	int getButtonCount();
-
-	/**
-	 * Method to create the mouse.
-	 */
-	void createMouse() throws LWJGLException;
-
-	/**
-	 * Method the destroy the mouse
-	 */
-	void destroyMouse();
-
-	/**
-	 * Method to poll the mouse
-	 */
-	void pollMouse(IntBuffer coord_buffer, ByteBuffer buttons);
-
-	/**
-	 * Method to read the keyboard buffer
-	 */
-	void readMouse(ByteBuffer buffer);
-
-	void grabMouse(boolean grab);
-
-	/**
-	 * Function to determine native cursor support
-	 */
-	int getNativeCursorCapabilities();
-
-	/** Method to set the native cursor position */
-	void setCursorPosition(int x, int y);
-	
-	/** Method to set the native cursor */
-	void setNativeCursor(Object handle) throws LWJGLException;
-
-	/** Method returning the minimum cursor size */
-	int getMinCursorSize();
-
-	/** Method returning the maximum cursor size */
-	int getMaxCursorSize();
-
-	/*
-	 * Keyboard methods
-	 */
-
-	/**
-	 * Method to create the keyboard
-	 */
-	void createKeyboard() throws LWJGLException;
-
-	/**
-	 * Method to destroy the keyboard
-	 */
-	void destroyKeyboard();
-
-	/**
-	 * Method to poll the keyboard.
-	 *
-	 * @param keyDownBuffer the address of a 256-byte buffer to place
-	 * key states in.
-	 */
-	void pollKeyboard(ByteBuffer keyDownBuffer);
-
-	/**
-	 * Method to read the keyboard buffer
-	 */
-	void readKeyboard(ByteBuffer buffer);
-
-//	int isStateKeySet(int key);
-
-	/** Native cursor handles */
-	Object createCursor(int width, int height, int xHotspot, int yHotspot, int numImages, IntBuffer images, IntBuffer delays) throws LWJGLException;
-
-	void destroyCursor(Object cursor_handle);
-
-	int getWidth();
-
-	int getHeight();
-
-        boolean isInsideWindow();
-}
diff --git a/src/embeddedlibs/org/lwjglx/opengl/OpenGLException.java b/src/embeddedlibs/org/lwjglx/opengl/OpenGLException.java
deleted file mode 100644
index eeb8671..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/OpenGLException.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-/**
- * <p/>
- * Thrown by the debug build library of the LWJGL if any OpenGL operation causes an error.
- *
- * @author cix_foo <cix_foo@users.sourceforge.net>
- * @version $Revision$
- * $Id$
- */
-public class OpenGLException extends RuntimeException {
-
-	private static final long serialVersionUID = 1L;
-
-	/** Constructor for OpenGLException. */
-	public OpenGLException(int gl_error_code) {
-		this(createErrorMessage(gl_error_code));
-	}
-
-	private static String createErrorMessage(int gl_error_code) {
-		String error_string = Util.translateGLErrorString(gl_error_code);
-		return error_string + " (" + gl_error_code + ")";
-	}
-
-	/** Constructor for OpenGLException. */
-	public OpenGLException() {
-		super();
-	}
-
-	/**
-	 * Constructor for OpenGLException.
-	 *
-	 * @param message
-	 */
-	public OpenGLException(String message) {
-		super(message);
-	}
-
-	/**
-	 * Constructor for OpenGLException.
-	 *
-	 * @param message
-	 * @param cause
-	 */
-	public OpenGLException(String message, Throwable cause) {
-		super(message, cause);
-	}
-
-	/**
-	 * Constructor for OpenGLException.
-	 *
-	 * @param cause
-	 */
-	public OpenGLException(Throwable cause) {
-		super(cause);
-	}
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/opengl/Pbuffer.java b/src/embeddedlibs/org/lwjglx/opengl/Pbuffer.java
deleted file mode 100644
index 20b4ecb..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/Pbuffer.java
+++ /dev/null
@@ -1,320 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-import java.nio.IntBuffer;
-
-import org.lwjglx.BufferUtils;
-import org.lwjglx.LWJGLException;
-import org.lwjglx.Sys;
-
-/**
- * <p/>
- * Pbuffer encapsulates an OpenGL pbuffer.
- * <p/>
- *
- * This class is thread-safe.
- *
- * @author elias_naur <elias_naur@users.sourceforge.net>
- * @version $Revision$
- * $Id$
- */
-public final class Pbuffer extends DrawableGL {
-	/**
-	 * Indicates that Pbuffers can be created.
-	 */
-	public static final int PBUFFER_SUPPORTED = 0;// mark as not supported 1 << 0;
-
-	/**
-	 * Indicates that Pbuffers can be used as render-textures.
-	 */
-	public static final int RENDER_TEXTURE_SUPPORTED = 1 << 1;
-
-	/**
-	 * Indicates that Pbuffers can be used as non-power-of-two render-textures.
-	 */
-	public static final int RENDER_TEXTURE_RECTANGLE_SUPPORTED = 1 << 2;
-
-	/**
-	 * Indicates that Pbuffers can be used as depth render-textures.
-	 */
-	public static final int RENDER_DEPTH_TEXTURE_SUPPORTED = 1 << 3;
-
-	/**
-	 * The render-to-texture mipmap level attribute.
-	 */
-	public static final int MIPMAP_LEVEL = RenderTexture.WGL_MIPMAP_LEVEL_ARB;
-
-	/**
-	 * The render-to-texture cube map face attribute.
-	 */
-	public static final int CUBE_MAP_FACE = RenderTexture.WGL_CUBE_MAP_FACE_ARB;
-
-	/**
-	 * The render-to-texture cube map positive X face value.
-	 */
-	public static final int TEXTURE_CUBE_MAP_POSITIVE_X = RenderTexture.WGL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB;
-
-	/**
-	 * The render-to-texture cube map negative X face value.
-	 */
-	public static final int TEXTURE_CUBE_MAP_NEGATIVE_X = RenderTexture.WGL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB;
-
-	/**
-	 * The render-to-texture cube map positive Y face value.
-	 */
-	public static final int TEXTURE_CUBE_MAP_POSITIVE_Y = RenderTexture.WGL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB;
-
-	/**
-	 * The render-to-texture cube map negative Y face value.
-	 */
-	public static final int TEXTURE_CUBE_MAP_NEGATIVE_Y = RenderTexture.WGL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB;
-
-	/**
-	 * The render-to-texture cube map positive Z face value.
-	 */
-	public static final int TEXTURE_CUBE_MAP_POSITIVE_Z = RenderTexture.WGL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB;
-
-	/**
-	 * The render-to-texture cube map negative Z face value.
-	 */
-	public static final int TEXTURE_CUBE_MAP_NEGATIVE_Z = RenderTexture.WGL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB;
-
-	/**
-	 * The Pbuffer front left buffer.
-	 */
-	public static final int FRONT_LEFT_BUFFER = RenderTexture.WGL_FRONT_LEFT_ARB;
-
-	/**
-	 * The Pbuffer front right buffer.
-	 */
-	public static final int FRONT_RIGHT_BUFFER = RenderTexture.WGL_FRONT_RIGHT_ARB;
-
-	/**
-	 * The Pbuffer back left buffer.
-	 */
-	public static final int BACK_LEFT_BUFFER = RenderTexture.WGL_BACK_LEFT_ARB;
-
-	/**
-	 * The Pbuffer back right buffer.
-	 */
-	public static final int BACK_RIGHT_BUFFER = RenderTexture.WGL_BACK_RIGHT_ARB;
-
-	/**
-	 * The Pbuffer depth buffer.
-	 */
-	public static final int DEPTH_BUFFER = RenderTexture.WGL_DEPTH_COMPONENT_NV;
-
-	/**
-	 * Width
-	 */
-	private final int width;
-
-	/**
-	 * Height
-	 */
-	private final int height;
-
-	static {
-		Sys.initialize();
-	}
-
-	/**
-	 * Create an instance of a Pbuffer with a unique OpenGL context. The buffer is single-buffered.
-	 * <p/>
-	 * NOTE: The Pbuffer will have its own context that shares display lists and textures with <code>shared_context</code>,
-	 * or, if <code>shared_context</code> is <code>null</code>, the Display context if it is created. The Pbuffer
-	 * will have its own OpenGL state. Therefore, state changes to a pbuffer will not be seen in the window context and vice versa.
-	 * <p/>
-	 *
-	 * @param width         Pbuffer width
-	 * @param height        Pbuffer height
-	 * @param pixel_format  Minimum Pbuffer context properties
-	 * @param shared_drawable If non-null the Pbuffer will share display lists and textures with it. Otherwise, the Pbuffer will share
-	 * 						 with the Display context (if created).
-	 */
-	public Pbuffer(int width, int height, PixelFormat pixel_format, Drawable shared_drawable) throws LWJGLException {
-		this(width, height, pixel_format, null, shared_drawable);
-	}
-
-	/**
-	 * Create an instance of a Pbuffer with a unique OpenGL context. The buffer is single-buffered.
-	 * <p/>
-	 * NOTE: The Pbuffer will have its own context that shares display lists and textures with <code>shared_context</code>,
-	 * or, if <code>shared_context</code> is <code>null</code>, the Display context if it is created. The Pbuffer
-	 * will have its own OpenGL state. Therefore, state changes to a pbuffer will not be seen in the window context and vice versa.
-	 * <p/>
-	 * The renderTexture parameter defines the necessary state for enabling render-to-texture. When this parameter is null,
-	 * render-to-texture is not available. Before using render-to-texture, the Pbuffer capabilities must be queried to ensure that
-	 * it is supported. Currently only windows platform can support this feature, so it is recommended that EXT_framebuffer_object
-	 * or similar is used if available, for maximum portability.
-	 * <p/>
-	 *
-	 * @param width         Pbuffer width
-	 * @param height        Pbuffer height
-	 * @param pixel_format  Minimum Pbuffer context properties
-	 * @param renderTexture
-	 * @param shared_drawable If non-null the Pbuffer will share display lists and textures with it. Otherwise, the Pbuffer will share
-	 * 						 with the Display context (if created).
-	 */
-	public Pbuffer(int width, int height, PixelFormat pixel_format, RenderTexture renderTexture, Drawable shared_drawable) throws LWJGLException {
-		this(width, height, pixel_format, renderTexture, shared_drawable, null);
-	}
-
-	/**
-	 * Create an instance of a Pbuffer with a unique OpenGL context. The buffer is single-buffered.
-	 * <p/>
-	 * NOTE: The Pbuffer will have its own context that shares display lists and textures with <code>shared_context</code>,
-	 * or, if <code>shared_context</code> is <code>null</code>, the Display context if it is created. The Pbuffer
-	 * will have its own OpenGL state. Therefore, state changes to a pbuffer will not be seen in the window context and vice versa.
-	 * <p/>
-	 * The renderTexture parameter defines the necessary state for enabling render-to-texture. When this parameter is null,
-	 * render-to-texture is not available. Before using render-to-texture, the Pbuffer capabilities must be queried to ensure that
-	 * it is supported. Currently only windows platform can support this feature, so it is recommended that EXT_framebuffer_object
-	 * or similar is used if available, for maximum portability.
-	 * <p/>
-	 *
-	 * @param width         Pbuffer width
-	 * @param height        Pbuffer height
-	 * @param pixel_format  Minimum Pbuffer context properties
-	 * @param renderTexture
-	 * @param shared_drawable If non-null the Pbuffer will share display lists and textures with it. Otherwise, the Pbuffer will share
-	 * 						 with the Display context (if created).
-	 * @param attribs      The ContextAttribs to use when creating the context. (optional, may be null)
-	 */
-	public Pbuffer(int width, int height, PixelFormat pixel_format, RenderTexture renderTexture, Drawable shared_drawable, ContextAttribs attribs) throws LWJGLException {
-		if (pixel_format == null)
-			throw new NullPointerException("Pixel format must be non-null");
-		this.width = width;
-		this.height = height;
-		this.peer_info = createPbuffer(width, height, pixel_format, attribs, renderTexture);
-		Context shared_context = null;
-		if ( shared_drawable == null )
-			shared_drawable = Display.getDrawable(); // May be null
-		if (shared_drawable != null)
-			shared_context = ((DrawableLWJGL)shared_drawable).getContext();
-		//this.context = new ContextGL(peer_info, attribs, (ContextGL)shared_context);
-	}
-
-	private static PeerInfo createPbuffer(int width, int height, PixelFormat pixel_format, ContextAttribs attribs, RenderTexture renderTexture) throws LWJGLException {
-		if ( renderTexture == null ) {
-			// Though null is a perfectly valid argument, Matrox Parhelia drivers expect
-			// a 0 terminated list, or else they crash. Supplying NULL or 0, should
-			// cause the drivers to use default settings
-			IntBuffer defaultAttribs = BufferUtils.createIntBuffer(1);
-			return Display.getImplementation().createPbuffer(width, height, pixel_format, attribs, null, defaultAttribs);
-		} else
-			return Display.getImplementation().createPbuffer(width, height, pixel_format, attribs,
-					renderTexture.pixelFormatCaps,
-					renderTexture.pBufferAttribs);
-	}
-
-	/**
-	 * Method to test for validity of the buffer. If this function returns true, the buffer contents is lost. The buffer can still
-	 * be used, but the results are undefined. The application is expected to release the buffer if needed, destroy it and recreate
-	 * a new buffer.
-	 *
-	 * @return true if the buffer is lost and destroyed, false if the buffer is valid.
-	 */
-	public synchronized boolean isBufferLost() {
-		checkDestroyed();
-		return Display.getImplementation().isBufferLost(peer_info);
-	}
-
-	/**
-	 * Gets the Pbuffer capabilities.
-	 *
-	 * @return a bitmask of Pbuffer capabilities.
-	 */
-	public static int getCapabilities() {
-		return Display.getImplementation().getPbufferCapabilities();
-	}
-
-	// -----------------------------------------------------------------------------------------
-	// ------------------------------- Render-to-Texture Methods -------------------------------
-	// -----------------------------------------------------------------------------------------
-
-	/**
-	 * Sets a render-to-texture attribute.
-	 * <p/>
-	 * The attrib parameter can be one of MIPMAP_LEVEL and CUBE_MAP_FACE. When the attrib parameter is CUBE_MAP_FACE then the value
-	 * parameter can be on of the following:
-	 * <p/>
-	 * TEXTURE_CUBE_MAP_POSITIVE_X TEXTURE_CUBE_MAP_NEGATIVE_X TEXTURE_CUBE_MAP_POSITIVE_Y TEXTURE_CUBE_MAP_NEGATIVE_Y
-	 * TEXTURE_CUBE_MAP_POSITIVE_Z TEXTURE_CUBE_MAP_NEGATIVE_Z
-	 *
-	 * @param attrib
-	 * @param value
-	 */
-	public synchronized void setAttrib(int attrib, int value) {
-		checkDestroyed();
-		Display.getImplementation().setPbufferAttrib(peer_info, attrib, value);
-	}
-
-	/**
-	 * Binds the currently bound texture to the buffer specified. The buffer can be one of the following:
-	 * <p/>
-	 * FRONT_LEFT_BUFFER FRONT_RIGHT_BUFFER BACK_LEFT_BUFFER BACK_RIGHT_BUFFER DEPTH_BUFFER
-	 *
-	 * @param buffer
-	 */
-	public synchronized void bindTexImage(int buffer) {
-		checkDestroyed();
-		Display.getImplementation().bindTexImageToPbuffer(peer_info, buffer);
-	}
-
-	/**
-	 * Releases the currently bound texture from the buffer specified.
-	 *
-	 * @param buffer
-	 */
-	public synchronized void releaseTexImage(int buffer) {
-		checkDestroyed();
-		Display.getImplementation().releaseTexImageFromPbuffer(peer_info, buffer);
-	}
-
-	/**
-	 * @return Returns the height.
-	 */
-	public synchronized int getHeight() {
-		checkDestroyed();
-		return height;
-	}
-
-	/**
-	 * @return Returns the width.
-	 */
-	public synchronized int getWidth() {
-		checkDestroyed();
-		return width;
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/opengl/PeerInfo.java b/src/embeddedlibs/org/lwjglx/opengl/PeerInfo.java
deleted file mode 100644
index 91c55ff..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/PeerInfo.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-import java.nio.ByteBuffer;
-
-import org.lwjglx.LWJGLException;
-import org.lwjglx.LWJGLUtil;
-
-/**
- *
- * @author elias_naur <elias_naur@users.sourceforge.net>
- * @version $Revision$
- * $Id$
- */
-abstract class PeerInfo {
-	private final ByteBuffer handle;
-	private Thread locking_thread; // Thread that has locked this PeerInfo
-	private int lock_count;
-
-	protected PeerInfo(ByteBuffer handle) {
-		this.handle = handle;
-	}
-
-	private void lockAndInitHandle() throws LWJGLException {
-		doLockAndInitHandle();
-	}
-
-	public final synchronized void unlock() throws LWJGLException {
-		if (lock_count <= 0)
-			throw new IllegalStateException("PeerInfo not locked!");
-		if (Thread.currentThread() != locking_thread)
-			throw new IllegalStateException("PeerInfo already locked by " + locking_thread);
-		lock_count--;
-		if (lock_count == 0) {
-			doUnlock();
-			locking_thread = null;
-			notify();
-		}
-	}
-
-	protected abstract void doLockAndInitHandle() throws LWJGLException;
-	protected abstract void doUnlock() throws LWJGLException;
-
-	public final synchronized ByteBuffer lockAndGetHandle() throws LWJGLException {
-		Thread this_thread = Thread.currentThread();
-		while (locking_thread != null && locking_thread != this_thread) {
-			try {
-				wait();
-			} catch (InterruptedException e) {
-				LWJGLUtil.log("Interrupted while waiting for PeerInfo lock: " + e);
-			}
-		}
-		if (lock_count == 0) {
-			locking_thread = this_thread;
-			doLockAndInitHandle();
-		}
-		lock_count++;
-		return getHandle();
-	}
-
-	protected final ByteBuffer getHandle() {
-		return handle;
-	}
-
-	public void destroy() {
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/opengl/PixelFormat.java b/src/embeddedlibs/org/lwjglx/opengl/PixelFormat.java
deleted file mode 100644
index 64d12ff..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/PixelFormat.java
+++ /dev/null
@@ -1,424 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-/**
- * This class describes pixel format properties for an OpenGL context. Instances
- * of this class is used as arguments to Display.create(), Pbuffer.create() and
- * AWTGLCanvas, to indicate minimum required properties.
- * <p/>
- * Instants of this class are immutable. An example of the expected way to set
- * the PixelFormat property values is the following:
- * <code>PixelFormat pf = new PixelFormat().withDepthBits(24).withSamples(4).withSRGB(true);</code>
- * <p/>
- * WARNING: Some pixel formats are known to cause troubles on certain buggy drivers.
- * Example: Under Windows, specifying samples != 0 will enable the ARB
- * pixel format selection path, which could trigger a crash.
- *
- * @author elias_naur@sourceforge.net
- * @version $Revision$
- */
-public final class PixelFormat implements PixelFormatLWJGL {
-
-	/**
-	 * The number of bits per pixel, exluding alpha.
-	 * This parameter is ignored in Display.create().
-	 */
-	private int bpp;
-	/** The number of alpha bits. */
-	private int alpha;
-	/** The number of depth buffer bits */
-	private int depth;
-	/** The number of stencil bits */
-	private int stencil;
-	/**
-	 * The number of samples to use in anti-aliasing.
-	 * 0 means that anti-aliasing is disabled.
-	 */
-	private int samples;
-	/**
-	 * The number of COLOR_SAMPLES_NV to use for Coverage Sample Anti-aliasing (CSAA).
-	 * When this number is greater than 0, the {@code samples} property will be treated
-	 * as if it were the COVERAGE_SAMPLES_NV property.
-	 * <p/>
-	 * This property is currently a no-op for the MacOS implementation.
-	 */
-	private int colorSamples;
-	/** The number of auxiliary buffers */
-	private int num_aux_buffers;
-	/** The number of bits per pixel in the accumulation buffer */
-	private int accum_bpp;
-	/** The number of alpha bits in the accumulation buffer */
-	private int accum_alpha;
-	/** Whether this format requires a stereo buffer */
-	private boolean stereo;
-	/** Whether this format specifies a floating point format */
-	private boolean floating_point;
-	/**
-	 * Whether this format specifies a packed floating point format (32 bit unsigned - R11F_G11F_B10F)
-	 * This property is currently a no-op for the MacOS implementation.
-	 */
-	private boolean floating_point_packed;
-	/**
-	 * Whether this format specifies an sRGB format
-	 * This property is currently a no-op for the MacOS implementation.
-	 */
-	private boolean sRGB;
-
-	/**
-	 * Default pixel format is minimum 8 bits depth, and no alpha
-	 * nor stencil requirements.
-	 */
-	public PixelFormat() {
-		this(0, 8, 0);
-	}
-
-	public PixelFormat(int alpha, int depth, int stencil) {
-		this(alpha, depth, stencil, 0);
-	}
-
-	public PixelFormat(int alpha, int depth, int stencil, int samples) {
-		this(0, alpha, depth, stencil, samples);
-	}
-
-	public PixelFormat(int bpp, int alpha, int depth, int stencil, int samples) {
-		this(bpp, alpha, depth, stencil, samples, 0, 0, 0, false);
-	}
-
-	public PixelFormat(int bpp, int alpha, int depth, int stencil, int samples, int num_aux_buffers, int accum_bpp, int accum_alpha, boolean stereo) {
-		this(bpp, alpha, depth, stencil, samples, num_aux_buffers, accum_bpp, accum_alpha, stereo, false);
-	}
-
-	public PixelFormat(int bpp, int alpha, int depth, int stencil, int samples, int num_aux_buffers, int accum_bpp, int accum_alpha, boolean stereo, boolean floating_point) {
-		this.bpp = bpp;
-		this.alpha = alpha;
-		this.depth = depth;
-		this.stencil = stencil;
-
-		this.samples = samples;
-
-		this.num_aux_buffers = num_aux_buffers;
-
-		this.accum_bpp = accum_bpp;
-		this.accum_alpha = accum_alpha;
-
-		this.stereo = stereo;
-
-		this.floating_point = floating_point;
-		this.floating_point_packed = false;
-		this.sRGB = false;
-	}
-
-	private PixelFormat(final PixelFormat pf) {
-		this.bpp = pf.bpp;
-		this.alpha = pf.alpha;
-		this.depth = pf.depth;
-		this.stencil = pf.stencil;
-
-		this.samples = pf.samples;
-		this.colorSamples = pf.colorSamples;
-
-		this.num_aux_buffers = pf.num_aux_buffers;
-
-		this.accum_bpp = pf.accum_bpp;
-		this.accum_alpha = pf.accum_alpha;
-
-		this.stereo = pf.stereo;
-
-		this.floating_point = pf.floating_point;
-		this.floating_point_packed = pf.floating_point_packed;
-		this.sRGB = pf.sRGB;
-	}
-
-	public int getBitsPerPixel() {
-		return bpp;
-	}
-
-	/**
-	 * Returns a new PixelFormat object with the same properties as this PixelFormat and the new bits per pixel value.
-	 *
-	 * @param bpp the new bits per pixel value.
-	 *
-	 * @return the new PixelFormat
-	 */
-	public PixelFormat withBitsPerPixel(final int bpp) {
-		if ( bpp < 0 )
-			throw new IllegalArgumentException("Invalid number of bits per pixel specified: " + bpp);
-
-		final PixelFormat pf = new PixelFormat(this);
-		pf.bpp = bpp;
-		return pf;
-	}
-
-	public int getAlphaBits() {
-		return alpha;
-	}
-
-	/**
-	 * Returns a new PixelFormat object with the same properties as this PixelFormat and the new alpha bits value.
-	 *
-	 * @param alpha the new alpha bits value.
-	 *
-	 * @return the new PixelFormat
-	 */
-	public PixelFormat withAlphaBits(final int alpha) {
-		if ( alpha < 0 )
-			throw new IllegalArgumentException("Invalid number of alpha bits specified: " + alpha);
-
-		final PixelFormat pf = new PixelFormat(this);
-		pf.alpha = alpha;
-		return pf;
-	}
-
-	public int getDepthBits() {
-		return depth;
-	}
-
-	/**
-	 * Returns a new PixelFormat object with the same properties as this PixelFormat and the new depth bits value.
-	 *
-	 * @param depth the new depth bits value.
-	 *
-	 * @return the new PixelFormat
-	 */
-	public PixelFormat withDepthBits(final int depth) {
-		if ( depth < 0 )
-			throw new IllegalArgumentException("Invalid number of depth bits specified: " + depth);
-
-		final PixelFormat pf = new PixelFormat(this);
-		pf.depth = depth;
-		return pf;
-	}
-
-	public int getStencilBits() {
-		return stencil;
-	}
-
-	/**
-	 * Returns a new PixelFormat object with the same properties as this PixelFormat and the new stencil bits value.
-	 *
-	 * @param stencil the new stencil bits value.
-	 *
-	 * @return the new PixelFormat
-	 */
-	public PixelFormat withStencilBits(final int stencil) {
-		if ( stencil < 0 )
-			throw new IllegalArgumentException("Invalid number of stencil bits specified: " + stencil);
-
-		final PixelFormat pf = new PixelFormat(this);
-		pf.stencil = stencil;
-		return pf;
-	}
-
-	public int getSamples() {
-		return samples;
-	}
-
-	/**
-	 * Returns a new PixelFormat object with the same properties as this PixelFormat and the new samples value.
-	 *
-	 * @param samples the new samples value.
-	 *
-	 * @return the new PixelFormat
-	 */
-	public PixelFormat withSamples(final int samples) {
-		if ( samples < 0 )
-			throw new IllegalArgumentException("Invalid number of samples specified: " + samples);
-
-		final PixelFormat pf = new PixelFormat(this);
-		pf.samples = samples;
-		return pf;
-	}
-
-	/**
-	 * Returns a new PixelFormat object with the same properties as this PixelFormat and the new color samples values.
-	 * A value greater than 0 is valid only if the {@code samples} property is also greater than 0. Additionally, the
-	 * color samples value needs to be lower than or equal to the {@code samples} property.
-	 *
-	 * @param colorSamples    the new color samples value.
-	 *
-	 * @return the new PixelFormat
-	 */
-	public PixelFormat withCoverageSamples(final int colorSamples) {
-		return withCoverageSamples(colorSamples, samples);
-	}
-
-	/**
-	 * Returns a new PixelFormat object with the same properties as this PixelFormat and the new color samples
-	 * and coverage samples values.
-	 *
-	 * @param colorSamples    the new color samples value. This value must be lower than or equal to the coverage samples value.
-	 * @param coverageSamples the new coverage samples value.
-	 *
-	 * @return the new PixelFormat
-	 */
-	public PixelFormat withCoverageSamples(final int colorSamples, final int coverageSamples) {
-		if ( coverageSamples < 0 || colorSamples < 0 || (coverageSamples == 0 && 0 < colorSamples) || coverageSamples < colorSamples  )
-			throw new IllegalArgumentException("Invalid number of coverage samples specified: " + coverageSamples + " - " + colorSamples);
-
-		final PixelFormat pf = new PixelFormat(this);
-		pf.samples = coverageSamples;
-		pf.colorSamples = colorSamples;
-		return pf;
-	}
-
-	public int getAuxBuffers() {
-		return num_aux_buffers;
-	}
-
-	/**
-	 * Returns a new PixelFormat object with the same properties as this PixelFormat and the new auxiliary buffers value.
-	 *
-	 * @param num_aux_buffers the new auxiliary buffers value.
-	 *
-	 * @return the new PixelFormat
-	 */
-	public PixelFormat withAuxBuffers(final int num_aux_buffers) {
-		if ( num_aux_buffers < 0 )
-			throw new IllegalArgumentException("Invalid number of auxiliary buffers specified: " + num_aux_buffers);
-
-		final PixelFormat pf = new PixelFormat(this);
-		pf.num_aux_buffers = num_aux_buffers;
-		return pf;
-	}
-
-	public int getAccumulationBitsPerPixel() {
-		return accum_bpp;
-	}
-
-	/**
-	 * Returns a new PixelFormat object with the same properties as this PixelFormat and the new bits per pixel in the accumulation buffer value.
-	 *
-	 * @param accum_bpp the new bits per pixel in the accumulation buffer value.
-	 *
-	 * @return the new PixelFormat
-	 */
-	public PixelFormat withAccumulationBitsPerPixel(final int accum_bpp) {
-		if ( accum_bpp < 0 )
-			throw new IllegalArgumentException("Invalid number of bits per pixel in the accumulation buffer specified: " + accum_bpp);
-
-		final PixelFormat pf = new PixelFormat(this);
-		pf.accum_bpp = accum_bpp;
-		return pf;
-	}
-
-	public int getAccumulationAlpha() {
-		return accum_alpha;
-	}
-
-	/**
-	 * Returns a new PixelFormat object with the same properties as this PixelFormat and the new alpha bits in the accumulation buffer value.
-	 *
-	 * @param accum_alpha the new alpha bits in the accumulation buffer value.
-	 *
-	 * @return the new PixelFormat
-	 */
-	public PixelFormat withAccumulationAlpha(final int accum_alpha) {
-		if ( accum_alpha < 0 )
-			throw new IllegalArgumentException("Invalid number of alpha bits in the accumulation buffer specified: " + accum_alpha);
-
-		final PixelFormat pf = new PixelFormat(this);
-		pf.accum_alpha = accum_alpha;
-		return pf;
-	}
-
-	public boolean isStereo() {
-		return stereo;
-	}
-
-	/**
-	 * Returns a new PixelFormat object with the same properties as this PixelFormat and the new stereo value.
-	 *
-	 * @param stereo the new stereo value.
-	 *
-	 * @return the new PixelFormat
-	 */
-	public PixelFormat withStereo(final boolean stereo) {
-		final PixelFormat pf = new PixelFormat(this);
-		pf.stereo = stereo;
-		return pf;
-	}
-
-	public boolean isFloatingPoint() {
-		return floating_point;
-	}
-
-	/**
-	 * Returns a new PixelFormat object with the same properties as this PixelFormat and the new floating point value.
-	 * If floating_point is true, floating_point_packed will be reset to false.
-	 *
-	 * @param floating_point the new floating point value.
-	 *
-	 * @return the new PixelFormat
-	 */
-	public PixelFormat withFloatingPoint(final boolean floating_point) {
-		final PixelFormat pf = new PixelFormat(this);
-		pf.floating_point = floating_point;
-		if ( floating_point )
-			pf.floating_point_packed = false;
-		return pf;
-	}
-
-	/**
-	 * Returns a new PixelFormat object with the same properties as this PixelFormat and the new packed floating point value.
-	 * If floating_point_packed is true, floating_point will be reset to false.
-	 *
-	 * @param floating_point_packed the new packed floating point value.
-	 *
-	 * @return the new PixelFormat
-	 */
-	public PixelFormat withFloatingPointPacked(final boolean floating_point_packed) {
-		final PixelFormat pf = new PixelFormat(this);
-		pf.floating_point_packed = floating_point_packed;
-		if ( floating_point_packed )
-			pf.floating_point = false;
-		return pf;
-	}
-
-	public boolean isSRGB() {
-		return sRGB;
-	}
-
-	/**
-	 * Returns a new PixelFormat object with the same properties as this PixelFormat and the new sRGB value.
-	 *
-	 * @param sRGB the new floating point value.
-	 *
-	 * @return the new PixelFormat
-	 */
-	public PixelFormat withSRGB(final boolean sRGB) {
-		final PixelFormat pf = new PixelFormat(this);
-		pf.sRGB = sRGB;
-		return pf;
-	}
-
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/opengl/PixelFormatLWJGL.java b/src/embeddedlibs/org/lwjglx/opengl/PixelFormatLWJGL.java
deleted file mode 100644
index c3f54df..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/PixelFormatLWJGL.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (c) 2002-2011 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-/**
- * [INTERNAL USE ONLY]
- *
- * @author Spasi
- */
-public interface PixelFormatLWJGL {
-	// Marker interface
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/opengl/RenderTexture.java b/src/embeddedlibs/org/lwjglx/opengl/RenderTexture.java
deleted file mode 100644
index 60dd71d..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/RenderTexture.java
+++ /dev/null
@@ -1,251 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-import java.nio.IntBuffer;
-
-import org.lwjgl.BufferUtils;
-
-import static org.lwjgl.opengl.GL11.*;
-
-/** This class represents the state necessary for render-to-texture. */
-public final class RenderTexture {
-
-	// ----------------------------------------------------------------------------------
-	// ----------------------------- WGL_ARB_render_texture -----------------------------
-	// ----------------------------------------------------------------------------------
-
-	/*
-	Accepted by the <piAttributes> parameter of wglGetPixelFormatAttribivARB,
-	wglGetPixelFormatAttribfvARB, and the <piAttribIList> and <pfAttribIList>
-	parameters of wglChoosePixelFormatARB:
-	*/
-	private static final int WGL_BIND_TO_TEXTURE_RGB_ARB = 0x2070;
-	private static final int WGL_BIND_TO_TEXTURE_RGBA_ARB = 0x2071;
-
-	/*
-	Accepted by the <piAttribList> parameter of wglCreatePbufferARB and
-	by the <iAttribute> parameter of wglQueryPbufferARB:
-	*/
-	private static final int WGL_TEXTURE_FORMAT_ARB = 0x2072;
-	private static final int WGL_TEXTURE_TARGET_ARB = 0x2073;
-	private static final int WGL_MIPMAP_TEXTURE_ARB = 0x2074;
-
-	/*
-	Accepted as a value in the <piAttribList> parameter of
-	wglCreatePbufferARB and returned in the value parameter of
-	wglQueryPbufferARB when <iAttribute> is WGL_TEXTURE_FORMAT_ARB:
-	*/
-	private static final int WGL_TEXTURE_RGB_ARB = 0x2075;
-	private static final int WGL_TEXTURE_RGBA_ARB = 0x2076;
-
-	/*
-	Accepted as a value in the <piAttribList> parameter of
-	wglCreatePbufferARB and returned in the value parameter of
-	wglQueryPbufferARB when <iAttribute> is WGL_TEXTURE_TARGET_ARB:
-	*/
-	private static final int WGL_TEXTURE_CUBE_MAP_ARB = 0x2078;
-	private static final int WGL_TEXTURE_1D_ARB = 0x2079;
-	private static final int WGL_TEXTURE_2D_ARB = 0x207A;
-	private static final int WGL_NO_TEXTURE_ARB = 0x2077;
-
-	/*
-	Accepted by the <piAttribList> parameter of wglSetPbufferAttribARB and
-	by the <iAttribute> parameter of wglQueryPbufferARB:
-	*/
-	static final int WGL_MIPMAP_LEVEL_ARB = 0x207B;
-	static final int WGL_CUBE_MAP_FACE_ARB = 0x207C;
-
-	/*
-	Accepted as a value in the <piAttribList> parameter of
-	wglSetPbufferAttribARB and returned in the value parameter of
-	wglQueryPbufferARB when <iAttribute> is WGL_CUBE_MAP_FACE_ARB:
-	*/
-	static final int WGL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB = 0x207D;
-	static final int WGL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB = 0x207E;
-	static final int WGL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB = 0x207F;
-	static final int WGL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB = 0x2080;
-	static final int WGL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB = 0x2081;
-	static final int WGL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB = 0x2082;
-
-	/*
-	Accepted by the <iBuffer> parameter of wglBindTexImageARB and
-	wglReleaseTexImageARB:
-	*/
-	static final int WGL_FRONT_LEFT_ARB = 0x2083;
-	static final int WGL_FRONT_RIGHT_ARB = 0x2084;
-	static final int WGL_BACK_LEFT_ARB = 0x2085;
-	static final int WGL_BACK_RIGHT_ARB = 0x2086;
-
-	/*
-	private static final int WGL_AUX0_ARB = 0x2087;
-	private static final int WGL_AUX1_ARB = 0x2088;
-	private static final int WGL_AUX2_ARB = 0x2089;
-	private static final int WGL_AUX3_ARB = 0x208A;
-	private static final int WGL_AUX4_ARB = 0x208B;
-	private static final int WGL_AUX5_ARB = 0x208C;
-	private static final int WGL_AUX6_ARB = 0x208D;
-	private static final int WGL_AUX7_ARB = 0x208E;
-	private static final int WGL_AUX8_ARB = 0x208F;
-	private static final int WGL_AUX9_ARB = 0x2090;
-	*/
-
-	// -------------------------------------------------------------------------------------------
-	// ----------------------------- WGL_NV_render_texture_rectangle -----------------------------
-	// -------------------------------------------------------------------------------------------
-
-	/*
-	Accepted by the <piAttributes> parameter of wglGetPixelFormatAttribivARB,
-	wglGetPixelFormatAttribfvARB, and the <piAttribIList> and <pfAttribIList>
-	parameters of wglChoosePixelFormatARB:
-	*/
-	private static final int WGL_BIND_TO_TEXTURE_RECTANGLE_RGB_NV = 0x20A0;
-	private static final int WGL_BIND_TO_TEXTURE_RECTANGLE_RGBA_NV = 0x20A1;
-
-	/*
-	Accepted as a value in the <piAttribList> parameter of wglCreatePbufferARB
-	and returned in the value parameter of wglQueryPbufferARB when
-	<iAttribute> is WGL_TEXTURE_TARGET_ARB:
-	*/
-	private static final int WGL_TEXTURE_RECTANGLE_NV = 0x20A2;
-
-	// ---------------------------------------------------------------------------------------
-	// ----------------------------- WGL_NV_render_depth_texture -----------------------------
-	// ---------------------------------------------------------------------------------------
-
-	/*
-	Accepted by the <piAttributes> parameter of wglGetPixelFormatAttribivARB,
-	wglGetPixelFormatAttribfvARB, and the <piAttribIList> and <pfAttribIList>
-	parameters of wglChoosePixelFormatARB:
-	*/
-	private static final int WGL_BIND_TO_TEXTURE_DEPTH_NV = 0x20A3;
-	private static final int WGL_BIND_TO_TEXTURE_RECTANGLE_DEPTH_NV = 0x20A4;
-
-	/*
-	Accepted by the <piAttribList> parameter of wglCreatePbufferARB and
-	by the <iAttribute> parameter of wglQueryPbufferARB:
-	*/
-	private static final int WGL_DEPTH_TEXTURE_FORMAT_NV = 0x20A5;
-
-	/*
-	Accepted as a value in the <piAttribList> parameter of wglCreatePbufferARB
-	and returned in the value parameter of wglQueryPbufferARB when
-	<iAttribute> is WGL_DEPTH_TEXTURE_FORMAT_NV:
-	*/
-	private static final int WGL_TEXTURE_DEPTH_COMPONENT_NV = 0x20A6;
-
-	/*
-	Accepted by the <iBuffer> parameter of wglBindTexImageARB:
-	*/
-	static final int WGL_DEPTH_COMPONENT_NV = 0x20A7;
-
-	/** The TEXTURE_1D target. */
-	public static final int RENDER_TEXTURE_1D = WGL_TEXTURE_1D_ARB;
-
-	/** The TEXTURE_2D target. */
-	public static final int RENDER_TEXTURE_2D = WGL_TEXTURE_2D_ARB;
-
-	/** The TEXTURE_RECTANGLE target. */
-	public static final int RENDER_TEXTURE_RECTANGLE = WGL_TEXTURE_RECTANGLE_NV;
-
-	/** The TEXTURE_CUBE_MAP target. */
-	public static final int RENDER_TEXTURE_CUBE_MAP = WGL_TEXTURE_CUBE_MAP_ARB;
-
-	IntBuffer pixelFormatCaps;
-	IntBuffer pBufferAttribs;
-
-	/**
-	 * Creates a RenderTexture object for enabling render-to-texture on a P-buffer.
-	 * <p/>
-	 * NOTE: Only one of useRGB and useRGBA can be true at the same time.
-	 * <p/>
-	 * NOTE: useRGB(A) and useDepth can be true at the same time, thus allowing two different render textures.
-	 * <p/>
-	 * NOTE: The target parameter can be one of the following:
-	 * <p/>
-	 * RENDER_TEXTURE_1D RENDER_TEXTURE_2D RENDER_TEXTURE_RECTANGLE RENDER_TEXTURE_CUBE_MAP
-	 *
-	 * @param useRGB      - When true the P-buffer can be used as an RGB render texture.
-	 * @param useRGBA     - When true the P-buffer can be used as an RGBA render texture.
-	 * @param useDepth    - When true the P-buffer can be used as a depth render texture.
-	 * @param isRectangle - When true rectangle textures will be allowed on the P-buffer.
-	 * @param target      - The texture target of the render texture.
-	 * @param mipmaps     - How many mipmap levels to allocate on the P-buffer.
-	 */
-	public RenderTexture(boolean useRGB, boolean useRGBA, boolean useDepth, boolean isRectangle, int target, int mipmaps) {
-		if ( useRGB && useRGBA )
-			throw new IllegalArgumentException("A RenderTexture can't be both RGB and RGBA.");
-
-		if ( mipmaps < 0 )
-			throw new IllegalArgumentException("The mipmap levels can't be negative.");
-
-		if ( isRectangle && target != RENDER_TEXTURE_RECTANGLE )
-			throw new IllegalArgumentException("When the RenderTexture is rectangle the target must be RENDER_TEXTURE_RECTANGLE.");
-
-		pixelFormatCaps = BufferUtils.createIntBuffer(4);
-		pBufferAttribs = BufferUtils.createIntBuffer(8);
-
-		if ( useRGB ) {
-			pixelFormatCaps.put(isRectangle ? WGL_BIND_TO_TEXTURE_RECTANGLE_RGB_NV : WGL_BIND_TO_TEXTURE_RGB_ARB);
-			pixelFormatCaps.put(GL_TRUE);
-
-			pBufferAttribs.put(WGL_TEXTURE_FORMAT_ARB);
-			pBufferAttribs.put(WGL_TEXTURE_RGB_ARB);
-		} else if ( useRGBA ) {
-			pixelFormatCaps.put(isRectangle ? WGL_BIND_TO_TEXTURE_RECTANGLE_RGBA_NV : WGL_BIND_TO_TEXTURE_RGBA_ARB);
-			pixelFormatCaps.put(GL_TRUE);
-
-			pBufferAttribs.put(WGL_TEXTURE_FORMAT_ARB);
-			pBufferAttribs.put(WGL_TEXTURE_RGBA_ARB);
-		}
-
-		if ( useDepth ) {
-			pixelFormatCaps.put(isRectangle ? WGL_BIND_TO_TEXTURE_RECTANGLE_DEPTH_NV : WGL_BIND_TO_TEXTURE_DEPTH_NV);
-			pixelFormatCaps.put(GL_TRUE);
-
-			pBufferAttribs.put(WGL_DEPTH_TEXTURE_FORMAT_NV);
-			pBufferAttribs.put(WGL_TEXTURE_DEPTH_COMPONENT_NV);
-		}
-
-		pBufferAttribs.put(WGL_TEXTURE_TARGET_ARB);
-		pBufferAttribs.put(target);
-
-		if ( mipmaps != 0 ) {
-			pBufferAttribs.put(WGL_MIPMAP_TEXTURE_ARB);
-			pBufferAttribs.put(mipmaps);
-		}
-
-		pixelFormatCaps.flip();
-		pBufferAttribs.flip();
-	}
-
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/opengl/Sync.java b/src/embeddedlibs/org/lwjglx/opengl/Sync.java
deleted file mode 100644
index 3c65321..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/Sync.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright (c) 2002-2012 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-import org.lwjglx.Sys;
-
-/**
-* A highly accurate sync method that continually adapts to the system 
-* it runs on to provide reliable results.
-*
-* @author Riven
-* @author kappaOne
-*/
-class Sync {
-
-	/** number of nano seconds in a second */
-	private static final long NANOS_IN_SECOND = 1000L * 1000L * 1000L;
-
-	/** The time to sleep/yield until the next frame */
-	private static long nextFrame = 0;
-	
-	/** whether the initialisation code has run */
-	private static boolean initialised = false;
-	
-	/** for calculating the averages the previous sleep/yield times are stored */
-	private static RunningAvg sleepDurations = new RunningAvg(10);
-	private static RunningAvg yieldDurations = new RunningAvg(10);
-	
-	
-	/**
-	 * An accurate sync method that will attempt to run at a constant frame rate.
-	 * It should be called once every frame.
-	 * 
-	 * @param fps - the desired frame rate, in frames per second
-	 */
-	public static void sync(int fps) {
-		if (fps <= 0) return;
-		if (!initialised) initialise();
-		
-		try {
-			// sleep until the average sleep time is greater than the time remaining till nextFrame
-			for (long t0 = getTime(), t1; (nextFrame - t0) > sleepDurations.avg(); t0 = t1) {
-				Thread.sleep(1);
-				sleepDurations.add((t1 = getTime()) - t0); // update average sleep time
-			}
-	
-			// slowly dampen sleep average if too high to avoid yielding too much
-			sleepDurations.dampenForLowResTicker();
-	
-			// yield until the average yield time is greater than the time remaining till nextFrame
-			for (long t0 = getTime(), t1; (nextFrame - t0) > yieldDurations.avg(); t0 = t1) {
-				Thread.yield();
-				yieldDurations.add((t1 = getTime()) - t0); // update average yield time
-			}
-		} catch (InterruptedException e) {
-			
-		}
-		
-		// schedule next frame, drop frame(s) if already too late for next frame
-		nextFrame = Math.max(nextFrame + NANOS_IN_SECOND / fps, getTime());
-	}
-	
-	/**
-	 * This method will initialise the sync method by setting initial
-	 * values for sleepDurations/yieldDurations and nextFrame.
-	 * 
-	 * If running on windows it will start the sleep timer fix.
-	 */
-	private static void initialise() {
-		initialised = true;
-		
-		sleepDurations.init(1000 * 1000);
-		yieldDurations.init((int) (-(getTime() - getTime()) * 1.333));
-		
-		nextFrame = getTime();
-		
-		String osName = System.getProperty("os.name");
-		
-		if (osName.startsWith("Win")) {
-			// On windows the sleep functions can be highly inaccurate by 
-			// over 10ms making in unusable. However it can be forced to 
-			// be a bit more accurate by running a separate sleeping daemon
-			// thread.
-			Thread timerAccuracyThread = new Thread(new Runnable() {
-				public void run() {
-					try {
-						Thread.sleep(Long.MAX_VALUE);
-					} catch (Exception e) {}
-				}
-			});
-			
-			timerAccuracyThread.setName("LWJGL Timer");
-			timerAccuracyThread.setDaemon(true);
-			timerAccuracyThread.start();
-		}
-	}
-
-	/**
-	 * Get the system time in nano seconds
-	 * 
-	 * @return will return the current time in nano's
-	 */
-	private static long getTime() {
-		return (Sys.getTime() * NANOS_IN_SECOND) / Sys.getTimerResolution();
-	}
-
-	private static class RunningAvg {
-		private final long[] slots;
-		private int offset;
-		
-		private static final long DAMPEN_THRESHOLD = 10 * 1000L * 1000L; // 10ms
-		private static final float DAMPEN_FACTOR = 0.9f; // don't change: 0.9f is exactly right!
-
-		public RunningAvg(int slotCount) {
-			this.slots = new long[slotCount];
-			this.offset = 0;
-		}
-
-		public void init(long value) {
-			while (this.offset < this.slots.length) {
-				this.slots[this.offset++] = value;
-			}
-		}
-
-		public void add(long value) {
-			this.slots[this.offset++ % this.slots.length] = value;
-			this.offset %= this.slots.length;
-		}
-
-		public long avg() {
-			long sum = 0;
-			for (int i = 0; i < this.slots.length; i++) {
-				sum += this.slots[i];
-			}
-			return sum / this.slots.length;
-		}
-		
-		public void dampenForLowResTicker() {
-			if (this.avg() > DAMPEN_THRESHOLD) {
-				for (int i = 0; i < this.slots.length; i++) {
-					this.slots[i] *= DAMPEN_FACTOR;
-				}
-			}
-		}
-	}
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/opengl/Util.java b/src/embeddedlibs/org/lwjglx/opengl/Util.java
deleted file mode 100644
index 2afde49..0000000
--- a/src/embeddedlibs/org/lwjglx/opengl/Util.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.opengl;
-
-import org.lwjgl.opengl.GL;
-import org.lwjgl.opengl.GLCapabilities;
-
-import static org.lwjgl.opengl.ARBImaging.*;
-import static org.lwjgl.opengl.GL11.*;
-import static org.lwjgl.opengl.GL30.*;
-
-
-/**
- * Simple utility class.
- *
- * @author cix_foo <cix_foo@users.sourceforge.net>
- * @version $Revision$
- */
-
-public final class Util {
-	
-	static GLCapabilities glContext = GL.createCapabilities();
-	
-	/** No c'tor */
-	private Util() {
-	}
-
-	/**
-	 * Throws OpenGLException if glGetError() returns anything else than GL_NO_ERROR
-	 *
-	 */
-	public static void checkGLError() throws OpenGLException {
-		// glContext.checkGLError();
-	}
-
-	/**
-	 * Translate a GL error code to a String describing the error
-	 */
-	public static String translateGLErrorString(int error_code) {
-		switch (error_code) {
-			case GL_NO_ERROR:
-				return "No error";
-			case GL_INVALID_ENUM:
-				return "Invalid enum";
-			case GL_INVALID_VALUE:
-				return "Invalid value";
-			case GL_INVALID_OPERATION:
-				return "Invalid operation";
-			case GL_STACK_OVERFLOW:
-				return "Stack overflow";
-			case GL_STACK_UNDERFLOW:
-				return "Stack underflow";
-			case GL_OUT_OF_MEMORY:
-				return "Out of memory";
-			case GL_TABLE_TOO_LARGE:
-				return "Table too large";
-			case GL_INVALID_FRAMEBUFFER_OPERATION:
-				return "Invalid framebuffer operation";
-			default:
-				return null;
-		}
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/Display.java b/src/embeddedlibs/org/lwjglx/util/Display.java
deleted file mode 100644
index cc09839..0000000
--- a/src/embeddedlibs/org/lwjglx/util/Display.java
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Comparator;
-
-import org.lwjglx.LWJGLException;
-import org.lwjglx.LWJGLUtil;
-import org.lwjglx.opengl.DisplayMode;
-
-/**
- * Display initialization utility, that can be used to find display modes and pick
- * one for you based on your criteria.
- * @author $Author: spasi $
- * @version $Revision: 3418 $
- * $Id: Display.java 3418 2010-09-28 21:11:35Z spasi $
- */
-public final class Display {
-
-	private static final boolean DEBUG = false;
-
-	/**
-	 * Determine the available display modes that match the specified minimum and maximum criteria.
-	 * If any given criterium is specified as -1 then it is ignored.
-	 *
-	 * @param minWidth the minimum display resolution in pixels
-	 * @param minHeight the minimum display resolution in pixels
-	 * @param maxWidth the maximum display resolution in pixels
-	 * @param maxHeight the maximum display resolution in pixels
-	 * @param minBPP the minimum bit depth per pixel
-	 * @param maxBPP the maximum bit depth per pixel
-	 * @param minFreq the minimum display frequency in Hz
-	 * @param maxFreq the maximum display frequency in Hz
-	 * @return an array of matching display modes
-	 */
-	public static DisplayMode[] getAvailableDisplayModes(int minWidth, int minHeight, int maxWidth, int maxHeight, int minBPP, int maxBPP,
-		int minFreq, int maxFreq) throws LWJGLException
-	{
-		// First get the available display modes
-		DisplayMode[] modes = org.lwjglx.opengl.Display.getAvailableDisplayModes();
-
-		if (LWJGLUtil.DEBUG || DEBUG) {
-			System.out.println("Available screen modes:");
-			for ( DisplayMode mode : modes ) {
-				System.out.println(mode);
-			}
-		}
-
-		ArrayList<DisplayMode> matches = new ArrayList<DisplayMode>(modes.length);
-
-		for (int i = 0; i < modes.length; i ++) {
-			assert modes[i] != null : ""+i+" "+modes.length;
-			if (minWidth != -1 && modes[i].getWidth() < minWidth)
-				continue;
-			if (maxWidth != -1 && modes[i].getWidth() > maxWidth)
-				continue;
-			if (minHeight != -1 && modes[i].getHeight() < minHeight)
-				continue;
-			if (maxHeight != -1 && modes[i].getHeight() > maxHeight)
-				continue;
-			if (minBPP != -1 && modes[i].getBitsPerPixel() < minBPP)
-				continue;
-			if (maxBPP != -1 && modes[i].getBitsPerPixel() > maxBPP)
-				continue;
-			//if (modes[i].bpp == 24)
-			//	continue;
-			if (modes[i].getFrequency() != 0) {
-				if (minFreq != -1 && modes[i].getFrequency() < minFreq)
-					continue;
-				if (maxFreq != -1 && modes[i].getFrequency() > maxFreq)
-					continue;
-			}
-			matches.add(modes[i]);
-		}
-
-		DisplayMode[] ret = new DisplayMode[matches.size()];
-		matches.toArray(ret);
-		if (LWJGLUtil.DEBUG && DEBUG) {
-			System.out.println("Filtered screen modes:");
-			for ( DisplayMode mode : ret ) {
-				System.out.println(mode);
-			}
-		}
-
-		return ret;
-	}
-
-	/**
-	 * Create the display by choosing from a list of display modes based on an order of preference.
-	 * You must supply a list of allowable display modes, probably by calling getAvailableDisplayModes(),
-	 * and an array with the order in which you would like them sorted in descending order.
-	 * This method attempts to create the topmost display mode; if that fails, it will try the next one,
-	 * and so on, until there are no modes left. If no mode is set at the end, an exception is thrown.
-	 * @param dm a list of display modes to choose from
-	 * @param param the names of the DisplayMode fields in the order in which you would like them sorted.
-	 * @return the chosen display mode
-	 * @throws NoSuchFieldException if one of the params is not a field in DisplayMode
-	 * @throws Exception if no display mode could be set
-	 * @see org.lwjgl.opengl.DisplayMode
-	 */
-	public static DisplayMode setDisplayMode(DisplayMode[] dm, final String[] param) throws Exception {
-
-		class FieldAccessor {
-			final String fieldName;
-			final int order;
-			final int preferred;
-			final boolean usePreferred;
-			FieldAccessor(String fieldName, int order, int preferred, boolean usePreferred) {
-				this.fieldName = fieldName;
-				this.order = order;
-				this.preferred = preferred;
-				this.usePreferred = usePreferred;
-			}
-			int getInt(DisplayMode mode) {
-				if ("width".equals(fieldName)) {
-					return mode.getWidth();
-				}
-				if ("height".equals(fieldName)) {
-					return mode.getHeight();
-				}
-				if ("freq".equals(fieldName)) {
-					return mode.getFrequency();
-				}
-				if ("bpp".equals(fieldName)) {
-					return mode.getBitsPerPixel();
-				}
-				throw new IllegalArgumentException("Unknown field "+fieldName);
-			}
-		}
-
-		class Sorter implements Comparator<DisplayMode> {
-
-			final FieldAccessor[] accessors;
-
-			Sorter() {
-				accessors = new FieldAccessor[param.length];
-				for (int i = 0; i < accessors.length; i ++) {
-					int idx = param[i].indexOf('=');
-					if (idx > 0) {
-						accessors[i] = new FieldAccessor(param[i].substring(0, idx), 0, Integer.parseInt(param[i].substring(idx + 1, param[i].length())), true);
-					} else if (param[i].charAt(0) == '-') {
-						accessors[i] = new FieldAccessor(param[i].substring(1), -1, 0, false);
-					} else {
-						accessors[i] = new FieldAccessor(param[i], 1, 0, false);
-					}
-				}
-			}
-
-			/**
-			 * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
-			 */
-			public int compare(DisplayMode dm1, DisplayMode dm2) {
-				for ( FieldAccessor accessor : accessors ) {
-					int f1 = accessor.getInt(dm1);
-					int f2 = accessor.getInt(dm2);
-
-					if ( accessor.usePreferred && f1 != f2 ) {
-						if ( f1 == accessor.preferred )
-							return -1;
-						else if ( f2 == accessor.preferred )
-							return 1;
-						else {
-							// Score according to the difference between the values
-							int absf1 = Math.abs(f1 - accessor.preferred);
-							int absf2 = Math.abs(f2 - accessor.preferred);
-							if ( absf1 < absf2 )
-								return -1;
-							else if ( absf1 > absf2 )
-								return 1;
-							else
-								continue;
-						}
-					} else if ( f1 < f2 )
-						return accessor.order;
-					else if ( f1 == f2 )
-						continue;
-					else
-						return -accessor.order;
-				}
-
-				return 0;
-			}
-		}
-
-		// Sort the display modes
-		Arrays.sort(dm, new Sorter());
-
-		// Try them out in the appropriate order
-		if (LWJGLUtil.DEBUG || DEBUG) {
-			System.out.println("Sorted display modes:");
-			for ( DisplayMode aDm : dm ) {
-				System.out.println(aDm);
-			}
-		}
-		for ( DisplayMode aDm : dm ) {
-			try {
-				if ( LWJGLUtil.DEBUG || DEBUG )
-					System.out.println("Attempting to set displaymode: " + aDm);
-				org.lwjglx.opengl.Display.setDisplayMode(aDm);
-				return aDm;
-			} catch (Exception e) {
-				if ( LWJGLUtil.DEBUG || DEBUG ) {
-					System.out.println("Failed to set display mode to " + aDm);
-					e.printStackTrace();
-				}
-			}
-		}
-
-		throw new Exception("Failed to set display mode.");
-	}
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/WaveData.java b/src/embeddedlibs/org/lwjglx/util/WaveData.java
deleted file mode 100644
index f1b9cba..0000000
--- a/src/embeddedlibs/org/lwjglx/util/WaveData.java
+++ /dev/null
@@ -1,258 +0,0 @@
-/* 
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are 
- * met:
- * 
- * * Redistributions of source code must retain the above copyright 
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of 
- *   its contributors may be used to endorse or promote products derived 
- *   from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util;
-
-import java.io.BufferedInputStream;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URL;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.ShortBuffer;
-
-import javax.sound.sampled.AudioFormat;
-import javax.sound.sampled.AudioInputStream;
-import javax.sound.sampled.AudioSystem;
-
-import org.lwjgl.openal.AL10;
-
-//import com.sun.media.sound.WaveFileReader;
-
-/**
- *
- * Utitlity class for loading wavefiles.
- *
- * @author Brian Matzon <brian@matzon.dk>
- * @version $Revision$
- * $Id$
- */
-public class WaveData {
-	/** actual wave data */
-	public final ByteBuffer data;
-
-	/** format type of data */
-	public final int format;
-
-	/** sample rate of data */
-	public final int samplerate;
-
-	/**
-	 * Creates a new WaveData
-	 * 
-	 * @param data actual wavedata
-	 * @param format format of wave data
-	 * @param samplerate sample rate of data
-	 */
-	private WaveData(ByteBuffer data, int format, int samplerate) {
-		this.data = data;
-		this.format = format;
-		this.samplerate = samplerate;
-	}
-
-	/**
-	 * Disposes the wavedata
-	 */
-	public void dispose() {
-		data.clear();
-	}
-
-	/**
-	 * Creates a WaveData container from the specified url
-	 * 
-	 * @param path URL to file 
-	 * @return WaveData containing data, or null if a failure occured
-	 */
-	public static WaveData create(URL path) {
-		try {
-			// due to an issue with AudioSystem.getAudioInputStream
-			// and mixing unsigned and signed code
-			// we will use the reader directly
-			return create(AudioSystem.getAudioInputStream(path));
-			//WaveFileReader wfr = new WaveFileReader();
-			//return create(wfr.getAudioInputStream(new BufferedInputStream(path.openStream())));
-		} catch (Exception e) {
-			org.lwjglx.LWJGLUtil.log("Unable to create from: " + path + ", " + e.getMessage());
-			return null;
-		}		
-	}
-	
-	/**
-	 * Creates a WaveData container from the specified in the classpath
-	 * 
-	 * @param path path to file (relative, and in classpath) 
-	 * @return WaveData containing data, or null if a failure occured
-	 */
-	public static WaveData create(String path) {
-		return create(Thread.currentThread().getContextClassLoader().getResource(path));
-	}
-	
-	/**
-	 * Creates a WaveData container from the specified inputstream
-	 * 
-	 * @param is InputStream to read from 
-	 * @return WaveData containing data, or null if a failure occured
-	 */
-	public static WaveData create(InputStream is) {
-		try {
-			return create(
-				AudioSystem.getAudioInputStream(is));
-		} catch (Exception e) {
-			org.lwjglx.LWJGLUtil.log("Unable to create from inputstream, " + e.getMessage());
-			return null;
-		}		
-	}	
-	
-	/**	
-	 * Creates a WaveData container from the specified bytes
-	 *
-	 * @param buffer array of bytes containing the complete wave file
-	 * @return WaveData containing data, or null if a failure occured
-	 */
-	public static WaveData create(byte[] buffer) {
-		try {
-			return create(
-				AudioSystem.getAudioInputStream(
-					new BufferedInputStream(new ByteArrayInputStream(buffer))));
-		} catch (Exception e) {
-			org.lwjglx.LWJGLUtil.log("Unable to create from byte array, " + e.getMessage());
-			return null;
-		}
-	}
-	
-	/**	
-	 * Creates a WaveData container from the specified ByetBuffer.
-	 * If the buffer is backed by an array, it will be used directly, 
-	 * else the contents of the buffer will be copied using get(byte[]).
-	 *
-	 * @param buffer ByteBuffer containing sound file
-	 * @return WaveData containing data, or null if a failure occured
-	 */
-	public static WaveData create(ByteBuffer buffer) {
-		try {
-			byte[] bytes = null;
-			
-			if(buffer.hasArray()) {
-				bytes = buffer.array();
-			} else {
-				bytes = new byte[buffer.capacity()];
-				buffer.get(bytes);
-			}
-			return create(bytes);
-		} catch (Exception e) {
-			org.lwjglx.LWJGLUtil.log("Unable to create from ByteBuffer, " + e.getMessage());
-			return null;
-		}
-	}	
-
-	/**
-	 * Creates a WaveData container from the specified stream
-	 * 
-	 * @param ais AudioInputStream to read from
-	 * @return WaveData containing data, or null if a failure occured
-	 */
-	public static WaveData create(AudioInputStream ais) {
-		//get format of data
-		AudioFormat audioformat = ais.getFormat();
-
-		// get channels
-		int channels = 0;
-		if (audioformat.getChannels() == 1) {
-			if (audioformat.getSampleSizeInBits() == 8) {
-				channels = AL10.AL_FORMAT_MONO8;
-			} else if (audioformat.getSampleSizeInBits() == 16) {
-				channels = AL10.AL_FORMAT_MONO16;
-			} else {
-				assert false : "Illegal sample size";
-			}
-		} else if (audioformat.getChannels() == 2) {
-			if (audioformat.getSampleSizeInBits() == 8) {
-				channels = AL10.AL_FORMAT_STEREO8;
-			} else if (audioformat.getSampleSizeInBits() == 16) {
-				channels = AL10.AL_FORMAT_STEREO16;
-			} else {
-				assert false : "Illegal sample size";
-			}
-		} else {
-			assert false : "Only mono or stereo is supported";
-		}
-
-		//read data into buffer
-		ByteBuffer buffer = null;
-		try {
-			int available = ais.available();
-			if(available <= 0) {
-				available = ais.getFormat().getChannels() * (int) ais.getFrameLength() * ais.getFormat().getSampleSizeInBits() / 8;
-			}
-			byte[] buf = new byte[ais.available()];
-			int read = 0, total = 0;
-			while ((read = ais.read(buf, total, buf.length - total)) != -1
-				&& total < buf.length) {
-				total += read;
-			}
-			buffer = convertAudioBytes(buf, audioformat.getSampleSizeInBits() == 16, audioformat.isBigEndian() ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN);
-		} catch (IOException ioe) {
-			return null;
-		}
-
-
-		//create our result
-		WaveData wavedata =
-			new WaveData(buffer, channels, (int) audioformat.getSampleRate());
-
-		//close stream
-		try {
-			ais.close();
-		} catch (IOException ioe) {
-		}
-
-		return wavedata;
-	}
-
-	private static ByteBuffer convertAudioBytes(byte[] audio_bytes, boolean two_bytes_data, ByteOrder order) {
-		ByteBuffer dest = ByteBuffer.allocateDirect(audio_bytes.length);
-		dest.order(ByteOrder.nativeOrder());
-		ByteBuffer src = ByteBuffer.wrap(audio_bytes);
-		src.order(order);
-		if (two_bytes_data) {
-			ShortBuffer dest_short = dest.asShortBuffer();
-			ShortBuffer src_short = src.asShortBuffer();
-			while (src_short.hasRemaining())
-				dest_short.put(src_short.get());
-		} else {
-			while (src.hasRemaining())
-				dest.put(src.get());
-		}
-		dest.rewind();
-		return dest;
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/Cylinder.java b/src/embeddedlibs/org/lwjglx/util/glu/Cylinder.java
deleted file mode 100644
index 5499d9f..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/Cylinder.java
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.glu;
-
-import static org.lwjgl.opengl.GL11.*;
-import static org.lwjglx.util.glu.GLU.*;
-
-/**
- * Cylinder.java
- *
- *
- * Created 23-dec-2003
- * @author Erik Duijs
- */
-public class Cylinder extends Quadric {
-
-	/**
-	 * Constructor for Cylinder.
-	 */
-	public Cylinder() {
-		super();
-	}
-
-	/**
-	 * draws a cylinder oriented along the z axis. The base of the
-	 * cylinder is placed at z = 0, and the top at z=height. Like a sphere, a
-	 * cylinder is subdivided around the z axis into slices, and along the z axis
-	 * into stacks.
-	 *
-	 * Note that if topRadius is set to zero, then this routine will generate a
-	 * cone.
-	 *
-	 * If the orientation is set to GLU.OUTSIDE (with glu.quadricOrientation), then
-	 * any generated normals point away from the z axis. Otherwise, they point
-	 * toward the z axis.
-	 *
-	 * If texturing is turned on (with glu.quadricTexture), then texture
-	 * coordinates are generated so that t ranges linearly from 0.0 at z = 0 to
-	 * 1.0 at z = height, and s ranges from 0.0 at the +y axis, to 0.25 at the +x
-	 * axis, to 0.5 at the -y axis, to 0.75 at the -x axis, and back to 1.0 at the
-	 * +y axis.
-	 *
-	 * @param baseRadius  Specifies the radius of the cylinder at z = 0.
-	 * @param topRadius   Specifies the radius of the cylinder at z = height.
-	 * @param height      Specifies the height of the cylinder.
-	 * @param slices      Specifies the number of subdivisions around the z axis.
-	 * @param stacks      Specifies the number of subdivisions along the z axis.
-	 */
-	public void draw(float baseRadius, float topRadius, float height, int slices, int stacks) {
-
-		float da, r, dr, dz;
-		float x, y, z, nz, nsign;
-		int i, j;
-
-		if (super.orientation == GLU_INSIDE) {
-			nsign = -1.0f;
-		} else {
-			nsign = 1.0f;
-		}
-
-		da = 2.0f * PI / slices;
-		dr = (topRadius - baseRadius) / stacks;
-		dz = height / stacks;
-		nz = (baseRadius - topRadius) / height;
-		// Z component of normal vectors
-
-		if (super.drawStyle == GLU_POINT) {
-			glBegin(GL_POINTS);
-			for (i = 0; i < slices; i++) {
-				x = cos((i * da));
-				y = sin((i * da));
-				normal3f(x * nsign, y * nsign, nz * nsign);
-
-				z = 0.0f;
-				r = baseRadius;
-				for (j = 0; j <= stacks; j++) {
-					glVertex3f((x * r), (y * r), z);
-					z += dz;
-					r += dr;
-				}
-			}
-			glEnd();
-		} else if (super.drawStyle == GLU_LINE || super.drawStyle == GLU_SILHOUETTE) {
-			// Draw rings
-			if (super.drawStyle == GLU_LINE) {
-				z = 0.0f;
-				r = baseRadius;
-				for (j = 0; j <= stacks; j++) {
-					glBegin(GL_LINE_LOOP);
-					for (i = 0; i < slices; i++) {
-						x = cos((i * da));
-						y = sin((i * da));
-						normal3f(x * nsign, y * nsign, nz * nsign);
-						glVertex3f((x * r), (y * r), z);
-					}
-					glEnd();
-					z += dz;
-					r += dr;
-				}
-			} else {
-				// draw one ring at each end
-				if (baseRadius != 0.0) {
-					glBegin(GL_LINE_LOOP);
-					for (i = 0; i < slices; i++) {
-						x = cos((i * da));
-						y = sin((i * da));
-						normal3f(x * nsign, y * nsign, nz * nsign);
-						glVertex3f((x * baseRadius), (y * baseRadius), 0.0f);
-					}
-					glEnd();
-					glBegin(GL_LINE_LOOP);
-					for (i = 0; i < slices; i++) {
-						x = cos((i * da));
-						y = sin((i * da));
-						normal3f(x * nsign, y * nsign, nz * nsign);
-						glVertex3f((x * topRadius), (y * topRadius), height);
-					}
-					glEnd();
-				}
-			}
-			// draw length lines
-			glBegin(GL_LINES);
-			for (i = 0; i < slices; i++) {
-				x = cos((i * da));
-				y = sin((i * da));
-				normal3f(x * nsign, y * nsign, nz * nsign);
-				glVertex3f((x * baseRadius), (y * baseRadius), 0.0f);
-				glVertex3f((x * topRadius), (y * topRadius), (height));
-			}
-			glEnd();
-		} else if (super.drawStyle == GLU_FILL) {
-			float ds = 1.0f / slices;
-			float dt = 1.0f / stacks;
-			float t = 0.0f;
-			z = 0.0f;
-			r = baseRadius;
-			for (j = 0; j < stacks; j++) {
-				float s = 0.0f;
-				glBegin(GL_QUAD_STRIP);
-				for (i = 0; i <= slices; i++) {
-					if (i == slices) {
-						x = sin(0.0f);
-						y = cos(0.0f);
-					} else {
-						x = sin((i * da));
-						y = cos((i * da));
-					}
-					if (nsign == 1.0f) {
-						normal3f((x * nsign), (y * nsign), (nz * nsign));
-						TXTR_COORD(s, t);
-						glVertex3f((x * r), (y * r), z);
-						normal3f((x * nsign), (y * nsign), (nz * nsign));
-						TXTR_COORD(s, t + dt);
-						glVertex3f((x * (r + dr)), (y * (r + dr)), (z + dz));
-					} else {
-						normal3f(x * nsign, y * nsign, nz * nsign);
-						TXTR_COORD(s, t);
-						glVertex3f((x * r), (y * r), z);
-						normal3f(x * nsign, y * nsign, nz * nsign);
-						TXTR_COORD(s, t + dt);
-						glVertex3f((x * (r + dr)), (y * (r + dr)), (z + dz));
-					}
-					s += ds;
-				} // for slices
-				glEnd();
-				r += dr;
-				t += dt;
-				z += dz;
-			} // for stacks
-		}
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/Disk.java b/src/embeddedlibs/org/lwjglx/util/glu/Disk.java
deleted file mode 100644
index 4478cd0..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/Disk.java
+++ /dev/null
@@ -1,214 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.glu;
-
-import static org.lwjgl.opengl.GL11.*;
-import static org.lwjglx.util.glu.GLU.*;
-
-/**
- * Disk.java
- *
- *
- * Created 23-dec-2003
- * @author Erik Duijs
- */
-public class Disk extends Quadric {
-
-	/**
-	 * Constructor for Disk.
-	 */
-	public Disk() {
-		super();
-	}
-
-    /**
-     * renders a disk on the z = 0  plane.  The disk has a radius of
-     * outerRadius, and contains a concentric circular hole with a radius of
-     * innerRadius. If innerRadius is 0, then no hole is generated. The disk is
-     * subdivided around the z axis into slices (like pizza slices), and also
-     * about the z axis into rings (as specified by slices and loops,
-     * respectively).
-     *
-     * With respect to orientation, the +z side of the disk is considered to be
-     * "outside" (see glu.quadricOrientation).  This means that if the orientation
-     * is set to GLU.OUTSIDE, then any normals generated point along the +z axis.
-     * Otherwise, they point along the -z axis.
-     *
-     * If texturing is turned on (with glu.quadricTexture), texture coordinates are
-     * generated linearly such that where r=outerRadius, the value at (r, 0, 0) is
-     * (1, 0.5), at (0, r, 0) it is (0.5, 1), at (-r, 0, 0) it is (0, 0.5), and at
-     * (0, -r, 0) it is (0.5, 0).
-     */
-	public void draw(float innerRadius, float outerRadius, int slices, int loops)
-	{
-	   float da, dr;
-
-	   /* Normal vectors */
-	   if (super.normals != GLU_NONE) {
-	      if (super.orientation == GLU_OUTSIDE) {
-		 glNormal3f(0.0f, 0.0f, +1.0f);
-	      }
-	      else {
-		 glNormal3f(0.0f, 0.0f, -1.0f);
-	      }
-	   }
-
-	   da = 2.0f * PI / slices;
-	   dr = (outerRadius - innerRadius) /  loops;
-
-	   switch (super.drawStyle) {
-	   case GLU_FILL:
-	      {
-		 /* texture of a gluDisk is a cut out of the texture unit square
-		  * x, y in [-outerRadius, +outerRadius]; s, t in [0, 1]
-		  * (linear mapping)
-		  */
-		 float dtc = 2.0f * outerRadius;
-		 float sa, ca;
-		 float r1 = innerRadius;
-		 int l;
-		 for (l = 0; l < loops; l++) {
-		    float r2 = r1 + dr;
-		    if (super.orientation == GLU_OUTSIDE) {
-		       int s;
-		       glBegin(GL_QUAD_STRIP);
-		       for (s = 0; s <= slices; s++) {
-			  float a;
-			  if (s == slices)
-			     a = 0.0f;
-			  else
-			     a = s * da;
-			  sa = sin(a);
-			  ca = cos(a);
-			  TXTR_COORD(0.5f + sa * r2 / dtc, 0.5f + ca * r2 / dtc);
-			  glVertex2f(r2 * sa, r2 * ca);
-			  TXTR_COORD(0.5f + sa * r1 / dtc, 0.5f + ca * r1 / dtc);
-			  glVertex2f(r1 * sa, r1 * ca);
-		       }
-		       glEnd();
-		    }
-		    else {
-		       int s;
-		       glBegin(GL_QUAD_STRIP);
-		       for (s = slices; s >= 0; s--) {
-			  float a;
-			  if (s == slices)
-			     a = 0.0f;
-			  else
-			     a = s * da;
-			  sa = sin(a);
-			  ca = cos(a);
-			  TXTR_COORD(0.5f - sa * r2 / dtc, 0.5f + ca * r2 / dtc);
-			  glVertex2f(r2 * sa, r2 * ca);
-			  TXTR_COORD(0.5f - sa * r1 / dtc, 0.5f + ca * r1 / dtc);
-			  glVertex2f(r1 * sa, r1 * ca);
-		       }
-		       glEnd();
-		    }
-		    r1 = r2;
-		 }
-		 break;
-	      }
-	   case GLU_LINE:
-	      {
-		 int l, s;
-		 /* draw loops */
-		 for (l = 0; l <= loops; l++) {
-		    float r = innerRadius + l * dr;
-		    glBegin(GL_LINE_LOOP);
-		    for (s = 0; s < slices; s++) {
-		       float a = s * da;
-		       glVertex2f(r * sin(a), r * cos(a));
-		    }
-		    glEnd();
-		 }
-		 /* draw spokes */
-		 for (s = 0; s < slices; s++) {
-		    float a = s * da;
-		    float x = sin(a);
-		    float y = cos(a);
-		    glBegin(GL_LINE_STRIP);
-		    for (l = 0; l <= loops; l++) {
-		       float r = innerRadius + l * dr;
-		       glVertex2f(r * x, r * y);
-		    }
-		    glEnd();
-		 }
-		 break;
-	      }
-	   case GLU_POINT:
-	      {
-		 int s;
-		 glBegin(GL_POINTS);
-		 for (s = 0; s < slices; s++) {
-		    float a = s * da;
-		    float x = sin(a);
-		    float y = cos(a);
-		    int l;
-		    for (l = 0; l <= loops; l++) {
-		       float r = innerRadius * l * dr;
-		       glVertex2f(r * x, r * y);
-		    }
-		 }
-		 glEnd();
-		 break;
-	      }
-	   case GLU_SILHOUETTE:
-	      {
-		 if (innerRadius != 0.0) {
-		    float a;
-		    glBegin(GL_LINE_LOOP);
-		    for (a = 0.0f; a < 2.0 * PI; a += da) {
-		       float x = innerRadius * sin(a);
-		       float y = innerRadius * cos(a);
-		       glVertex2f(x, y);
-		    }
-		    glEnd();
-		 }
-		 {
-		    float a;
-		    glBegin(GL_LINE_LOOP);
-		    for (a = 0; a < 2.0f * PI; a += da) {
-		       float x = outerRadius * sin(a);
-		       float y = outerRadius * cos(a);
-		       glVertex2f(x, y);
-		    }
-		    glEnd();
-		 }
-		 break;
-	      }
-	   default:
-	      return;
-	   }
-	}
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/GLU.java b/src/embeddedlibs/org/lwjglx/util/glu/GLU.java
deleted file mode 100644
index 360c21f..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/GLU.java
+++ /dev/null
@@ -1,430 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.glu;
-
-import java.nio.ByteBuffer;
-import java.nio.FloatBuffer;
-import java.nio.IntBuffer;
-
-import org.lwjglx.util.glu.tessellation.GLUtessellatorImpl;
-import org.lwjglx.opengl.Util;
-
-import static org.lwjgl.opengl.GL11.*;
-
-/**
- * GLU.java
- *
- *
- * Created 23-dec-2003
- * @author Erik Duijs
- */
-public class GLU {
-	static final float PI = (float)Math.PI;
-
-	/* Errors: (return value 0 = no error) */
-	public static final int GLU_INVALID_ENUM        = 100900;
-	public static final int GLU_INVALID_VALUE       = 100901;
-	public static final int GLU_OUT_OF_MEMORY       = 100902;
-	public static final int GLU_INCOMPATIBLE_GL_VERSION     = 100903;
-
-	/* StringName */
-	public static final int GLU_VERSION             = 100800;
-	public static final int GLU_EXTENSIONS          = 100801;
-
-	/* Boolean */
-	public static final boolean GLU_TRUE                = true;
-	public static final boolean GLU_FALSE               = false;
-
-
-	/****           Quadric constants               ****/
-
-	/* QuadricNormal */
-	public static final int GLU_SMOOTH              = 100000;
-	public static final int GLU_FLAT                = 100001;
-	public static final int GLU_NONE                = 100002;
-
-	/* QuadricDrawStyle */
-	public static final int GLU_POINT               = 100010;
-	public static final int GLU_LINE                = 100011;
-	public static final int GLU_FILL                = 100012;
-	public static final int GLU_SILHOUETTE          = 100013;
-
-	/* QuadricOrientation */
-	public static final int GLU_OUTSIDE             = 100020;
-	public static final int GLU_INSIDE              = 100021;
-
-	/* Callback types: */
-	/*      ERROR               = 100103 */
-
-
-	/****           Tesselation constants           ****/
-
-	public static final double GLU_TESS_MAX_COORD              = 1.0e150;
-	public static final double TESS_MAX_COORD              = 1.0e150;
-
-	/* TessProperty */
-	public static final int GLU_TESS_WINDING_RULE           = 100140;
-	public static final int GLU_TESS_BOUNDARY_ONLY          = 100141;
-	public static final int GLU_TESS_TOLERANCE              = 100142;
-
-	/* TessWinding */
-	public static final int GLU_TESS_WINDING_ODD            = 100130;
-	public static final int GLU_TESS_WINDING_NONZERO        = 100131;
-	public static final int GLU_TESS_WINDING_POSITIVE       = 100132;
-	public static final int GLU_TESS_WINDING_NEGATIVE       = 100133;
-	public static final int GLU_TESS_WINDING_ABS_GEQ_TWO    = 100134;
-
-	/* TessCallback */
-	public static final int GLU_TESS_BEGIN          = 100100;  /* void (CALLBACK*)(GLenum    type)  */
-	public static final int GLU_TESS_VERTEX         = 100101;  /* void (CALLBACK*)(void      *data) */
-	public static final int GLU_TESS_END            = 100102;  /* void (CALLBACK*)(void)            */
-	public static final int GLU_TESS_ERROR          = 100103;  /* void (CALLBACK*)(GLenum    errno) */
-	public static final int GLU_TESS_EDGE_FLAG      = 100104;  /* void (CALLBACK*)(GLboolean boundaryEdge)  */
-	public static final int GLU_TESS_COMBINE        = 100105;  /* void (CALLBACK*)(GLdouble  coords[3],
-	                                                            void      *data[4],
-	                                                            GLfloat   weight[4],
-	                                                            void      **dataOut)     */
-	public static final int GLU_TESS_BEGIN_DATA     = 100106;  /* void (CALLBACK*)(GLenum    type,
-	                                                            void      *polygon_data) */
-	public static final int GLU_TESS_VERTEX_DATA    = 100107;  /* void (CALLBACK*)(void      *data,
-	                                                            void      *polygon_data) */
-	public static final int GLU_TESS_END_DATA       = 100108;  /* void (CALLBACK*)(void      *polygon_data) */
-	public static final int GLU_TESS_ERROR_DATA     = 100109;  /* void (CALLBACK*)(GLenum    errno,
-	                                                            void      *polygon_data) */
-	public static final int GLU_TESS_EDGE_FLAG_DATA = 100110;  /* void (CALLBACK*)(GLboolean boundaryEdge,
-	                                                            void      *polygon_data) */
-	public static final int GLU_TESS_COMBINE_DATA   = 100111;  /* void (CALLBACK*)(GLdouble  coords[3],
-	                                                            void      *data[4],
-	                                                            GLfloat   weight[4],
-	                                                            void      **dataOut,
-	                                                            void      *polygon_data) */
-
-	/* TessError */
-	public static final int GLU_TESS_ERROR1     = 100151;
-	public static final int GLU_TESS_ERROR2     = 100152;
-	public static final int GLU_TESS_ERROR3     = 100153;
-	public static final int GLU_TESS_ERROR4     = 100154;
-	public static final int GLU_TESS_ERROR5     = 100155;
-	public static final int GLU_TESS_ERROR6     = 100156;
-	public static final int GLU_TESS_ERROR7     = 100157;
-	public static final int GLU_TESS_ERROR8     = 100158;
-
-	public static final int GLU_TESS_MISSING_BEGIN_POLYGON  = GLU_TESS_ERROR1;
-	public static final int GLU_TESS_MISSING_BEGIN_CONTOUR  = GLU_TESS_ERROR2;
-	public static final int GLU_TESS_MISSING_END_POLYGON    = GLU_TESS_ERROR3;
-	public static final int GLU_TESS_MISSING_END_CONTOUR    = GLU_TESS_ERROR4;
-	public static final int GLU_TESS_COORD_TOO_LARGE        = GLU_TESS_ERROR5;
-	public static final int GLU_TESS_NEED_COMBINE_CALLBACK  = GLU_TESS_ERROR6;
-
-	/****           NURBS constants                 ****/
-
-	/* NurbsProperty */
-	public static final int GLU_AUTO_LOAD_MATRIX    = 100200;
-	public static final int GLU_CULLING             = 100201;
-	public static final int GLU_SAMPLING_TOLERANCE  = 100203;
-	public static final int GLU_DISPLAY_MODE        = 100204;
-	public static final int GLU_PARAMETRIC_TOLERANCE        = 100202;
-	public static final int GLU_SAMPLING_METHOD             = 100205;
-	public static final int GLU_U_STEP                      = 100206;
-	public static final int GLU_V_STEP                      = 100207;
-
-	/* NurbsSampling */
-	public static final int GLU_PATH_LENGTH                 = 100215;
-	public static final int GLU_PARAMETRIC_ERROR            = 100216;
-	public static final int GLU_DOMAIN_DISTANCE             = 100217;
-
-
-	/* NurbsTrim */
-	public static final int GLU_MAP1_TRIM_2         = 100210;
-	public static final int GLU_MAP1_TRIM_3         = 100211;
-
-	/* NurbsDisplay */
-	/*      FILL                = 100012 */
-	public static final int GLU_OUTLINE_POLYGON     = 100240;
-	public static final int GLU_OUTLINE_PATCH       = 100241;
-
-	/* NurbsCallback */
-	/*      ERROR               = 100103 */
-
-	/* NurbsErrors */
-	public static final int GLU_NURBS_ERROR1        = 100251;
-	public static final int GLU_NURBS_ERROR2        = 100252;
-	public static final int GLU_NURBS_ERROR3        = 100253;
-	public static final int GLU_NURBS_ERROR4        = 100254;
-	public static final int GLU_NURBS_ERROR5        = 100255;
-	public static final int GLU_NURBS_ERROR6        = 100256;
-	public static final int GLU_NURBS_ERROR7        = 100257;
-	public static final int GLU_NURBS_ERROR8        = 100258;
-	public static final int GLU_NURBS_ERROR9        = 100259;
-	public static final int GLU_NURBS_ERROR10       = 100260;
-	public static final int GLU_NURBS_ERROR11       = 100261;
-	public static final int GLU_NURBS_ERROR12       = 100262;
-	public static final int GLU_NURBS_ERROR13       = 100263;
-	public static final int GLU_NURBS_ERROR14       = 100264;
-	public static final int GLU_NURBS_ERROR15       = 100265;
-	public static final int GLU_NURBS_ERROR16       = 100266;
-	public static final int GLU_NURBS_ERROR17       = 100267;
-	public static final int GLU_NURBS_ERROR18       = 100268;
-	public static final int GLU_NURBS_ERROR19       = 100269;
-	public static final int GLU_NURBS_ERROR20       = 100270;
-	public static final int GLU_NURBS_ERROR21       = 100271;
-	public static final int GLU_NURBS_ERROR22       = 100272;
-	public static final int GLU_NURBS_ERROR23       = 100273;
-	public static final int GLU_NURBS_ERROR24       = 100274;
-	public static final int GLU_NURBS_ERROR25       = 100275;
-	public static final int GLU_NURBS_ERROR26       = 100276;
-	public static final int GLU_NURBS_ERROR27       = 100277;
-	public static final int GLU_NURBS_ERROR28       = 100278;
-	public static final int GLU_NURBS_ERROR29       = 100279;
-	public static final int GLU_NURBS_ERROR30       = 100280;
-	public static final int GLU_NURBS_ERROR31       = 100281;
-	public static final int GLU_NURBS_ERROR32       = 100282;
-	public static final int GLU_NURBS_ERROR33       = 100283;
-	public static final int GLU_NURBS_ERROR34       = 100284;
-	public static final int GLU_NURBS_ERROR35       = 100285;
-	public static final int GLU_NURBS_ERROR36       = 100286;
-	public static final int GLU_NURBS_ERROR37       = 100287;
-
-	/* Contours types -- obsolete! */
-	public static final int GLU_CW          = 100120;
-	public static final int GLU_CCW         = 100121;
-	public static final int GLU_INTERIOR    = 100122;
-	public static final int GLU_EXTERIOR    = 100123;
-	public static final int GLU_UNKNOWN     = 100124;
-
-	/* Names without "TESS_" prefix */
-	public static final int GLU_BEGIN       = GLU_TESS_BEGIN;
-	public static final int GLU_VERTEX      = GLU_TESS_VERTEX;
-	public static final int GLU_END         = GLU_TESS_END;
-	public static final int GLU_ERROR       = GLU_TESS_ERROR;
-	public static final int GLU_EDGE_FLAG   = GLU_TESS_EDGE_FLAG;
-
-	/**
-	 * Method gluLookAt
-	 * @param eyex
-	 * @param eyey
-	 * @param eyez
-	 * @param centerx
-	 * @param centery
-	 * @param centerz
-	 * @param upx
-	 * @param upy
-	 * @param upz
-	 */
-	public static void gluLookAt(
-			float eyex,
-			float eyey,
-			float eyez,
-			float centerx,
-			float centery,
-			float centerz,
-			float upx,
-			float upy,
-			float upz) {
-
-		Project.gluLookAt(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz);
-	}
-
-	/**
-	 * Method gluOrtho2D
-	 * @param left
-	 * @param right
-	 * @param bottom
-	 * @param top
-	 */
-	public static void gluOrtho2D(
-			float left,
-			float right,
-			float bottom,
-			float top) {
-
-		glOrtho(left, right, bottom, top, -1.0, 1.0);
-	}
-
-	/**
-	 * Method gluPerspective
-	 * @param fovy
-	 * @param aspect
-	 * @param zNear
-	 * @param zFar
-	 */
-	public static void gluPerspective(
-			float fovy,
-			float aspect,
-			float zNear,
-			float zFar) {
-
-		Project.gluPerspective(fovy, aspect, zNear, zFar);
-	}
-
-	/**
-	 * Method gluProject
-	 * @param objx
-	 * @param objy
-	 * @param objz
-	 * @param modelMatrix
-	 * @param projMatrix
-	 * @param viewport
-	 * @param win_pos
-	 */
-	public static boolean gluProject(float objx, float objy, float objz,
-			FloatBuffer modelMatrix,
-			FloatBuffer projMatrix,
-			IntBuffer viewport,
-			FloatBuffer win_pos)
-	{
-		return Project.gluProject(objx, objy, objz, modelMatrix, projMatrix, viewport, win_pos);
-	}
-
-	/**
-	 * Method gluUnproject
-	 * @param winx
-	 * @param winy
-	 * @param winz
-	 * @param modelMatrix
-	 * @param projMatrix
-	 * @param viewport
-	 * @param obj_pos
-	 */
-	public static boolean gluUnProject(float winx, float winy, float winz,
-			FloatBuffer modelMatrix,
-			FloatBuffer projMatrix,
-			IntBuffer viewport,
-			FloatBuffer obj_pos)
-	{
-		return Project.gluUnProject(winx, winy, winz, modelMatrix, projMatrix, viewport, obj_pos);
-	}
-
-	/**
-	 * Method gluPickMatrix
-	 * @param x
-	 * @param y
-	 * @param width
-	 * @param height
-	 * @param viewport
-	 */
-	public static void gluPickMatrix(
-			float x,
-			float y,
-			float width,
-			float height,
-			IntBuffer viewport) {
-
-		Project.gluPickMatrix(x, y, width, height, viewport);
-	}
-
-	/**
-	 * Method gluGetString.
-	 * @param name
-	 * @return String
-	 */
-	public static String gluGetString(int name) {
-		return Registry.gluGetString(name);
-	}
-
-	/**
-	 * Method gluCheckExtension.
-	 * @param extName
-	 * @param extString
-	 * @return boolean
-	 */
-	public static boolean gluCheckExtension(String extName, String extString) {
-		return Registry.gluCheckExtension(extName, extString);
-	}
-
-	/**
-	 * Method gluBuild2DMipmaps
-	 * @param target
-	 * @param components
-	 * @param width
-	 * @param height
-	 * @param format
-	 * @param type
-	 * @param data
-	 * @return int
-	 */
-	public static int gluBuild2DMipmaps(
-			int target,
-			int components,
-			int width,
-			int height,
-			int format,
-			int type,
-			ByteBuffer data) {
-
-		return MipMap.gluBuild2DMipmaps(target, components, width, height, format, type, data);
-	}
-
-	/**
-	 * Method gluScaleImage.
-	 * @param format
-	 * @param widthIn
-	 * @param heightIn
-	 * @param typeIn
-	 * @param dataIn
-	 * @param widthOut
-	 * @param heightOut
-	 * @param typeOut
-	 * @param dataOut
-	 * @return int
-	 */
-	public static int gluScaleImage(
-			int format,
-			int widthIn,
-			int heightIn,
-			int typeIn,
-			ByteBuffer dataIn,
-			int widthOut,
-			int heightOut,
-			int typeOut,
-			ByteBuffer dataOut) {
-
-		return MipMap.gluScaleImage(format, widthIn, heightIn, typeIn, dataIn, widthOut, heightOut, typeOut, dataOut);
-	}
-
-	public static String gluErrorString(int error_code) {
-		switch (error_code) {
-			case GLU_INVALID_ENUM:
-				return "Invalid enum (glu)";
-			case GLU_INVALID_VALUE:
-				return "Invalid value (glu)";
-			case GLU_OUT_OF_MEMORY:
-				return "Out of memory (glu)";
-			default:
-				return Util.translateGLErrorString(error_code);
-		}
-	}
-
-	public static GLUtessellator gluNewTess() {
-		return new GLUtessellatorImpl();
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/GLUtessellator.java b/src/embeddedlibs/org/lwjglx/util/glu/GLUtessellator.java
deleted file mode 100644
index 0bb13dd..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/GLUtessellator.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package org.lwjglx.util.glu;
-
-public interface GLUtessellator {
-
-	void gluDeleteTess();
-
-	void gluTessProperty(int which, double value);
-
-	/* Returns tessellator property */
-	void gluGetTessProperty(int which, double[] value,
-			int value_offset); /* gluGetTessProperty() */
-
-	void gluTessNormal(double x, double y, double z);
-
-	void gluTessCallback(int which,
-			GLUtessellatorCallback aCallback);
-
-	void gluTessVertex(double[] coords, int coords_offset,
-			Object vertexData);
-
-	void gluTessBeginPolygon(Object data);
-
-	void gluTessBeginContour();
-
-	void gluTessEndContour();
-
-	void gluTessEndPolygon();
-
-	/*******************************************************/
-
-	/* Obsolete calls -- for backward compatibility */
-
-	void gluBeginPolygon();
-
-	/*ARGSUSED*/
-	void gluNextContour(int type);
-
-	void gluEndPolygon();
-
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/GLUtessellatorCallback.java b/src/embeddedlibs/org/lwjglx/util/glu/GLUtessellatorCallback.java
deleted file mode 100644
index e538c0b..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/GLUtessellatorCallback.java
+++ /dev/null
@@ -1,388 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu;
-
-/**
- * <b>GLUtessellatorCallback</b> interface provides methods that the user will
- * override to define the callbacks for a tessellation object.
- *
- * @author Eric Veach, July 1994
- * @author Java Port: Pepijn Van Eeckhoudt, July 2003
- * @author Java Port: Nathan Parker Burg, August 2003
- */
-public interface GLUtessellatorCallback {
-  /**
-   * The <b>begin</b> callback method is invoked like
-   * {@link javax.media.opengl.GL#glBegin glBegin} to indicate the start of a
-   * (triangle) primitive. The method takes a single argument of type int. If
-   * the <b>GLU_TESS_BOUNDARY_ONLY</b> property is set to <b>GL_FALSE</b>, then
-   * the argument is set to either <b>GL_TRIANGLE_FAN</b>,
-   * <b>GL_TRIANGLE_STRIP</b>, or <b>GL_TRIANGLES</b>. If the
-   * <b>GLU_TESS_BOUNDARY_ONLY</b> property is set to <b>GL_TRUE</b>, then the
-   * argument will be set to <b>GL_LINE_LOOP</b>.
-   *
-   * @param type
-   *        Specifics the type of begin/end pair being defined.  The following
-   *        values are valid:  <b>GL_TRIANGLE_FAN</b>, <b>GL_TRIANGLE_STRIP</b>,
-   *        <b>GL_TRIANGLES</b> or <b>GL_LINE_LOOP</b>.
-   *
-   * @see GLU#gluTessCallback           gluTessCallback
-   * @see #end     end
-   * @see #begin   begin
-   */
-  void begin(int type);
-
-  /**
-   * The same as the {@link #begin begin} callback method except that
-   * it takes an additional reference argument. This reference is
-   * identical to the opaque reference provided when {@link
-   * GLU#gluTessBeginPolygon gluTessBeginPolygon} was called.
-   *
-   * @param type
-   *        Specifics the type of begin/end pair being defined.  The following
-   *        values are valid:  <b>GL_TRIANGLE_FAN</b>, <b>GL_TRIANGLE_STRIP</b>,
-   *        <b>GL_TRIANGLES</b> or <b>GL_LINE_LOOP</b>.
-   * @param polygonData
-   *        Specifics a reference to user-defined data.
-   *
-   * @see GLU#gluTessCallback           gluTessCallback
-   * @see #endData endData
-   * @see #begin   begin
-   */
-  void beginData(int type, Object polygonData);
-
-
-  /**
-   * The <b>edgeFlag</b> callback method is similar to
-   * {@link javax.media.opengl.GL#glEdgeFlag glEdgeFlag}. The method takes
-   * a single boolean boundaryEdge that indicates which edges lie on the
-   * polygon boundary. If the boundaryEdge is <b>GL_TRUE</b>, then each vertex
-   * that follows begins an edge that lies on the polygon boundary, that is,
-   * an edge that separates an interior region from an exterior one. If the
-   * boundaryEdge is <b>GL_FALSE</b>, then each vertex that follows begins an
-   * edge that lies in the polygon interior. The edge flag callback (if
-   * defined) is invoked before the first vertex callback.<P>
-   *
-   * Since triangle fans and triangle strips do not support edge flags, the
-   * begin callback is not called with <b>GL_TRIANGLE_FAN</b> or
-   * <b>GL_TRIANGLE_STRIP</b> if a non-null edge flag callback is provided.
-   * (If the callback is initialized to null, there is no impact on
-   * performance). Instead, the fans and strips are converted to independent
-   * triangles.
-   *
-   * @param boundaryEdge
-   *        Specifics which edges lie on the polygon boundary.
-   *
-   * @see GLU#gluTessCallback gluTessCallback
-   * @see #edgeFlagData edgeFlagData
-   */
-  void edgeFlag(boolean boundaryEdge);
-
-
-  /**
-   * The same as the {@link #edgeFlag edgeFlage} callback method
-   * except that it takes an additional reference argument. This
-   * reference is identical to the opaque reference provided when
-   * {@link GLU#gluTessBeginPolygon gluTessBeginPolygon} was called.
-   *
-   * @param boundaryEdge
-   *        Specifics which edges lie on the polygon boundary.
-   * @param polygonData
-   *        Specifics a reference to user-defined data.
-   *
-   * @see GLU#gluTessCallback            gluTessCallback
-   * @see #edgeFlag edgeFlag
-   */
-  void edgeFlagData(boolean boundaryEdge, Object polygonData);
-
-
-  /**
-   * The <b>vertex</b> callback method is invoked between the {@link
-   * #begin begin} and {@link #end end} callback methods.  It is
-   * similar to {@link javax.media.opengl.GL#glVertex3f glVertex3f},
-   * and it defines the vertices of the triangles created by the
-   * tessellation process.  The method takes a reference as its only
-   * argument. This reference is identical to the opaque reference
-   * provided by the user when the vertex was described (see {@link
-   * GLU#gluTessVertex gluTessVertex}).
-   *
-   * @param vertexData
-   *        Specifics a reference to the vertices of the triangles created
-   *        byt the tessellatin process.
-   *
-   * @see GLU#gluTessCallback              gluTessCallback
-   * @see #vertexData vertexData
-   */
-  void vertex(Object vertexData);
-
-
-  /**
-   * The same as the {@link #vertex vertex} callback method except
-   * that it takes an additional reference argument. This reference is
-   * identical to the opaque reference provided when {@link
-   * GLU#gluTessBeginPolygon gluTessBeginPolygon} was called.
-   *
-   * @param vertexData
-   *        Specifics a reference to the vertices of the triangles created
-   *        byt the tessellatin process.
-   * @param polygonData
-   *        Specifics a reference to user-defined data.
-   *
-   * @see GLU#gluTessCallback          gluTessCallback
-   * @see #vertex vertex
-   */
-  void vertexData(Object vertexData, Object polygonData);
-
-
-  /**
-   * The end callback serves the same purpose as
-   * {@link javax.media.opengl.GL#glEnd glEnd}. It indicates the end of a
-   * primitive and it takes no arguments.
-   *
-   * @see GLU#gluTessCallback           gluTessCallback
-   * @see #begin   begin
-   * @see #endData endData
-   */
-  void end();
-
-
-  /**
-   * The same as the {@link #end end} callback method except that it
-   * takes an additional reference argument. This reference is
-   * identical to the opaque reference provided when {@link
-   * GLU#gluTessBeginPolygon gluTessBeginPolygon} was called.
-   *
-   * @param polygonData
-   *        Specifics a reference to user-defined data.
-   *
-   * @see GLU#gluTessCallback             gluTessCallback
-   * @see #beginData beginData
-   * @see #end       end
-   */
-  void endData(Object polygonData);
-
-
-  /**
-   * The <b>combine</b> callback method is called to create a new vertex when
-   * the tessellation detects an intersection, or wishes to merge features. The
-   * method takes four arguments: an array of three elements each of type
-   * double, an array of four references, an array of four elements each of
-   * type float, and a reference to a reference.<P>
-   *
-   * The vertex is defined as a linear combination of up to four existing
-   * vertices, stored in <i>data</i>. The coefficients of the linear combination
-   * are given by <i>weight</i>; these weights always add up to 1. All vertex
-   * pointers are valid even when some of the weights are 0. <i>coords</i> gives
-   * the location of the new vertex.<P>
-   *
-   * The user must allocate another vertex, interpolate parameters using
-   * <i>data</i> and <i>weight</i>, and return the new vertex pointer in
-   * <i>outData</i>. This handle is supplied during rendering callbacks. The
-   * user is responsible for freeing the memory some time after
-   * {@link GLU#gluTessEndPolygon gluTessEndPolygon} is
-   * called.<P>
-   *
-   * For example, if the polygon lies in an arbitrary plane in 3-space, and a
-   * color is associated with each vertex, the <b>GLU_TESS_COMBINE</b>
-   * callback might look like this:
-   * </UL>
-   * <PRE>
-   *         void myCombine(double[] coords, Object[] data,
-   *                        float[] weight, Object[] outData)
-   *         {
-   *            MyVertex newVertex = new MyVertex();
-   *
-   *            newVertex.x = coords[0];
-   *            newVertex.y = coords[1];
-   *            newVertex.z = coords[2];
-   *            newVertex.r = weight[0]*data[0].r +
-   *                          weight[1]*data[1].r +
-   *                          weight[2]*data[2].r +
-   *                          weight[3]*data[3].r;
-   *            newVertex.g = weight[0]*data[0].g +
-   *                          weight[1]*data[1].g +
-   *                          weight[2]*data[2].g +
-   *                          weight[3]*data[3].g;
-   *            newVertex.b = weight[0]*data[0].b +
-   *                          weight[1]*data[1].b +
-   *                          weight[2]*data[2].b +
-   *                          weight[3]*data[3].b;
-   *            newVertex.a = weight[0]*data[0].a +
-   *                          weight[1]*data[1].a +
-   *                          weight[2]*data[2].a +
-   *                          weight[3]*data[3].a;
-   *            outData = newVertex;
-   *         }</PRE>
-   *
-   * @param coords
-   *        Specifics the location of the new vertex.
-   * @param data
-   *        Specifics the vertices used to create the new vertex.
-   * @param weight
-   *        Specifics the weights used to create the new vertex.
-   * @param outData
-   *        Reference user the put the coodinates of the new vertex.
-   *
-   * @see GLU#gluTessCallback               gluTessCallback
-   * @see #combineData combineData
-   */
-  void combine(double[] coords, Object[] data,
-               float[] weight, Object[] outData);
-
-
-  /**
-   * The same as the {@link #combine combine} callback method except
-   * that it takes an additional reference argument. This reference is
-   * identical to the opaque reference provided when {@link
-   * GLU#gluTessBeginPolygon gluTessBeginPolygon} was called.
-   *
-   * @param coords
-   *        Specifics the location of the new vertex.
-   * @param data
-   *        Specifics the vertices used to create the new vertex.
-   * @param weight
-   *        Specifics the weights used to create the new vertex.
-   * @param outData
-   *        Reference user the put the coodinates of the new vertex.
-   * @param polygonData
-   *        Specifics a reference to user-defined data.
-   *
-   * @see GLU#gluTessCallback           gluTessCallback
-   * @see #combine combine
-   */
-  void combineData(double[] coords, Object[] data,
-                   float[] weight, Object[] outData,
-                   Object polygonData);
-
-
-  /**
-   * The <b>error</b> callback method is called when an error is encountered.
-   * The one argument is of type int; it indicates the specific error that
-   * occurred and will be set to one of <b>GLU_TESS_MISSING_BEGIN_POLYGON</b>,
-   * <b>GLU_TESS_MISSING_END_POLYGON</b>, <b>GLU_TESS_MISSING_BEGIN_CONTOUR</b>,
-   * <b>GLU_TESS_MISSING_END_CONTOUR</b>, <b>GLU_TESS_COORD_TOO_LARGE</b>,
-   * <b>GLU_TESS_NEED_COMBINE_CALLBACK</b> or <b>GLU_OUT_OF_MEMORY</b>.
-   * Character strings describing these errors can be retrieved with the
-   * {@link GLU#gluErrorString gluErrorString} call.<P>
-   *
-   * The GLU library will recover from the first four errors by inserting the
-   * missing call(s). <b>GLU_TESS_COORD_TOO_LARGE</b> indicates that some
-   * vertex coordinate exceeded the predefined constant
-   * <b>GLU_TESS_MAX_COORD</b> in absolute value, and that the value has been
-   * clamped. (Coordinate values must be small enough so that two can be
-   * multiplied together without overflow.)
-   * <b>GLU_TESS_NEED_COMBINE_CALLBACK</b> indicates that the tessellation
-   * detected an intersection between two edges in the input data, and the
-   * <b>GLU_TESS_COMBINE</b> or <b>GLU_TESS_COMBINE_DATA</b> callback was not
-   * provided. No output is generated. <b>GLU_OUT_OF_MEMORY</b> indicates that
-   * there is not enough memory so no output is generated.
-   *
-   * @param errnum
-   *        Specifics the error number code.
-   *
-   * @see GLU#gluTessCallback             gluTessCallback
-   * @see #errorData errorData
-   */
-  void error(int errnum);
-
-
-  /**
-   * The same as the {@link #error error} callback method except that
-   * it takes an additional reference argument. This reference is
-   * identical to the opaque reference provided when {@link
-   * GLU#gluTessBeginPolygon gluTessBeginPolygon} was called.
-   *
-   * @param errnum
-   *        Specifics the error number code.
-   * @param polygonData
-   *        Specifics a reference to user-defined data.
-   *
-   * @see GLU#gluTessCallback         gluTessCallback
-   * @see #error error
-   */
-  void errorData(int errnum, Object polygonData);
-
-  //void mesh(com.sun.opengl.impl.tessellator.GLUmesh mesh);
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/GLUtessellatorCallbackAdapter.java b/src/embeddedlibs/org/lwjglx/util/glu/GLUtessellatorCallbackAdapter.java
deleted file mode 100644
index 28facfe..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/GLUtessellatorCallbackAdapter.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu;
-
-/**
- * The <b>GLUtessellatorCallbackAdapter</b> provides a default implementation of
- * {@link GLUtessellatorCallback GLUtessellatorCallback}
- * with empty callback methods.  This class can be extended to provide user
- * defined callback methods.
- *
- * @author Eric Veach, July 1994
- * @author Java Port: Pepijn Van Eechhoudt, July 2003
- * @author Java Port: Nathan Parker Burg, August 2003
- */
-
-public class GLUtessellatorCallbackAdapter implements GLUtessellatorCallback {
-    public void begin(int type) {}
-    public void edgeFlag(boolean boundaryEdge) {}
-    public void vertex(Object vertexData) {}
-    public void end() {}
-//  public void mesh(com.sun.opengl.impl.tessellator.GLUmesh mesh) {}
-    public void error(int errnum) {}
-    public void combine(double[] coords, Object[] data,
-                            float[] weight, Object[] outData) {}
-    public void beginData(int type, Object polygonData) {}
-    public void edgeFlagData(boolean boundaryEdge,
-                                 Object polygonData) {}
-    public void vertexData(Object vertexData, Object polygonData) {}
-    public void endData(Object polygonData) {}
-    public void errorData(int errnum, Object polygonData) {}
-    public void combineData(double[] coords, Object[] data,
-                                float[] weight, Object[] outData,
-                                Object polygonData) {}
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/MipMap.java b/src/embeddedlibs/org/lwjglx/util/glu/MipMap.java
deleted file mode 100644
index fc9003e..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/MipMap.java
+++ /dev/null
@@ -1,353 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.glu;
-
-import java.nio.ByteBuffer;
-
-import org.lwjglx.BufferUtils;
-
-import static org.lwjgl.opengl.GL11.*;
-import static org.lwjglx.util.glu.GLU.*;
-
-/**
- * MipMap.java
- *
- *
- * Created 11-jan-2004
- * @author Erik Duijs
- */
-public class MipMap extends Util {
-
-	/**
-	 * Method gluBuild2DMipmaps
-	 *
-	 * @param target
-	 * @param components
-	 * @param width
-	 * @param height
-	 * @param format
-	 * @param type
-	 * @param data
-	 * @return int
-	 */
-	public static int gluBuild2DMipmaps(final int target,
-	                                    final int components, final int width, final int height,
-	                                    final int format, final int type, final ByteBuffer data) {
-		if ( width < 1 || height < 1 ) return GLU_INVALID_VALUE;
-
-		final int bpp = bytesPerPixel(format, type);
-		if ( bpp == 0 )
-			return GLU_INVALID_ENUM;
-
-		final int maxSize = glGetIntegerv(GL_MAX_TEXTURE_SIZE);
-
-		int w = nearestPower(width);
-		if ( w > maxSize )
-			w = maxSize;
-
-		int h = nearestPower(height);
-		if ( h > maxSize )
-			h = maxSize;
-
-		// Get current glPixelStore state
-		PixelStoreState pss = new PixelStoreState();
-
-		// set pixel packing
-		glPixelStorei(GL_PACK_ROW_LENGTH, 0);
-		glPixelStorei(GL_PACK_ALIGNMENT, 1);
-		glPixelStorei(GL_PACK_SKIP_ROWS, 0);
-		glPixelStorei(GL_PACK_SKIP_PIXELS, 0);
-
-		ByteBuffer image;
-		int retVal = 0;
-		boolean done = false;
-
-		if ( w != width || h != height ) {
-			// must rescale image to get "top" mipmap texture image
-			image = BufferUtils.createByteBuffer((w + 4) * h * bpp);
-			int error = gluScaleImage(format, width, height, type, data, w, h, type, image);
-			if ( error != 0 ) {
-				retVal = error;
-				done = true;
-			}
-
-			/* set pixel unpacking */
-			glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
-			glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
-			glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
-			glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
-		} else {
-			image = data;
-		}
-
-		ByteBuffer bufferA = null;
-		ByteBuffer bufferB = null;
-
-		int level = 0;
-		while ( !done ) {
-			if (image != data) {
-				/* set pixel unpacking */
-				glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
-				glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
-				glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
-				glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
-			}
-
-			glTexImage2D(target, level, components, w, h, 0, format, type, image);
-
-			if ( w == 1 && h == 1 )
-				break;
-
-			final int newW = (w < 2) ? 1 : w >> 1;
-			final int newH = (h < 2) ? 1 : h >> 1;
-
-			final ByteBuffer newImage;
-
-			if ( bufferA == null )
-				newImage = (bufferA = BufferUtils.createByteBuffer((newW + 4) * newH * bpp));
-			else if ( bufferB == null )
-				newImage = (bufferB = BufferUtils.createByteBuffer((newW + 4) * newH * bpp));
-			else
-				newImage = bufferB;
-
-			int error = gluScaleImage(format, w, h, type, image, newW, newH, type, newImage);
-			if ( error != 0 ) {
-				retVal = error;
-				done = true;
-			}
-
-			image = newImage;
-			if ( bufferB != null )
-				bufferB = bufferA;
-
-			w = newW;
-			h = newH;
-			level++;
-		}
-
-		// Restore original glPixelStore state
-		pss.save();
-
-		return retVal;
-	}
-
-	/**
-	 * Method gluScaleImage.
-	 * @param format
-	 * @param widthIn
-	 * @param heightIn
-	 * @param typein
-	 * @param dataIn
-	 * @param widthOut
-	 * @param heightOut
-	 * @param typeOut
-	 * @param dataOut
-	 * @return int
-	 */
-	public static int gluScaleImage(int format,
-	                                int widthIn, int heightIn, int typein, ByteBuffer dataIn,
-	                                int widthOut, int heightOut, int typeOut, ByteBuffer dataOut) {
-
-		final int components = compPerPix(format);
-		if ( components == -1 )
-			return GLU_INVALID_ENUM;
-
-		int i, j, k;
-		float[] tempIn, tempOut;
-		float sx, sy;
-		int sizein, sizeout;
-		int rowstride, rowlen;
-
-		// temp image data
-		tempIn = new float[widthIn * heightIn * components];
-		tempOut = new float[widthOut * heightOut * components];
-
-		// Determine bytes per input type
-		switch ( typein ) {
-			case GL_UNSIGNED_BYTE:
-				sizein = 1;
-				break;
-			case GL_FLOAT:
-				sizein = 4;
-				break;
-			default:
-				return GL_INVALID_ENUM;
-		}
-
-		// Determine bytes per output type
-		switch ( typeOut ) {
-			case GL_UNSIGNED_BYTE:
-				sizeout = 1;
-				break;
-			case GL_FLOAT:
-				sizeout = 4;
-				break;
-			default:
-				return GL_INVALID_ENUM;
-		}
-
-		// Get glPixelStore state
-		PixelStoreState pss = new PixelStoreState();
-
-		//Unpack the pixel data and convert to floating point
-		if ( pss.unpackRowLength > 0 )
-			rowlen = pss.unpackRowLength;
-		else
-			rowlen = widthIn;
-
-		if ( sizein >= pss.unpackAlignment )
-			rowstride = components * rowlen;
-		else
-			rowstride = pss.unpackAlignment / sizein * ceil(components * rowlen * sizein, pss.unpackAlignment);
-
-		switch ( typein ) {
-			case GL_UNSIGNED_BYTE:
-				k = 0;
-				dataIn.rewind();
-				for ( i = 0; i < heightIn; i++ ) {
-					int ubptr = i * rowstride + pss.unpackSkipRows * rowstride + pss.unpackSkipPixels * components;
-					for ( j = 0; j < widthIn * components; j++ ) {
-						tempIn[k++] = dataIn.get(ubptr++) & 0xff;
-					}
-				}
-				break;
-			case GL_FLOAT:
-				k = 0;
-				dataIn.rewind();
-				for ( i = 0; i < heightIn; i++ )
-				{
-					int fptr = 4 * (i * rowstride + pss.unpackSkipRows * rowstride + pss.unpackSkipPixels * components);
-					for ( j = 0; j < widthIn * components; j++ )
-					{
-						tempIn[k++] = dataIn.getFloat(fptr);
-						fptr += 4;
-					}
-				}
-				break;
-			default:
-				return GLU_INVALID_ENUM;
-		}
-
-		// Do scaling
-		sx = (float)widthIn / (float)widthOut;
-		sy = (float)heightIn / (float)heightOut;
-
-		float[] c = new float[components];
-		int src, dst;
-
-		for ( int iy = 0; iy < heightOut; iy++ ) {
-			for ( int ix = 0; ix < widthOut; ix++ ) {
-				int x0 = (int)(ix * sx);
-				int x1 = (int)((ix + 1) * sx);
-				int y0 = (int)(iy * sy);
-				int y1 = (int)((iy + 1) * sy);
-
-				int readPix = 0;
-
-				// reset weighted pixel
-				for ( int ic = 0; ic < components; ic++ ) {
-					c[ic] = 0;
-				}
-
-				// create weighted pixel
-				for ( int ix0 = x0; ix0 < x1; ix0++ ) {
-					for ( int iy0 = y0; iy0 < y1; iy0++ ) {
-
-						src = (iy0 * widthIn + ix0) * components;
-
-						for ( int ic = 0; ic < components; ic++ ) {
-							c[ic] += tempIn[src + ic];
-						}
-
-						readPix++;
-					}
-				}
-
-				// store weighted pixel
-				dst = (iy * widthOut + ix) * components;
-
-				if ( readPix == 0 ) {
-					// Image is sized up, caused by non power of two texture as input
-					src = (y0 * widthIn + x0) * components;
-					for ( int ic = 0; ic < components; ic++ ) {
-						tempOut[dst++] = tempIn[src + ic];
-					}
-				} else {
-					// sized down
-					for ( k = 0; k < components; k++ ) {
-						tempOut[dst++] = c[k] / readPix;
-					}
-				}
-			}
-		}
-
-
-		// Convert temp output
-		if ( pss.packRowLength > 0 )
-			rowlen = pss.packRowLength;
-		else
-			rowlen = widthOut;
-
-		if ( sizeout >= pss.packAlignment )
-			rowstride = components * rowlen;
-		else
-			rowstride = pss.packAlignment / sizeout * ceil(components * rowlen * sizeout, pss.packAlignment);
-
-		switch ( typeOut ) {
-			case GL_UNSIGNED_BYTE:
-				k = 0;
-				for ( i = 0; i < heightOut; i++ ) {
-					int ubptr = i * rowstride + pss.packSkipRows * rowstride + pss.packSkipPixels * components;
-
-					for ( j = 0; j < widthOut * components; j++ ) {
-						dataOut.put(ubptr++, (byte)tempOut[k++]);
-					}
-				}
-				break;
-			case GL_FLOAT:
-				k = 0;
-				for ( i = 0; i < heightOut; i++ ) {
-					int fptr = 4 * (i * rowstride + pss.unpackSkipRows * rowstride + pss.unpackSkipPixels * components);
-
-					for ( j = 0; j < widthOut * components; j++ ) {
-						dataOut.putFloat(fptr, tempOut[k++]);
-						fptr += 4;
-					}
-				}
-				break;
-			default:
-				return GLU_INVALID_ENUM;
-		}
-
-		return 0;
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/PartialDisk.java b/src/embeddedlibs/org/lwjglx/util/glu/PartialDisk.java
deleted file mode 100644
index 2cfc612..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/PartialDisk.java
+++ /dev/null
@@ -1,358 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.glu;
-
-import static org.lwjgl.opengl.GL11.*;
-import static org.lwjglx.util.glu.GLU.*;
-
-/**
- * PartialDisk.java
- *
- *
- * Created 23-dec-2003
- *
- * @author Erik Duijs
- */
-public class PartialDisk extends Quadric {
-
-	private static final int CACHE_SIZE = 240;
-
-	/**
-	 * Constructor for PartialDisk.
-	 */
-	public PartialDisk() {
-		super();
-	}
-
-	/**
-	 * renders a partial disk on the z=0 plane. A partial disk is similar to a
-	 * full disk, except that only the subset of the disk from startAngle
-	 * through startAngle + sweepAngle is included (where 0 degrees is along
-	 * the +y axis, 90 degrees along the +x axis, 180 along the -y axis, and
-	 * 270 along the -x axis).
-	 *
-	 * The partial disk has a radius of outerRadius, and contains a concentric
-	 * circular hole with a radius of innerRadius. If innerRadius is zero, then
-	 * no hole is generated. The partial disk is subdivided around the z axis
-	 * into slices (like pizza slices), and also about the z axis into rings
-	 * (as specified by slices and loops, respectively).
-	 *
-	 * With respect to orientation, the +z side of the partial disk is
-	 * considered to be outside (see gluQuadricOrientation). This means that if
-	 * the orientation is set to GLU.GLU_OUTSIDE, then any normals generated point
-	 * along the +z axis. Otherwise, they point along the -z axis.
-	 *
-	 * If texturing is turned on (with gluQuadricTexture), texture coordinates
-	 * are generated linearly such that where r=outerRadius, the value at (r, 0, 0)
-	 * is (1, 0.5), at (0, r, 0) it is (0.5, 1), at (-r, 0, 0) it is (0, 0.5),
-	 * and at (0, -r, 0) it is (0.5, 0).
-	 */
-	public void draw(
-		float innerRadius,
-		float outerRadius,
-		int slices,
-		int loops,
-		float startAngle,
-		float sweepAngle) {
-
-		int i, j;
-		float[] sinCache = new float[CACHE_SIZE];
-		float[] cosCache = new float[CACHE_SIZE];
-		float angle;
-		float sintemp, costemp;
-		float deltaRadius;
-		float radiusLow, radiusHigh;
-		float texLow = 0, texHigh = 0;
-		float angleOffset;
-		int slices2;
-		int finish;
-
-		if (slices >= CACHE_SIZE)
-			slices = CACHE_SIZE - 1;
-		if (slices < 2
-			|| loops < 1
-			|| outerRadius <= 0.0f
-			|| innerRadius < 0.0f
-			|| innerRadius > outerRadius) {
-			//gluQuadricError(qobj, GLU.GLU_INVALID_VALUE);
-			System.err.println("PartialDisk: GLU_INVALID_VALUE");
-			return;
-		}
-
-		if (sweepAngle < -360.0f)
-			sweepAngle = 360.0f;
-		if (sweepAngle > 360.0f)
-			sweepAngle = 360.0f;
-		if (sweepAngle < 0) {
-			startAngle += sweepAngle;
-			sweepAngle = -sweepAngle;
-		}
-
-		if (sweepAngle == 360.0f) {
-			slices2 = slices;
-		} else {
-			slices2 = slices + 1;
-		}
-
-		/* Compute length (needed for normal calculations) */
-		deltaRadius = outerRadius - innerRadius;
-
-		/* Cache is the vertex locations cache */
-
-		angleOffset = startAngle / 180.0f * PI;
-		for (i = 0; i <= slices; i++) {
-			angle = angleOffset + ((PI * sweepAngle) / 180.0f) * i / slices;
-			sinCache[i] = sin(angle);
-			cosCache[i] = cos(angle);
-		}
-
-		if (sweepAngle == 360.0f) {
-			sinCache[slices] = sinCache[0];
-			cosCache[slices] = cosCache[0];
-		}
-
-		switch (super.normals) {
-			case GLU_FLAT :
-			case GLU_SMOOTH :
-				if (super.orientation == GLU_OUTSIDE) {
-					glNormal3f(0.0f, 0.0f, 1.0f);
-				} else {
-					glNormal3f(0.0f, 0.0f, -1.0f);
-				}
-				break;
-			default :
-			case GLU_NONE :
-				break;
-		}
-
-		switch (super.drawStyle) {
-			case GLU_FILL :
-				if (innerRadius == .0f) {
-					finish = loops - 1;
-					/* Triangle strip for inner polygons */
-					glBegin(GL_TRIANGLE_FAN);
-					if (super.textureFlag) {
-						glTexCoord2f(0.5f, 0.5f);
-					}
-					glVertex3f(0.0f, 0.0f, 0.0f);
-					radiusLow = outerRadius - deltaRadius * ((float) (loops - 1) / loops);
-					if (super.textureFlag) {
-						texLow = radiusLow / outerRadius / 2;
-					}
-
-					if (super.orientation == GLU_OUTSIDE) {
-						for (i = slices; i >= 0; i--) {
-							if (super.textureFlag) {
-								glTexCoord2f(
-									texLow * sinCache[i] + 0.5f,
-									texLow * cosCache[i] + 0.5f);
-							}
-							glVertex3f(radiusLow * sinCache[i], radiusLow * cosCache[i], 0.0f);
-						}
-					} else {
-						for (i = 0; i <= slices; i++) {
-							if (super.textureFlag) {
-								glTexCoord2f(
-									texLow * sinCache[i] + 0.5f,
-									texLow * cosCache[i] + 0.5f);
-							}
-							glVertex3f(radiusLow * sinCache[i], radiusLow * cosCache[i], 0.0f);
-						}
-					}
-					glEnd();
-				} else {
-					finish = loops;
-				}
-				for (j = 0; j < finish; j++) {
-					radiusLow = outerRadius - deltaRadius * ((float) j / loops);
-					radiusHigh = outerRadius - deltaRadius * ((float) (j + 1) / loops);
-					if (super.textureFlag) {
-						texLow = radiusLow / outerRadius / 2;
-						texHigh = radiusHigh / outerRadius / 2;
-					}
-
-					glBegin(GL_QUAD_STRIP);
-					for (i = 0; i <= slices; i++) {
-						if (super.orientation == GLU_OUTSIDE) {
-							if (super.textureFlag) {
-								glTexCoord2f(
-									texLow * sinCache[i] + 0.5f,
-									texLow * cosCache[i] + 0.5f);
-							}
-							glVertex3f(radiusLow * sinCache[i], radiusLow * cosCache[i], 0.0f);
-
-							if (super.textureFlag) {
-								glTexCoord2f(
-									texHigh * sinCache[i] + 0.5f,
-									texHigh * cosCache[i] + 0.5f);
-							}
-							glVertex3f(
-								radiusHigh * sinCache[i],
-								radiusHigh * cosCache[i],
-								0.0f);
-						} else {
-							if (super.textureFlag) {
-								glTexCoord2f(
-									texHigh * sinCache[i] + 0.5f,
-									texHigh * cosCache[i] + 0.5f);
-							}
-							glVertex3f(
-								radiusHigh * sinCache[i],
-								radiusHigh * cosCache[i],
-								0.0f);
-
-							if (super.textureFlag) {
-								glTexCoord2f(
-									texLow * sinCache[i] + 0.5f,
-									texLow * cosCache[i] + 0.5f);
-							}
-							glVertex3f(radiusLow * sinCache[i], radiusLow * cosCache[i], 0.0f);
-						}
-					}
-					glEnd();
-				}
-				break;
-			case GLU_POINT :
-				glBegin(GL_POINTS);
-				for (i = 0; i < slices2; i++) {
-					sintemp = sinCache[i];
-					costemp = cosCache[i];
-					for (j = 0; j <= loops; j++) {
-						radiusLow = outerRadius - deltaRadius * ((float) j / loops);
-
-						if (super.textureFlag) {
-							texLow = radiusLow / outerRadius / 2;
-
-							glTexCoord2f(
-								texLow * sinCache[i] + 0.5f,
-								texLow * cosCache[i] + 0.5f);
-						}
-						glVertex3f(radiusLow * sintemp, radiusLow * costemp, 0.0f);
-					}
-				}
-				glEnd();
-				break;
-			case GLU_LINE :
-				if (innerRadius == outerRadius) {
-					glBegin(GL_LINE_STRIP);
-
-					for (i = 0; i <= slices; i++) {
-						if (super.textureFlag) {
-							glTexCoord2f(sinCache[i] / 2 + 0.5f, cosCache[i] / 2 + 0.5f);
-						}
-						glVertex3f(innerRadius * sinCache[i], innerRadius * cosCache[i], 0.0f);
-					}
-					glEnd();
-					break;
-				}
-				for (j = 0; j <= loops; j++) {
-					radiusLow = outerRadius - deltaRadius * ((float) j / loops);
-					if (super.textureFlag) {
-						texLow = radiusLow / outerRadius / 2;
-					}
-
-					glBegin(GL_LINE_STRIP);
-					for (i = 0; i <= slices; i++) {
-						if (super.textureFlag) {
-							glTexCoord2f(
-								texLow * sinCache[i] + 0.5f,
-								texLow * cosCache[i] + 0.5f);
-						}
-						glVertex3f(radiusLow * sinCache[i], radiusLow * cosCache[i], 0.0f);
-					}
-					glEnd();
-				}
-				for (i = 0; i < slices2; i++) {
-					sintemp = sinCache[i];
-					costemp = cosCache[i];
-					glBegin(GL_LINE_STRIP);
-					for (j = 0; j <= loops; j++) {
-						radiusLow = outerRadius - deltaRadius * ((float) j / loops);
-						if (super.textureFlag) {
-							texLow = radiusLow / outerRadius / 2;
-						}
-
-						if (super.textureFlag) {
-							glTexCoord2f(
-								texLow * sinCache[i] + 0.5f,
-								texLow * cosCache[i] + 0.5f);
-						}
-						glVertex3f(radiusLow * sintemp, radiusLow * costemp, 0.0f);
-					}
-					glEnd();
-				}
-				break;
-			case GLU_SILHOUETTE :
-				if (sweepAngle < 360.0f) {
-					for (i = 0; i <= slices; i += slices) {
-						sintemp = sinCache[i];
-						costemp = cosCache[i];
-						glBegin(GL_LINE_STRIP);
-						for (j = 0; j <= loops; j++) {
-							radiusLow = outerRadius - deltaRadius * ((float) j / loops);
-
-							if (super.textureFlag) {
-								texLow = radiusLow / outerRadius / 2;
-								glTexCoord2f(
-									texLow * sinCache[i] + 0.5f,
-									texLow * cosCache[i] + 0.5f);
-							}
-							glVertex3f(radiusLow * sintemp, radiusLow * costemp, 0.0f);
-						}
-						glEnd();
-					}
-				}
-				for (j = 0; j <= loops; j += loops) {
-					radiusLow = outerRadius - deltaRadius * ((float) j / loops);
-					if (super.textureFlag) {
-						texLow = radiusLow / outerRadius / 2;
-					}
-
-					glBegin(GL_LINE_STRIP);
-					for (i = 0; i <= slices; i++) {
-						if (super.textureFlag) {
-							glTexCoord2f(
-								texLow * sinCache[i] + 0.5f,
-								texLow * cosCache[i] + 0.5f);
-						}
-						glVertex3f(radiusLow * sinCache[i], radiusLow * cosCache[i], 0.0f);
-					}
-					glEnd();
-					if (innerRadius == outerRadius)
-						break;
-				}
-				break;
-			default :
-				break;
-		}
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/PixelStoreState.java b/src/embeddedlibs/org/lwjglx/util/glu/PixelStoreState.java
deleted file mode 100644
index 12b0595..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/PixelStoreState.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.glu;
-
-import static org.lwjgl.opengl.GL11.*;
-
-/**
- * PixelStoreState.java
- *
- *
- * Created 11-jan-2004
- * @author Erik Duijs
- */
-class PixelStoreState extends Util {
-
-	public int unpackRowLength;
-	public int unpackAlignment;
-	public int unpackSkipRows;
-	public int unpackSkipPixels;
-	public int packRowLength;
-	public int packAlignment;
-	public int packSkipRows;
-	public int packSkipPixels;
-
-	/**
-	 * Constructor for PixelStoreState.
-	 */
-	PixelStoreState() {
-		super();
-		load();
-	}
-
-	public void load() {
-		unpackRowLength = glGetIntegerv(GL_UNPACK_ROW_LENGTH);
-		unpackAlignment = glGetIntegerv(GL_UNPACK_ALIGNMENT);
-		unpackSkipRows = glGetIntegerv(GL_UNPACK_SKIP_ROWS);
-		unpackSkipPixels = glGetIntegerv(GL_UNPACK_SKIP_PIXELS);
-		packRowLength = glGetIntegerv(GL_PACK_ROW_LENGTH);
-		packAlignment = glGetIntegerv(GL_PACK_ALIGNMENT);
-		packSkipRows = glGetIntegerv(GL_PACK_SKIP_ROWS);
-		packSkipPixels = glGetIntegerv(GL_PACK_SKIP_PIXELS);
-	}
-
-	public void save() {
-		glPixelStorei(GL_UNPACK_ROW_LENGTH, unpackRowLength);
-		glPixelStorei(GL_UNPACK_ALIGNMENT, unpackAlignment);
-		glPixelStorei(GL_UNPACK_SKIP_ROWS, unpackSkipRows);
-		glPixelStorei(GL_UNPACK_SKIP_PIXELS, unpackSkipPixels);
-		glPixelStorei(GL_PACK_ROW_LENGTH, packRowLength);
-		glPixelStorei(GL_PACK_ALIGNMENT, packAlignment);
-		glPixelStorei(GL_PACK_SKIP_ROWS, packSkipRows);
-		glPixelStorei(GL_PACK_SKIP_PIXELS, packSkipPixels);
-	}
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/Project.java b/src/embeddedlibs/org/lwjglx/util/glu/Project.java
deleted file mode 100644
index 87f180d..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/Project.java
+++ /dev/null
@@ -1,411 +0,0 @@
-/* 
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.glu;
-
-import java.nio.FloatBuffer;
-import java.nio.IntBuffer;
-
-import org.lwjgl.BufferUtils;
-
-import static org.lwjgl.opengl.GL11.*;
-
-/**
- * Project.java
- * <p/>
- * <p/>
- * Created 11-jan-2004
- *
- * @author Erik Duijs
- */
-public class Project extends Util {
-
-	private static final float[] IDENTITY_MATRIX =
-		new float[] {
-			1.0f, 0.0f, 0.0f, 0.0f,
-			0.0f, 1.0f, 0.0f, 0.0f,
-			0.0f, 0.0f, 1.0f, 0.0f,
-			0.0f, 0.0f, 0.0f, 1.0f };
-
-	private static final FloatBuffer matrix = BufferUtils.createFloatBuffer(16);
-	private static final FloatBuffer finalMatrix = BufferUtils.createFloatBuffer(16);
-
-	private static final FloatBuffer tempMatrix = BufferUtils.createFloatBuffer(16);
-	private static final float[] in = new float[4];
-	private static final float[] out = new float[4];
-
-	private static final float[] forward = new float[3];
-	private static final float[] side = new float[3];
-	private static final float[] up = new float[3];
-
-	/**
-	 * Make matrix an identity matrix
-	 */
-	private static void __gluMakeIdentityf(FloatBuffer m) {
-		int oldPos = m.position();
-		m.put(IDENTITY_MATRIX);
-		m.position(oldPos);
-	}
-
-	/**
-	 * Method __gluMultMatrixVecf
-	 *
-	 * @param finalMatrix
-	 * @param in
-	 * @param out
-	 */
-	private static void __gluMultMatrixVecf(FloatBuffer m, float[] in, float[] out) {
-		for (int i = 0; i < 4; i++) {
-			out[i] =
-				in[0] * m.get(m.position() + 0*4 + i)
-					+ in[1] * m.get(m.position() + 1*4 + i)
-					+ in[2] * m.get(m.position() + 2*4 + i)
-					+ in[3] * m.get(m.position() + 3*4 + i);
-
-		}
-	}
-
-	/**
-	 * @param src
-	 * @param inverse
-	 *
-	 * @return
-	 */
-	private static boolean __gluInvertMatrixf(FloatBuffer src, FloatBuffer inverse) {
-		int i, j, k, swap;
-		float t;
-		FloatBuffer temp = Project.tempMatrix;
-
-
-		for (i = 0; i < 16; i++) {
-			temp.put(i, src.get(i + src.position()));
-		}
-		__gluMakeIdentityf(inverse);
-
-		for (i = 0; i < 4; i++) {
-			/*
-			 * * Look for largest element in column
-			 */
-			swap = i;
-			for (j = i + 1; j < 4; j++) {
-				/*
-				 * if (fabs(temp[j][i]) > fabs(temp[i][i])) { swap = j;
-				 */
-				if (Math.abs(temp.get(j*4 + i)) > Math.abs(temp.get(i* 4 + i))) {
-					swap = j;
-				}
-			}
-
-			if (swap != i) {
-				/*
-				 * * Swap rows.
-				 */
-				for (k = 0; k < 4; k++) {
-					t = temp.get(i*4 + k);
-					temp.put(i*4 + k, temp.get(swap*4 + k));
-					temp.put(swap*4 + k, t);
-
-					t = inverse.get(i*4 + k);
-					inverse.put(i*4 + k, inverse.get(swap*4 + k));
-					//inverse.put((i << 2) + k, inverse.get((swap << 2) + k));
-					inverse.put(swap*4 + k, t);
-					//inverse.put((swap << 2) + k, t);
-				}
-			}
-
-			if (temp.get(i*4 + i) == 0) {
-				/*
-				 * * No non-zero pivot. The matrix is singular, which shouldn't *
-				 * happen. This means the user gave us a bad matrix.
-				 */
-				return false;
-			}
-
-			t = temp.get(i*4 + i);
-			for (k = 0; k < 4; k++) {
-				temp.put(i*4 + k, temp.get(i*4 + k)/t);
-				inverse.put(i*4 + k, inverse.get(i*4 + k)/t);
-			}
-			for (j = 0; j < 4; j++) {
-				if (j != i) {
-					t = temp.get(j*4 + i);
-					for (k = 0; k < 4; k++) {
-						temp.put(j*4 + k, temp.get(j*4 + k) - temp.get(i*4 + k) * t);
-						inverse.put(j*4 + k, inverse.get(j*4 + k) - inverse.get(i*4 + k) * t);
-						/*inverse.put(
-							(j << 2) + k,
-							inverse.get((j << 2) + k) - inverse.get((i << 2) + k) * t);*/
-					}
-				}
-			}
-		}
-		return true;
-	}
-
-	/**
-	 * @param a
-	 * @param b
-	 * @param r
-	 */
-	private static void __gluMultMatricesf(FloatBuffer a, FloatBuffer b, FloatBuffer r) {
-		for (int i = 0; i < 4; i++) {
-			for (int j = 0; j < 4; j++) {
-				r.put(r.position() + i*4 + j,
-					a.get(a.position() + i*4 + 0) * b.get(b.position() + 0*4 + j) + a.get(a.position() + i*4 + 1) * b.get(b.position() + 1*4 + j) + a.get(a.position() + i*4 + 2) * b.get(b.position() + 2*4 + j) + a.get(a.position() + i*4 + 3) * b.get(b.position() + 3*4 + j));
-			}
-		}
-	}
-
-	/**
-	 * Method gluPerspective.
-	 *
-	 * @param fovy
-	 * @param aspect
-	 * @param zNear
-	 * @param zFar
-	 */
-	public static void gluPerspective(float fovy, float aspect, float zNear, float zFar) {
-		float sine, cotangent, deltaZ;
-		float radians = fovy / 2 * GLU.PI / 180;
-
-		deltaZ = zFar - zNear;
-		sine = (float) Math.sin(radians);
-
-		if ((deltaZ == 0) || (sine == 0) || (aspect == 0)) {
-			return;
-		}
-
-		cotangent = (float) Math.cos(radians) / sine;
-
-		__gluMakeIdentityf(matrix);
-
-		matrix.put(0 * 4 + 0, cotangent / aspect);
-		matrix.put(1 * 4 + 1, cotangent);
-		matrix.put(2 * 4 + 2, - (zFar + zNear) / deltaZ);
-		matrix.put(2 * 4 + 3, -1);
-		matrix.put(3 * 4 + 2, -2 * zNear * zFar / deltaZ);
-		matrix.put(3 * 4 + 3, 0);
-
-		glMultMatrixf(matrix);
-	}
-
-	/**
-	 * Method gluLookAt
-	 *
-	 * @param eyex
-	 * @param eyey
-	 * @param eyez
-	 * @param centerx
-	 * @param centery
-	 * @param centerz
-	 * @param upx
-	 * @param upy
-	 * @param upz
-	 */
-	public static void gluLookAt(
-		float eyex,
-		float eyey,
-		float eyez,
-		float centerx,
-		float centery,
-		float centerz,
-		float upx,
-		float upy,
-		float upz) {
-		float[] forward = Project.forward;
-		float[] side = Project.side;
-		float[] up = Project.up;
-
-		forward[0] = centerx - eyex;
-		forward[1] = centery - eyey;
-		forward[2] = centerz - eyez;
-
-		up[0] = upx;
-		up[1] = upy;
-		up[2] = upz;
-
-		normalize(forward);
-
-		/* Side = forward x up */
-		cross(forward, up, side);
-		normalize(side);
-
-		/* Recompute up as: up = side x forward */
-		cross(side, forward, up);
-
-		__gluMakeIdentityf(matrix);
-		matrix.put(0 * 4 + 0, side[0]);
-		matrix.put(1 * 4 + 0, side[1]);
-		matrix.put(2 * 4 + 0, side[2]);
-
-		matrix.put(0 * 4 + 1, up[0]);
-		matrix.put(1 * 4 + 1, up[1]);
-		matrix.put(2 * 4 + 1, up[2]);
-
-		matrix.put(0 * 4 + 2, -forward[0]);
-		matrix.put(1 * 4 + 2, -forward[1]);
-		matrix.put(2 * 4 + 2, -forward[2]);
-
-		glMultMatrixf(matrix);
-		glTranslatef(-eyex, -eyey, -eyez);
-	}
-
-	/**
-	 * Method gluProject
-	 *
-	 * @param objx
-	 * @param objy
-	 * @param objz
-	 * @param modelMatrix
-	 * @param projMatrix
-	 * @param viewport
-	 * @param win_pos
-	 */
-	public static boolean gluProject(
-		float objx,
-		float objy,
-		float objz,
-		FloatBuffer modelMatrix,
-		FloatBuffer projMatrix,
-		IntBuffer viewport,
-		FloatBuffer win_pos) {
-
-		float[] in = Project.in;
-		float[] out = Project.out;
-
-		in[0] = objx;
-		in[1] = objy;
-		in[2] = objz;
-		in[3] = 1.0f;
-
-		__gluMultMatrixVecf(modelMatrix, in, out);
-		__gluMultMatrixVecf(projMatrix, out, in);
-
-		if (in[3] == 0.0)
-			return false;
-
-		in[3] = (1.0f / in[3]) * 0.5f;
-
-		// Map x, y and z to range 0-1
-		in[0] = in[0] * in[3] + 0.5f;
-		in[1] = in[1] * in[3] + 0.5f;
-		in[2] = in[2] * in[3] + 0.5f;
-
-		// Map x,y to viewport
-		win_pos.put(0, in[0] * viewport.get(viewport.position() + 2) + viewport.get(viewport.position() + 0));
-		win_pos.put(1, in[1] * viewport.get(viewport.position() + 3) + viewport.get(viewport.position() + 1));
-		win_pos.put(2, in[2]);
-
-		return true;
-	}
-
-	/**
-	 * Method gluUnproject
-	 *
-	 * @param winx
-	 * @param winy
-	 * @param winz
-	 * @param modelMatrix
-	 * @param projMatrix
-	 * @param viewport
-	 * @param obj_pos
-	 */
-	public static boolean gluUnProject(
-		float winx,
-		float winy,
-		float winz,
-		FloatBuffer modelMatrix,
-		FloatBuffer projMatrix,
-		IntBuffer viewport,
-		FloatBuffer obj_pos) {
-		float[] in = Project.in;
-		float[] out = Project.out;
-
-		__gluMultMatricesf(modelMatrix, projMatrix, finalMatrix);
-
-		if (!__gluInvertMatrixf(finalMatrix, finalMatrix))
-			return false;
-
-		in[0] = winx;
-		in[1] = winy;
-		in[2] = winz;
-		in[3] = 1.0f;
-
-		// Map x and y from window coordinates
-		in[0] = (in[0] - viewport.get(viewport.position() + 0)) / viewport.get(viewport.position() + 2);
-		in[1] = (in[1] - viewport.get(viewport.position() + 1)) / viewport.get(viewport.position() + 3);
-
-		// Map to range -1 to 1
-		in[0] = in[0] * 2 - 1;
-		in[1] = in[1] * 2 - 1;
-		in[2] = in[2] * 2 - 1;
-
-		__gluMultMatrixVecf(finalMatrix, in, out);
-
-		if (out[3] == 0.0)
-			return false;
-
-		out[3] = 1.0f / out[3];
-
-		obj_pos.put(obj_pos.position() + 0, out[0] * out[3]);
-		obj_pos.put(obj_pos.position() + 1, out[1] * out[3]);
-		obj_pos.put(obj_pos.position() + 2, out[2] * out[3]);
-
-		return true;
-	}
-
-	/**
-	 * Method gluPickMatrix
-	 *
-	 * @param x
-	 * @param y
-	 * @param deltaX
-	 * @param deltaY
-	 * @param viewport
-	 */
-	public static void gluPickMatrix(
-		float x,
-		float y,
-		float deltaX,
-		float deltaY,
-		IntBuffer viewport) {
-		if (deltaX <= 0 || deltaY <= 0) {
-			return;
-		}
-
-		/* Translate and scale the picked region to the entire window */
-		glTranslatef(
-			(viewport.get(viewport.position() + 2) - 2 * (x - viewport.get(viewport.position() + 0))) / deltaX,
-			(viewport.get(viewport.position() + 3) - 2 * (y - viewport.get(viewport.position() + 1))) / deltaY,
-			0);
-		glScalef(viewport.get(viewport.position() + 2) / deltaX, viewport.get(viewport.position() + 3) / deltaY, 1.0f);
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/Quadric.java b/src/embeddedlibs/org/lwjglx/util/glu/Quadric.java
deleted file mode 100644
index 5a508d3..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/Quadric.java
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.glu;
-
-import static org.lwjgl.opengl.GL11.*;
-import static org.lwjglx.util.glu.GLU.*;
-
-/**
- * Quadric.java
- *
- *
- * Created 22-dec-2003
- * @author Erik Duijs
- */
-public class Quadric {
-
-	protected int drawStyle;
-	protected int orientation;
-	protected boolean textureFlag;
-	protected int normals;
-
-	/**
-	 * Constructor for Quadric.
-	 */
-	public Quadric() {
-		super();
-
-		drawStyle = GLU_FILL;
-		orientation = GLU_OUTSIDE;
-		textureFlag = false;
-		normals = GLU_SMOOTH;
-	}
-
-	/**
-	 * Call glNormal3f after scaling normal to unit length.
-	 *
-	 * @param x
-	 * @param y
-	 * @param z
-	 */
-	protected void normal3f(float x, float y, float z) {
-	   float mag;
-
-	   mag = (float)Math.sqrt(x * x + y * y + z * z);
-	   if (mag > 0.00001F) {
-	      x /= mag;
-	      y /= mag;
-	      z /= mag;
-	   }
-	   glNormal3f(x, y, z);
-	}
-
-	/**
-     * specifies the draw style for quadrics.
-     *
-     * The legal values are as follows:
-     *
-     * GLU.FILL:       Quadrics are rendered with polygon primitives. The polygons
-     *                 are drawn in a counterclockwise fashion with respect to
-     *                 their normals (as defined with glu.quadricOrientation).
-     *
-     * GLU.LINE:       Quadrics are rendered as a set of lines.
-     *
-     * GLU.SILHOUETTE: Quadrics are rendered as a set of lines, except that edges
-     * 		   separating coplanar faces will not be drawn.
-     *
-     * GLU.POINT:       Quadrics are rendered as a set of points.
-     *
-	 * @param drawStyle The drawStyle to set
-	 */
-	public void setDrawStyle(int drawStyle) {
-		this.drawStyle = drawStyle;
-	}
-
-    /**
-     * specifies what kind	of normals are desired for quadrics.
-     * The legal values	are as follows:
-     *
-     * GLU.NONE:     No normals are generated.
-     *
-     * GLU.FLAT:     One normal is generated for every facet of a quadric.
-     *
-     * GLU.SMOOTH:   One normal is generated for every vertex of a quadric.  This
-     *               is the default.
-     *
-	 * @param normals The normals to set
-	 */
-	public void setNormals(int normals) {
-		this.normals = normals;
-	}
-
-    /**
-     * specifies what kind of orientation is desired for.
-     * The orientation	values are as follows:
-     *
-     * GLU.OUTSIDE:  Quadrics are drawn with normals pointing outward.
-     *
-     * GLU.INSIDE:   Normals point inward. The default is GLU.OUTSIDE.
-     *
-     * Note that the interpretation of outward and inward depends on the quadric
-     * being drawn.
-     *
-	 * @param orientation The orientation to set
-	 */
-	public void setOrientation(int orientation) {
-		this.orientation = orientation;
-	}
-
-    /**
-     * specifies if texture coordinates should be generated for
-     * quadrics rendered with qobj. If the value of textureCoords is true,
-     * then texture coordinates are generated, and if textureCoords is false,
-     * they are not.. The default is false.
-     *
-     * The manner in which texture coordinates are generated depends upon the
-     * specific quadric rendered.
-     *
-	 * @param textureFlag The textureFlag to set
-	 */
-	public void setTextureFlag(boolean textureFlag) {
-		this.textureFlag = textureFlag;
-	}
-
-
-	/**
-	 * Returns the drawStyle.
-	 * @return int
-	 */
-	public int getDrawStyle() {
-		return drawStyle;
-	}
-
-	/**
-	 * Returns the normals.
-	 * @return int
-	 */
-	public int getNormals() {
-		return normals;
-	}
-
-	/**
-	 * Returns the orientation.
-	 * @return int
-	 */
-	public int getOrientation() {
-		return orientation;
-	}
-
-	/**
-	 * Returns the textureFlag.
-	 * @return boolean
-	 */
-	public boolean getTextureFlag() {
-		return textureFlag;
-	}
-
-	protected void TXTR_COORD(float x, float y) {
-		if (textureFlag) glTexCoord2f(x,y);
-	}
-
-
-	protected float sin(float r) {
-		return (float)Math.sin(r);
-	}
-
-	protected float cos(float r) {
-		return (float)Math.cos(r);
-	}
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/Registry.java b/src/embeddedlibs/org/lwjglx/util/glu/Registry.java
deleted file mode 100644
index e49340d..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/Registry.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/* 
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.glu;
-
-import static org.lwjglx.util.glu.GLU.*;
-
-/**
- * Registry.java
- *
- *
- * Created 11-jan-2004
- * @author Erik Duijs
- */
-public class Registry extends Util {
-
-	private static final String versionString = "1.3";
-	private static final String extensionString =
-		"GLU_EXT_nurbs_tessellator " + "GLU_EXT_object_space_tess ";
-
-	/**
-	 * Method gluGetString
-	 * @param name
-	 * @return String
-	 */
-	public static String gluGetString(int name) {
-
-		if (name == GLU_VERSION) {
-			return versionString;
-		} else if (name == GLU_EXTENSIONS) {
-			return extensionString;
-		}
-		return null;
-	}
-
-	/**
-	 * Method gluCheckExtension
-	 *
-	 * @param extName is an extension name.
-	 * @param extString is a string of extensions separated by blank(s). There may or
-	 * may not be leading or trailing blank(s) in extString.
-	 * This works in cases of extensions being prefixes of another like
-	 * GL_EXT_texture and GL_EXT_texture3D.
-	 * @return boolean true if extName is found otherwise it returns false.
-	 */
-	public static boolean gluCheckExtension(String extName, String extString) {
-		if (extString == null || extName == null)
-			return false;
-
-		return extString.indexOf(extName) != -1;
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/Sphere.java b/src/embeddedlibs/org/lwjglx/util/glu/Sphere.java
deleted file mode 100644
index f14ac20..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/Sphere.java
+++ /dev/null
@@ -1,229 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.glu;
-
-import static org.lwjgl.opengl.GL11.*;
-import static org.lwjglx.util.glu.GLU.*;
-
-/**
- * Sphere.java
- *
- *
- * Created 23-dec-2003
- * @author Erik Duijs
- */
-public class Sphere extends Quadric {
-
-	/**
-	 * Constructor
-	 */
-	public Sphere() {
-		super();
-	}
-
-	/**
-	 * draws a sphere of the given	radius centered	around the origin.
-	 * The sphere is subdivided around the z axis into slices and along the z axis
-	 * into stacks (similar to lines of longitude and latitude).
-	 *
-	 * If the orientation is set to GLU.OUTSIDE (with glu.quadricOrientation), then
-	 * any normals generated point away from the center of the sphere. Otherwise,
-	 * they point toward the center of the sphere.
-
-	 * If texturing is turned on (with glu.quadricTexture), then texture
-	 * coordinates are generated so that t ranges from 0.0 at z=-radius to 1.0 at
-	 * z=radius (t increases linearly along longitudinal lines), and s ranges from
-	 * 0.0 at the +y axis, to 0.25 at the +x axis, to 0.5 at the -y axis, to 0.75
-	 * at the -x axis, and back to 1.0 at the +y axis.
-	 */
-	public void draw(float radius, int slices, int stacks) {
-		// TODO
-
-		float rho, drho, theta, dtheta;
-		float x, y, z;
-		float s, t, ds, dt;
-		int i, j, imin, imax;
-		boolean normals;
-		float nsign;
-
-		normals = super.normals != GLU_NONE;
-
-		if (super.orientation == GLU_INSIDE) {
-			nsign = -1.0f;
-		} else {
-			nsign = 1.0f;
-		}
-
-		drho = PI / stacks;
-		dtheta = 2.0f * PI / slices;
-
-		if (super.drawStyle == GLU_FILL) {
-			if (!super.textureFlag) {
-				// draw +Z end as a triangle fan
-				glBegin(GL_TRIANGLE_FAN);
-				glNormal3f(0.0f, 0.0f, 1.0f);
-				glVertex3f(0.0f, 0.0f, nsign * radius);
-				for (j = 0; j <= slices; j++) {
-					theta = (j == slices) ? 0.0f : j * dtheta;
-					x = -sin(theta) * sin(drho);
-					y = cos(theta) * sin(drho);
-					z = nsign * cos(drho);
-					if (normals) {
-						glNormal3f(x * nsign, y * nsign, z * nsign);
-					}
-					glVertex3f(x * radius, y * radius, z * radius);
-				}
-				glEnd();
-			}
-
-			ds = 1.0f / slices;
-			dt = 1.0f / stacks;
-			t = 1.0f; // because loop now runs from 0
-			if (super.textureFlag) {
-				imin = 0;
-				imax = stacks;
-			} else {
-				imin = 1;
-				imax = stacks - 1;
-			}
-
-			// draw intermediate stacks as quad strips
-			for (i = imin; i < imax; i++) {
-				rho = i * drho;
-				glBegin(GL_QUAD_STRIP);
-				s = 0.0f;
-				for (j = 0; j <= slices; j++) {
-					theta = (j == slices) ? 0.0f : j * dtheta;
-					x = -sin(theta) * sin(rho);
-					y = cos(theta) * sin(rho);
-					z = nsign * cos(rho);
-					if (normals) {
-						glNormal3f(x * nsign, y * nsign, z * nsign);
-					}
-					TXTR_COORD(s, t);
-					glVertex3f(x * radius, y * radius, z * radius);
-					x = -sin(theta) * sin(rho + drho);
-					y = cos(theta) * sin(rho + drho);
-					z = nsign * cos(rho + drho);
-					if (normals) {
-						glNormal3f(x * nsign, y * nsign, z * nsign);
-					}
-					TXTR_COORD(s, t - dt);
-					s += ds;
-					glVertex3f(x * radius, y * radius, z * radius);
-				}
-				glEnd();
-				t -= dt;
-			}
-
-			if (!super.textureFlag) {
-				// draw -Z end as a triangle fan
-				glBegin(GL_TRIANGLE_FAN);
-				glNormal3f(0.0f, 0.0f, -1.0f);
-				glVertex3f(0.0f, 0.0f, -radius * nsign);
-				rho = PI - drho;
-				s = 1.0f;
-				for (j = slices; j >= 0; j--) {
-					theta = (j == slices) ? 0.0f : j * dtheta;
-					x = -sin(theta) * sin(rho);
-					y = cos(theta) * sin(rho);
-					z = nsign * cos(rho);
-					if (normals)
-						glNormal3f(x * nsign, y * nsign, z * nsign);
-					s -= ds;
-					glVertex3f(x * radius, y * radius, z * radius);
-				}
-				glEnd();
-			}
-		} else if (
-			super.drawStyle == GLU_LINE
-				|| super.drawStyle == GLU_SILHOUETTE) {
-			// draw stack lines
-			for (i = 1;
-				i < stacks;
-				i++) { // stack line at i==stacks-1 was missing here
-				rho = i * drho;
-				glBegin(GL_LINE_LOOP);
-				for (j = 0; j < slices; j++) {
-					theta = j * dtheta;
-					x = cos(theta) * sin(rho);
-					y = sin(theta) * sin(rho);
-					z = cos(rho);
-					if (normals)
-						glNormal3f(x * nsign, y * nsign, z * nsign);
-					glVertex3f(x * radius, y * radius, z * radius);
-				}
-				glEnd();
-			}
-			// draw slice lines
-			for (j = 0; j < slices; j++) {
-				theta = j * dtheta;
-				glBegin(GL_LINE_STRIP);
-				for (i = 0; i <= stacks; i++) {
-					rho = i * drho;
-					x = cos(theta) * sin(rho);
-					y = sin(theta) * sin(rho);
-					z = cos(rho);
-					if (normals)
-						glNormal3f(x * nsign, y * nsign, z * nsign);
-					glVertex3f(x * radius, y * radius, z * radius);
-				}
-				glEnd();
-			}
-		} else if (super.drawStyle == GLU_POINT) {
-			// top and bottom-most points
-			glBegin(GL_POINTS);
-			if (normals)
-				glNormal3f(0.0f, 0.0f, nsign);
-			glVertex3f(0.0f, 0.0f, radius);
-			if (normals)
-				glNormal3f(0.0f, 0.0f, -nsign);
-			glVertex3f(0.0f, 0.0f, -radius);
-
-			// loop over stacks
-			for (i = 1; i < stacks - 1; i++) {
-				rho = i * drho;
-				for (j = 0; j < slices; j++) {
-					theta = j * dtheta;
-					x = cos(theta) * sin(rho);
-					y = sin(theta) * sin(rho);
-					z = cos(rho);
-					if (normals)
-						glNormal3f(x * nsign, y * nsign, z * nsign);
-					glVertex3f(x * radius, y * radius, z * radius);
-				}
-			}
-			glEnd();
-		}
-	}
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/Util.java b/src/embeddedlibs/org/lwjglx/util/glu/Util.java
deleted file mode 100644
index 86d9a3f..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/Util.java
+++ /dev/null
@@ -1,245 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.glu;
-
-import java.nio.IntBuffer;
-
-import org.lwjgl.BufferUtils;
-
-import static org.lwjgl.opengl.GL11.*;
-import static org.lwjgl.opengl.GL12.*;
-
-/**
- * Util.java
- * <p/>
- * <p/>
- * Created 7-jan-2004
- *
- * @author Erik Duijs
- */
-public class Util {
-	
-	/**
-	 * temp IntBuffer of one for getting an int from some GL functions
-	 */
-	private static IntBuffer scratch = BufferUtils.createIntBuffer(16);
-
-	/**
-	 * Return ceiling of integer division
-	 *
-	 * @param a
-	 * @param b
-	 *
-	 * @return int
-	 */
-	protected static int ceil(int a, int b) {
-		return (a % b == 0 ? a / b : a / b + 1);
-	}
-
-	/**
-	 * Normalize vector
-	 *
-	 * @param v
-	 *
-	 * @return float[]
-	 */
-	protected static float[] normalize(float[] v) {
-		float r;
-
-		r = (float)Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
-		if ( r == 0.0 )
-			return v;
-
-		r = 1.0f / r;
-
-		v[0] *= r;
-		v[1] *= r;
-		v[2] *= r;
-
-		return v;
-	}
-
-	/**
-	 * Calculate cross-product
-	 *
-	 * @param v1
-	 * @param v2
-	 * @param result
-	 */
-	protected static void cross(float[] v1, float[] v2, float[] result) {
-		result[0] = v1[1] * v2[2] - v1[2] * v2[1];
-		result[1] = v1[2] * v2[0] - v1[0] * v2[2];
-		result[2] = v1[0] * v2[1] - v1[1] * v2[0];
-	}
-
-	/**
-	 * Method compPerPix.
-	 *
-	 * @param format
-	 *
-	 * @return int
-	 */
-	protected static int compPerPix(int format) {
-		/* Determine number of components per pixel */
-		switch ( format ) {
-			case GL_COLOR_INDEX:
-			case GL_STENCIL_INDEX:
-			case GL_DEPTH_COMPONENT:
-			case GL_RED:
-			case GL_GREEN:
-			case GL_BLUE:
-			case GL_ALPHA:
-			case GL_LUMINANCE:
-				return 1;
-			case GL_LUMINANCE_ALPHA:
-				return 2;
-			case GL_RGB:
-			case GL_BGR:
-				return 3;
-			case GL_RGBA:
-			case GL_BGRA:
-				return 4;
-			default :
-				return -1;
-		}
-	}
-
-	/**
-	 * Method nearestPower.
-	 * <p/>
-	 * Compute the nearest power of 2 number.  This algorithm is a little strange, but it works quite well.
-	 *
-	 * @param value
-	 *
-	 * @return int
-	 */
-	protected static int nearestPower(int value) {
-		int i;
-
-		i = 1;
-
-		/* Error! */
-		if ( value == 0 )
-			return -1;
-
-		for ( ; ; ) {
-			if ( value == 1 ) {
-				return i;
-			} else if ( value == 3 ) {
-				return i << 2;
-			}
-			value >>= 1;
-			i <<= 1;
-		}
-	}
-
-	/**
-	 * Method bytesPerPixel.
-	 *
-	 * @param format
-	 * @param type
-	 *
-	 * @return int
-	 */
-	protected static int bytesPerPixel(int format, int type) {
-		int n, m;
-
-		switch ( format ) {
-			case GL_COLOR_INDEX:
-			case GL_STENCIL_INDEX:
-			case GL_DEPTH_COMPONENT:
-			case GL_RED:
-			case GL_GREEN:
-			case GL_BLUE:
-			case GL_ALPHA:
-			case GL_LUMINANCE:
-				n = 1;
-				break;
-			case GL_LUMINANCE_ALPHA:
-				n = 2;
-				break;
-			case GL_RGB:
-			case GL_BGR:
-				n = 3;
-				break;
-			case GL_RGBA:
-			case GL_BGRA:
-				n = 4;
-				break;
-			default :
-				n = 0;
-		}
-
-		switch ( type ) {
-			case GL_UNSIGNED_BYTE:
-				m = 1;
-				break;
-			case GL_BYTE:
-				m = 1;
-				break;
-			case GL_BITMAP:
-				m = 1;
-				break;
-			case GL_UNSIGNED_SHORT:
-				m = 2;
-				break;
-			case GL_SHORT:
-				m = 2;
-				break;
-			case GL_UNSIGNED_INT:
-				m = 4;
-				break;
-			case GL_INT:
-				m = 4;
-				break;
-			case GL_FLOAT:
-				m = 4;
-				break;
-			default :
-				m = 0;
-		}
-
-		return n * m;
-	}
-
-	/**
-	 * Convenience method for returning an int, rather than getting it out of a buffer yourself.
-	 *
-	 * @param what
-	 *
-	 * @return int
-	 */
-	protected static int glGetIntegerv(int what) {
-		return glGetInteger(what);
-	}
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/ActiveRegion.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/ActiveRegion.java
deleted file mode 100644
index 12be5f0..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/ActiveRegion.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-class ActiveRegion {
-    GLUhalfEdge eUp;		/* upper edge, directed right to left */
-    DictNode nodeUp;	/* dictionary node corresponding to eUp */
-    int windingNumber;	/* used to determine which regions are
-                                 * inside the polygon */
-    boolean inside;		/* is this region inside the polygon? */
-    boolean sentinel;	/* marks fake edges at t = +/-infinity */
-    boolean dirty;		/* marks regions where the upper or lower
-                                 * edge has changed, but we haven't checked
-                                 * whether they intersect yet */
-    boolean fixUpperEdge;	/* marks temporary edges introduced when
-                                 * we process a "right vertex" (one without
-                                 * any edges leaving to the right) */
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/CachedVertex.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/CachedVertex.java
deleted file mode 100644
index 1cb8ccd..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/CachedVertex.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-class CachedVertex {
-    public double[] coords = new double[3];
-    public Object data;
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Dict.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Dict.java
deleted file mode 100644
index 6be1e5d..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Dict.java
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-class Dict {
-    DictNode head;
-    Object frame;
-    DictLeq leq;
-
-    private Dict() {
-    }
-
-    static Dict dictNewDict(Object frame, DictLeq leq) {
-        Dict dict = new Dict();
-        dict.head = new DictNode();
-
-        dict.head.key = null;
-        dict.head.next = dict.head;
-        dict.head.prev = dict.head;
-
-        dict.frame = frame;
-        dict.leq = leq;
-
-        return dict;
-    }
-
-    static void dictDeleteDict(Dict dict) {
-        dict.head = null;
-        dict.frame = null;
-        dict.leq = null;
-    }
-
-    static DictNode dictInsert(Dict dict, Object key) {
-        return dictInsertBefore(dict, dict.head, key);
-    }
-
-    static DictNode dictInsertBefore(Dict dict, DictNode node, Object key) {
-        do {
-            node = node.prev;
-        } while (node.key != null && !dict.leq.leq(dict.frame, node.key, key));
-
-        DictNode newNode = new DictNode();
-        newNode.key = key;
-        newNode.next = node.next;
-        node.next.prev = newNode;
-        newNode.prev = node;
-        node.next = newNode;
-
-        return newNode;
-    }
-
-    static Object dictKey(DictNode aNode) {
-        return aNode.key;
-    }
-
-    static DictNode dictSucc(DictNode aNode) {
-        return aNode.next;
-    }
-
-    static DictNode dictPred(DictNode aNode) {
-        return aNode.prev;
-    }
-
-    static DictNode dictMin(Dict aDict) {
-        return aDict.head.next;
-    }
-
-    static DictNode dictMax(Dict aDict) {
-        return aDict.head.prev;
-    }
-
-    static void dictDelete(Dict dict, DictNode node) {
-        node.next.prev = node.prev;
-        node.prev.next = node.next;
-    }
-
-    static DictNode dictSearch(Dict dict, Object key) {
-        DictNode node = dict.head;
-
-        do {
-            node = node.next;
-        } while (node.key != null && !(dict.leq.leq(dict.frame, key, node.key)));
-
-        return node;
-    }
-
-    public interface DictLeq {
-        boolean leq(Object frame, Object key1, Object key2);
-    }
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/DictNode.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/DictNode.java
deleted file mode 100644
index 2817706..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/DictNode.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-class DictNode {
-    Object key;
-    DictNode next;
-    DictNode prev;
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/GLUface.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/GLUface.java
deleted file mode 100644
index 2bd13d1..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/GLUface.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-class GLUface {
-    public GLUface next;		/* next face (never NULL) */
-    public GLUface prev;		/* previous face (never NULL) */
-    public GLUhalfEdge anEdge;	/* a half edge with this left face */
-    public Object data;		/* room for client's data */
-
-    /* Internal data (keep hidden) */
-    public GLUface trail;		/* "stack" for conversion to strips */
-    public boolean marked;		/* flag for conversion to strips */
-    public boolean inside;		/* this face is in the polygon interior */
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/GLUhalfEdge.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/GLUhalfEdge.java
deleted file mode 100644
index 2854fd8..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/GLUhalfEdge.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-
-
-class GLUhalfEdge {
-    public GLUhalfEdge next;		/* doubly-linked list (prev==Sym->next) */
-    public GLUhalfEdge Sym;		/* same edge, opposite direction */
-    public GLUhalfEdge Onext;		/* next edge CCW around origin */
-    public GLUhalfEdge Lnext;		/* next edge CCW around left face */
-    public GLUvertex Org;		/* origin vertex (Overtex too long) */
-    public GLUface Lface;		/* left face */
-
-    /* Internal data (keep hidden) */
-    public ActiveRegion activeRegion;	/* a region with this upper edge (sweep.c) */
-    public int winding;	/* change in winding number when crossing */
-    public boolean first;
-
-    GLUhalfEdge(boolean first) {
-        this.first = first;
-    }
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/GLUmesh.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/GLUmesh.java
deleted file mode 100644
index b80d361..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/GLUmesh.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-
-
-class GLUmesh {
-    GLUvertex vHead = new GLUvertex();		/* dummy header for vertex list */
-    GLUface fHead = new GLUface();		/* dummy header for face list */
-    GLUhalfEdge eHead = new GLUhalfEdge(true);		/* dummy header for edge list */
-    GLUhalfEdge eHeadSym = new GLUhalfEdge(false);	/* and its symmetric counterpart */
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/GLUtessellatorImpl.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/GLUtessellatorImpl.java
deleted file mode 100644
index b25b9c7..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/GLUtessellatorImpl.java
+++ /dev/null
@@ -1,669 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-import org.lwjglx.util.glu.GLUtessellator;
-import org.lwjglx.util.glu.GLUtessellatorCallback;
-import org.lwjglx.util.glu.GLUtessellatorCallbackAdapter;
-
-import static org.lwjglx.util.glu.GLU.*;
-
-public class GLUtessellatorImpl implements GLUtessellator {
-    public static final int TESS_MAX_CACHE = 100;
-
-    private int state;		/* what begin/end calls have we seen? */
-
-    private GLUhalfEdge lastEdge;	/* lastEdge->Org is the most recent vertex */
-    GLUmesh mesh;		/* stores the input contours, and eventually
-                                   the tessellation itself */
-
-    /*** state needed for projecting onto the sweep plane ***/
-
-    double[] normal = new double[3];	/* user-specified normal (if provided) */
-    double[] sUnit = new double[3];	/* unit vector in s-direction (debugging) */
-    double[] tUnit = new double[3];	/* unit vector in t-direction (debugging) */
-
-    /*** state needed for the line sweep ***/
-
-    private double relTolerance;	/* tolerance for merging features */
-    int windingRule;	/* rule for determining polygon interior */
-    boolean fatalError;	/* fatal error: needed combine callback */
-
-    Dict dict;		/* edge dictionary for sweep line */
-    PriorityQ pq;		/* priority queue of vertex events */
-    GLUvertex event;		/* current sweep event being processed */
-
-    /*** state needed for rendering callbacks (see render.c) ***/
-
-    boolean flagBoundary;	/* mark boundary edges (use EdgeFlag) */
-    boolean boundaryOnly;	/* Extract contours, not triangles */
-    GLUface lonelyTriList;
-    /* list of triangles which could not be rendered as strips or fans */
-
-
-
-    /*** state needed to cache single-contour polygons for renderCache() */
-
-    private boolean flushCacheOnNextVertex;		/* empty cache on next vertex() call */
-    int cacheCount;		/* number of cached vertices */
-    CachedVertex[] cache = new CachedVertex[TESS_MAX_CACHE];	/* the vertex data */
-
-    /*** rendering callbacks that also pass polygon data  ***/
-    private Object polygonData;		/* client data for current polygon */
-
-    private GLUtessellatorCallback callBegin;
-    private GLUtessellatorCallback callEdgeFlag;
-    private GLUtessellatorCallback callVertex;
-    private GLUtessellatorCallback callEnd;
-//    private GLUtessellatorCallback callMesh;
-    private GLUtessellatorCallback callError;
-    private GLUtessellatorCallback callCombine;
-
-    private GLUtessellatorCallback callBeginData;
-    private GLUtessellatorCallback callEdgeFlagData;
-    private GLUtessellatorCallback callVertexData;
-    private GLUtessellatorCallback callEndData;
-//    private GLUtessellatorCallback callMeshData;
-    private GLUtessellatorCallback callErrorData;
-    private GLUtessellatorCallback callCombineData;
-
-    private static final double GLU_TESS_DEFAULT_TOLERANCE = 0.0;
-//    private static final int GLU_TESS_MESH = 100112;	/* void (*)(GLUmesh *mesh)	    */
-    private static GLUtessellatorCallback NULL_CB = new GLUtessellatorCallbackAdapter();
-
-//    #define MAX_FAST_ALLOC	(MAX(sizeof(EdgePair), \
-//                 MAX(sizeof(GLUvertex),sizeof(GLUface))))
-
-    public GLUtessellatorImpl() {
-        state = TessState.T_DORMANT;
-
-        normal[0] = 0;
-        normal[1] = 0;
-        normal[2] = 0;
-
-        relTolerance = GLU_TESS_DEFAULT_TOLERANCE;
-        windingRule = GLU_TESS_WINDING_ODD;
-        flagBoundary = false;
-        boundaryOnly = false;
-
-        callBegin = NULL_CB;
-        callEdgeFlag = NULL_CB;
-        callVertex = NULL_CB;
-        callEnd = NULL_CB;
-        callError = NULL_CB;
-        callCombine = NULL_CB;
-//        callMesh = NULL_CB;
-
-        callBeginData = NULL_CB;
-        callEdgeFlagData = NULL_CB;
-        callVertexData = NULL_CB;
-        callEndData = NULL_CB;
-        callErrorData = NULL_CB;
-        callCombineData = NULL_CB;
-
-        polygonData = null;
-
-        for (int i = 0; i < cache.length; i++) {
-            cache[i] = new CachedVertex();
-        }
-    }
-
-    public static GLUtessellator gluNewTess()
-    {
-        return new GLUtessellatorImpl();
-    }
-
-
-    private void makeDormant() {
-        /* Return the tessellator to its original dormant state. */
-
-        if (mesh != null) {
-            Mesh.__gl_meshDeleteMesh(mesh);
-        }
-        state = TessState.T_DORMANT;
-        lastEdge = null;
-        mesh = null;
-    }
-
-    private void requireState(int newState) {
-        if (state != newState) gotoState(newState);
-    }
-
-    private void gotoState(int newState) {
-        while (state != newState) {
-            /* We change the current state one level at a time, to get to
-             * the desired state.
-             */
-            if (state < newState) {
-                if (state == TessState.T_DORMANT) {
-                    callErrorOrErrorData(GLU_TESS_MISSING_BEGIN_POLYGON);
-                    gluTessBeginPolygon(null);
-                } else if (state == TessState.T_IN_POLYGON) {
-                    callErrorOrErrorData(GLU_TESS_MISSING_BEGIN_CONTOUR);
-                    gluTessBeginContour();
-                }
-            } else {
-                if (state == TessState.T_IN_CONTOUR) {
-                    callErrorOrErrorData(GLU_TESS_MISSING_END_CONTOUR);
-                    gluTessEndContour();
-                } else if (state == TessState.T_IN_POLYGON) {
-                    callErrorOrErrorData(GLU_TESS_MISSING_END_POLYGON);
-                    /* gluTessEndPolygon( tess ) is too much work! */
-                    makeDormant();
-                }
-            }
-        }
-    }
-
-    public void gluDeleteTess() {
-        requireState(TessState.T_DORMANT);
-    }
-
-    public void gluTessProperty(int which, double value) {
-        switch (which) {
-            case GLU_TESS_TOLERANCE:
-                if (value < 0.0 || value > 1.0) break;
-                relTolerance = value;
-                return;
-
-            case GLU_TESS_WINDING_RULE:
-                int windingRule = (int) value;
-                if (windingRule != value) break;	/* not an integer */
-
-                switch (windingRule) {
-                    case GLU_TESS_WINDING_ODD:
-                    case GLU_TESS_WINDING_NONZERO:
-                    case GLU_TESS_WINDING_POSITIVE:
-                    case GLU_TESS_WINDING_NEGATIVE:
-                    case GLU_TESS_WINDING_ABS_GEQ_TWO:
-                        this.windingRule = windingRule;
-                        return;
-                    default:
-                        break;
-                }
-
-            case GLU_TESS_BOUNDARY_ONLY:
-                boundaryOnly = (value != 0);
-                return;
-
-            default:
-                callErrorOrErrorData(GLU_INVALID_ENUM);
-                return;
-        }
-        callErrorOrErrorData(GLU_INVALID_VALUE);
-    }
-
-/* Returns tessellator property */
-    public void gluGetTessProperty(int which, double[] value, int value_offset) {
-        switch (which) {
-            case GLU_TESS_TOLERANCE:
-/* tolerance should be in range [0..1] */
-                assert (0.0 <= relTolerance && relTolerance <= 1.0);
-                value[value_offset] = relTolerance;
-                break;
-            case GLU_TESS_WINDING_RULE:
-                assert (windingRule == GLU_TESS_WINDING_ODD ||
-                        windingRule == GLU_TESS_WINDING_NONZERO ||
-                        windingRule == GLU_TESS_WINDING_POSITIVE ||
-                        windingRule == GLU_TESS_WINDING_NEGATIVE ||
-                        windingRule == GLU_TESS_WINDING_ABS_GEQ_TWO);
-                value[value_offset] = windingRule;
-                break;
-            case GLU_TESS_BOUNDARY_ONLY:
-                assert (boundaryOnly == true || boundaryOnly == false);
-                value[value_offset] = boundaryOnly ? 1 : 0;
-                break;
-            default:
-                value[value_offset] = 0.0;
-                callErrorOrErrorData(GLU_INVALID_ENUM);
-                break;
-        }
-    } /* gluGetTessProperty() */
-
-    public void gluTessNormal(double x, double y, double z) {
-        normal[0] = x;
-        normal[1] = y;
-        normal[2] = z;
-    }
-
-    public void gluTessCallback(int which, GLUtessellatorCallback aCallback) {
-        switch (which) {
-            case GLU_TESS_BEGIN:
-                callBegin = aCallback == null ? NULL_CB : aCallback;
-                return;
-            case GLU_TESS_BEGIN_DATA:
-                callBeginData = aCallback == null ? NULL_CB : aCallback;
-                return;
-            case GLU_TESS_EDGE_FLAG:
-                callEdgeFlag = aCallback == null ? NULL_CB : aCallback;
-/* If the client wants boundary edges to be flagged,
- * we render everything as separate triangles (no strips or fans).
- */
-                flagBoundary = aCallback != null;
-                return;
-            case GLU_TESS_EDGE_FLAG_DATA:
-                callEdgeFlagData = callBegin = aCallback == null ? NULL_CB : aCallback;
-/* If the client wants boundary edges to be flagged,
- * we render everything as separate triangles (no strips or fans).
- */
-                flagBoundary = (aCallback != null);
-                return;
-            case GLU_TESS_VERTEX:
-                callVertex = aCallback == null ? NULL_CB : aCallback;
-                return;
-            case GLU_TESS_VERTEX_DATA:
-                callVertexData = aCallback == null ? NULL_CB : aCallback;
-                return;
-            case GLU_TESS_END:
-                callEnd = aCallback == null ? NULL_CB : aCallback;
-                return;
-            case GLU_TESS_END_DATA:
-                callEndData = aCallback == null ? NULL_CB : aCallback;
-                return;
-            case GLU_TESS_ERROR:
-                callError = aCallback == null ? NULL_CB : aCallback;
-                return;
-            case GLU_TESS_ERROR_DATA:
-                callErrorData = aCallback == null ? NULL_CB : aCallback;
-                return;
-            case GLU_TESS_COMBINE:
-                callCombine = aCallback == null ? NULL_CB : aCallback;
-                return;
-            case GLU_TESS_COMBINE_DATA:
-                callCombineData = aCallback == null ? NULL_CB : aCallback;
-                return;
-//            case GLU_TESS_MESH:
-//                callMesh = aCallback == null ? NULL_CB : aCallback;
-//                return;
-            default:
-                callErrorOrErrorData(GLU_INVALID_ENUM);
-                return;
-        }
-    }
-
-    private boolean addVertex(double[] coords, Object vertexData) {
-        GLUhalfEdge e;
-
-        e = lastEdge;
-        if (e == null) {
-/* Make a self-loop (one vertex, one edge). */
-
-            e = Mesh.__gl_meshMakeEdge(mesh);
-            if (e == null) return false;
-            if (!Mesh.__gl_meshSplice(e, e.Sym)) return false;
-        } else {
-/* Create a new vertex and edge which immediately follow e
- * in the ordering around the left face.
- */
-            if (Mesh.__gl_meshSplitEdge(e) == null) return false;
-            e = e.Lnext;
-        }
-
-/* The new vertex is now e.Org. */
-        e.Org.data = vertexData;
-        e.Org.coords[0] = coords[0];
-        e.Org.coords[1] = coords[1];
-        e.Org.coords[2] = coords[2];
-
-/* The winding of an edge says how the winding number changes as we
- * cross from the edge''s right face to its left face.  We add the
- * vertices in such an order that a CCW contour will add +1 to
- * the winding number of the region inside the contour.
- */
-        e.winding = 1;
-        e.Sym.winding = -1;
-
-        lastEdge = e;
-
-        return true;
-    }
-
-    private void cacheVertex(double[] coords, Object vertexData) {
-        if (cache[cacheCount] == null) {
-            cache[cacheCount] = new CachedVertex();
-        }
-
-        CachedVertex v = cache[cacheCount];
-
-        v.data = vertexData;
-        v.coords[0] = coords[0];
-        v.coords[1] = coords[1];
-        v.coords[2] = coords[2];
-        ++cacheCount;
-    }
-
-
-    private boolean flushCache() {
-        CachedVertex[] v = cache;
-
-        mesh = Mesh.__gl_meshNewMesh();
-        if (mesh == null) return false;
-
-        for (int i = 0; i < cacheCount; i++) {
-            CachedVertex vertex = v[i];
-            if (!addVertex(vertex.coords, vertex.data)) return false;
-        }
-        cacheCount = 0;
-        flushCacheOnNextVertex = false;
-
-        return true;
-    }
-
-    public void gluTessVertex(double[] coords, int coords_offset, Object vertexData) {
-        int i;
-        boolean tooLarge = false;
-        double x;
-        double[] clamped = new double[3];
-
-        requireState(TessState.T_IN_CONTOUR);
-
-        if (flushCacheOnNextVertex) {
-            if (!flushCache()) {
-                callErrorOrErrorData(GLU_OUT_OF_MEMORY);
-                return;
-            }
-            lastEdge = null;
-        }
-        for (i = 0; i < 3; ++i) {
-            x = coords[i+coords_offset];
-            if (x < -GLU_TESS_MAX_COORD) {
-                x = -GLU_TESS_MAX_COORD;
-                tooLarge = true;
-            }
-            if (x > GLU_TESS_MAX_COORD) {
-                x = GLU_TESS_MAX_COORD;
-                tooLarge = true;
-            }
-            clamped[i] = x;
-        }
-        if (tooLarge) {
-            callErrorOrErrorData(GLU_TESS_COORD_TOO_LARGE);
-        }
-
-        if (mesh == null) {
-            if (cacheCount < TESS_MAX_CACHE) {
-                cacheVertex(clamped, vertexData);
-                return;
-            }
-            if (!flushCache()) {
-                callErrorOrErrorData(GLU_OUT_OF_MEMORY);
-                return;
-            }
-        }
-
-        if (!addVertex(clamped, vertexData)) {
-            callErrorOrErrorData(GLU_OUT_OF_MEMORY);
-        }
-    }
-
-
-    public void gluTessBeginPolygon(Object data) {
-        requireState(TessState.T_DORMANT);
-
-        state = TessState.T_IN_POLYGON;
-        cacheCount = 0;
-        flushCacheOnNextVertex = false;
-        mesh = null;
-
-        polygonData = data;
-    }
-
-
-    public void gluTessBeginContour() {
-        requireState(TessState.T_IN_POLYGON);
-
-        state = TessState.T_IN_CONTOUR;
-        lastEdge = null;
-        if (cacheCount > 0) {
-/* Just set a flag so we don't get confused by empty contours
- * -- these can be generated accidentally with the obsolete
- * NextContour() interface.
- */
-            flushCacheOnNextVertex = true;
-        }
-    }
-
-
-    public void gluTessEndContour() {
-        requireState(TessState.T_IN_CONTOUR);
-        state = TessState.T_IN_POLYGON;
-    }
-
-    public void gluTessEndPolygon() {
-        GLUmesh mesh;
-
-        try {
-            requireState(TessState.T_IN_POLYGON);
-            state = TessState.T_DORMANT;
-
-            if (this.mesh == null) {
-                if (!flagBoundary /*&& callMesh == NULL_CB*/) {
-
-/* Try some special code to make the easy cases go quickly
- * (eg. convex polygons).  This code does NOT handle multiple contours,
- * intersections, edge flags, and of course it does not generate
- * an explicit mesh either.
- */
-                    if (Render.__gl_renderCache(this)) {
-                        polygonData = null;
-                        return;
-                    }
-                }
-                if (!flushCache()) throw new RuntimeException(); /* could've used a label*/
-            }
-
-/* Determine the polygon normal and project vertices onto the plane
-         * of the polygon.
-         */
-            Normal.__gl_projectPolygon(this);
-
-/* __gl_computeInterior( tess ) computes the planar arrangement specified
- * by the given contours, and further subdivides this arrangement
- * into regions.  Each region is marked "inside" if it belongs
- * to the polygon, according to the rule given by windingRule.
- * Each interior region is guaranteed be monotone.
- */
-            if (!Sweep.__gl_computeInterior(this)) {
-                throw new RuntimeException();	/* could've used a label */
-            }
-
-            mesh = this.mesh;
-            if (!fatalError) {
-                boolean rc = true;
-
-/* If the user wants only the boundary contours, we throw away all edges
- * except those which separate the interior from the exterior.
- * Otherwise we tessellate all the regions marked "inside".
- */
-                if (boundaryOnly) {
-                    rc = TessMono.__gl_meshSetWindingNumber(mesh, 1, true);
-                } else {
-                    rc = TessMono.__gl_meshTessellateInterior(mesh);
-                }
-                if (!rc) throw new RuntimeException();	/* could've used a label */
-
-                Mesh.__gl_meshCheckMesh(mesh);
-
-                if (callBegin != NULL_CB || callEnd != NULL_CB
-                        || callVertex != NULL_CB || callEdgeFlag != NULL_CB
-                        || callBeginData != NULL_CB
-                        || callEndData != NULL_CB
-                        || callVertexData != NULL_CB
-                        || callEdgeFlagData != NULL_CB) {
-                    if (boundaryOnly) {
-                        Render.__gl_renderBoundary(this, mesh);  /* output boundary contours */
-                    } else {
-                        Render.__gl_renderMesh(this, mesh);	   /* output strips and fans */
-                    }
-                }
-//                if (callMesh != NULL_CB) {
-//
-///* Throw away the exterior faces, so that all faces are interior.
-//                 * This way the user doesn't have to check the "inside" flag,
-//                 * and we don't need to even reveal its existence.  It also leaves
-//                 * the freedom for an implementation to not generate the exterior
-//                 * faces in the first place.
-//                 */
-//                    TessMono.__gl_meshDiscardExterior(mesh);
-//                    callMesh.mesh(mesh);		/* user wants the mesh itself */
-//                    mesh = null;
-//                    polygonData = null;
-//                    return;
-//                }
-            }
-            Mesh.__gl_meshDeleteMesh(mesh);
-            polygonData = null;
-            mesh = null;
-        } catch (Exception e) {
-            e.printStackTrace();
-            callErrorOrErrorData(GLU_OUT_OF_MEMORY);
-        }
-    }
-
-    /*******************************************************/
-
-/* Obsolete calls -- for backward compatibility */
-
-    public void gluBeginPolygon() {
-        gluTessBeginPolygon(null);
-        gluTessBeginContour();
-    }
-
-
-/*ARGSUSED*/
-    public void gluNextContour(int type) {
-        gluTessEndContour();
-        gluTessBeginContour();
-    }
-
-
-    public void gluEndPolygon() {
-        gluTessEndContour();
-        gluTessEndPolygon();
-    }
-
-    void callBeginOrBeginData(int a) {
-        if (callBeginData != NULL_CB)
-            callBeginData.beginData(a, polygonData);
-        else
-            callBegin.begin(a);
-    }
-
-    void callVertexOrVertexData(Object a) {
-        if (callVertexData != NULL_CB)
-            callVertexData.vertexData(a, polygonData);
-        else
-            callVertex.vertex(a);
-    }
-
-    void callEdgeFlagOrEdgeFlagData(boolean a) {
-        if (callEdgeFlagData != NULL_CB)
-            callEdgeFlagData.edgeFlagData(a, polygonData);
-        else
-            callEdgeFlag.edgeFlag(a);
-    }
-
-    void callEndOrEndData() {
-        if (callEndData != NULL_CB)
-            callEndData.endData(polygonData);
-        else
-            callEnd.end();
-    }
-
-    void callCombineOrCombineData(double[] coords, Object[] vertexData, float[] weights, Object[] outData) {
-        if (callCombineData != NULL_CB)
-            callCombineData.combineData(coords, vertexData, weights, outData, polygonData);
-        else
-            callCombine.combine(coords, vertexData, weights, outData);
-    }
-
-    void callErrorOrErrorData(int a) {
-        if (callErrorData != NULL_CB)
-            callErrorData.errorData(a, polygonData);
-        else
-            callError.error(a);
-    }
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/GLUvertex.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/GLUvertex.java
deleted file mode 100644
index 9f630fc..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/GLUvertex.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-class GLUvertex {
-    public GLUvertex next;		/* next vertex (never NULL) */
-    public GLUvertex prev;		/* previous vertex (never NULL) */
-    public GLUhalfEdge anEdge;	/* a half-edge with this origin */
-    public Object data;		/* client's data */
-
-    /* Internal data (keep hidden) */
-    public double[] coords = new double[3];	/* vertex location in 3D */
-    public double s, t;		/* projection onto the sweep plane */
-    public int pqHandle;	/* to allow deletion from priority queue */
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Geom.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Geom.java
deleted file mode 100644
index e9cde2a..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Geom.java
+++ /dev/null
@@ -1,350 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-class Geom {
-    private Geom() {
-    }
-
-    /* Given three vertices u,v,w such that VertLeq(u,v) && VertLeq(v,w),
-     * evaluates the t-coord of the edge uw at the s-coord of the vertex v.
-     * Returns v->t - (uw)(v->s), ie. the signed distance from uw to v.
-     * If uw is vertical (and thus passes thru v), the result is zero.
-     *
-     * The calculation is extremely accurate and stable, even when v
-     * is very close to u or w.  In particular if we set v->t = 0 and
-     * let r be the negated result (this evaluates (uw)(v->s)), then
-     * r is guaranteed to satisfy MIN(u->t,w->t) <= r <= MAX(u->t,w->t).
-     */
-    static double EdgeEval(GLUvertex u, GLUvertex v, GLUvertex w) {
-        double gapL, gapR;
-
-        assert (VertLeq(u, v) && VertLeq(v, w));
-
-        gapL = v.s - u.s;
-        gapR = w.s - v.s;
-
-        if (gapL + gapR > 0) {
-            if (gapL < gapR) {
-                return (v.t - u.t) + (u.t - w.t) * (gapL / (gapL + gapR));
-            } else {
-                return (v.t - w.t) + (w.t - u.t) * (gapR / (gapL + gapR));
-            }
-        }
-        /* vertical line */
-        return 0;
-    }
-
-    static double EdgeSign(GLUvertex u, GLUvertex v, GLUvertex w) {
-        double gapL, gapR;
-
-        assert (VertLeq(u, v) && VertLeq(v, w));
-
-        gapL = v.s - u.s;
-        gapR = w.s - v.s;
-
-        if (gapL + gapR > 0) {
-            return (v.t - w.t) * gapL + (v.t - u.t) * gapR;
-        }
-        /* vertical line */
-        return 0;
-    }
-
-
-    /***********************************************************************
-     * Define versions of EdgeSign, EdgeEval with s and t transposed.
-     */
-
-    static double TransEval(GLUvertex u, GLUvertex v, GLUvertex w) {
-        /* Given three vertices u,v,w such that TransLeq(u,v) && TransLeq(v,w),
-         * evaluates the t-coord of the edge uw at the s-coord of the vertex v.
-         * Returns v->s - (uw)(v->t), ie. the signed distance from uw to v.
-         * If uw is vertical (and thus passes thru v), the result is zero.
-         *
-         * The calculation is extremely accurate and stable, even when v
-         * is very close to u or w.  In particular if we set v->s = 0 and
-         * let r be the negated result (this evaluates (uw)(v->t)), then
-         * r is guaranteed to satisfy MIN(u->s,w->s) <= r <= MAX(u->s,w->s).
-         */
-        double gapL, gapR;
-
-        assert (TransLeq(u, v) && TransLeq(v, w));
-
-        gapL = v.t - u.t;
-        gapR = w.t - v.t;
-
-        if (gapL + gapR > 0) {
-            if (gapL < gapR) {
-                return (v.s - u.s) + (u.s - w.s) * (gapL / (gapL + gapR));
-            } else {
-                return (v.s - w.s) + (w.s - u.s) * (gapR / (gapL + gapR));
-            }
-        }
-        /* vertical line */
-        return 0;
-    }
-
-    static double TransSign(GLUvertex u, GLUvertex v, GLUvertex w) {
-        /* Returns a number whose sign matches TransEval(u,v,w) but which
-         * is cheaper to evaluate.  Returns > 0, == 0 , or < 0
-         * as v is above, on, or below the edge uw.
-         */
-        double gapL, gapR;
-
-        assert (TransLeq(u, v) && TransLeq(v, w));
-
-        gapL = v.t - u.t;
-        gapR = w.t - v.t;
-
-        if (gapL + gapR > 0) {
-            return (v.s - w.s) * gapL + (v.s - u.s) * gapR;
-        }
-        /* vertical line */
-        return 0;
-    }
-
-
-    static boolean VertCCW(GLUvertex u, GLUvertex v, GLUvertex w) {
-        /* For almost-degenerate situations, the results are not reliable.
-         * Unless the floating-point arithmetic can be performed without
-         * rounding errors, *any* implementation will give incorrect results
-         * on some degenerate inputs, so the client must have some way to
-         * handle this situation.
-         */
-        return (u.s * (v.t - w.t) + v.s * (w.t - u.t) + w.s * (u.t - v.t)) >= 0;
-    }
-
-/* Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),
- * or (x+y)/2 if a==b==0.  It requires that a,b >= 0, and enforces
- * this in the rare case that one argument is slightly negative.
- * The implementation is extremely stable numerically.
- * In particular it guarantees that the result r satisfies
- * MIN(x,y) <= r <= MAX(x,y), and the results are very accurate
- * even when a and b differ greatly in magnitude.
- */
-    static double Interpolate(double a, double x, double b, double y) {
-        a = (a < 0) ? 0 : a;
-        b = (b < 0) ? 0 : b;
-        if (a <= b) {
-            if (b == 0) {
-                return (x + y) / 2.0;
-            } else {
-                return (x + (y - x) * (a / (a + b)));
-            }
-        } else {
-            return (y + (x - y) * (b / (a + b)));
-        }
-    }
-
-    static void EdgeIntersect(GLUvertex o1, GLUvertex d1,
-                              GLUvertex o2, GLUvertex d2,
-                              GLUvertex v)
-/* Given edges (o1,d1) and (o2,d2), compute their point of intersection.
- * The computed point is guaranteed to lie in the intersection of the
- * bounding rectangles defined by each edge.
- */ {
-        double z1, z2;
-
-        /* This is certainly not the most efficient way to find the intersection
-         * of two line segments, but it is very numerically stable.
-         *
-         * Strategy: find the two middle vertices in the VertLeq ordering,
-         * and interpolate the intersection s-value from these.  Then repeat
-         * using the TransLeq ordering to find the intersection t-value.
-         */
-
-        if (!VertLeq(o1, d1)) {
-            GLUvertex temp = o1;
-            o1 = d1;
-            d1 = temp;
-        }
-        if (!VertLeq(o2, d2)) {
-            GLUvertex temp = o2;
-            o2 = d2;
-            d2 = temp;
-        }
-        if (!VertLeq(o1, o2)) {
-            GLUvertex temp = o1;
-            o1 = o2;
-            o2 = temp;
-            temp = d1;
-            d1 = d2;
-            d2 = temp;
-        }
-
-        if (!VertLeq(o2, d1)) {
-            /* Technically, no intersection -- do our best */
-            v.s = (o2.s + d1.s) / 2.0;
-        } else if (VertLeq(d1, d2)) {
-            /* Interpolate between o2 and d1 */
-            z1 = EdgeEval(o1, o2, d1);
-            z2 = EdgeEval(o2, d1, d2);
-            if (z1 + z2 < 0) {
-                z1 = -z1;
-                z2 = -z2;
-            }
-            v.s = Interpolate(z1, o2.s, z2, d1.s);
-        } else {
-            /* Interpolate between o2 and d2 */
-            z1 = EdgeSign(o1, o2, d1);
-            z2 = -EdgeSign(o1, d2, d1);
-            if (z1 + z2 < 0) {
-                z1 = -z1;
-                z2 = -z2;
-            }
-            v.s = Interpolate(z1, o2.s, z2, d2.s);
-        }
-
-        /* Now repeat the process for t */
-
-        if (!TransLeq(o1, d1)) {
-            GLUvertex temp = o1;
-            o1 = d1;
-            d1 = temp;
-        }
-        if (!TransLeq(o2, d2)) {
-            GLUvertex temp = o2;
-            o2 = d2;
-            d2 = temp;
-        }
-        if (!TransLeq(o1, o2)) {
-            GLUvertex temp = o2;
-            o2 = o1;
-            o1 = temp;
-            temp = d2;
-            d2 = d1;
-            d1 = temp;
-        }
-
-        if (!TransLeq(o2, d1)) {
-            /* Technically, no intersection -- do our best */
-            v.t = (o2.t + d1.t) / 2.0;
-        } else if (TransLeq(d1, d2)) {
-            /* Interpolate between o2 and d1 */
-            z1 = TransEval(o1, o2, d1);
-            z2 = TransEval(o2, d1, d2);
-            if (z1 + z2 < 0) {
-                z1 = -z1;
-                z2 = -z2;
-            }
-            v.t = Interpolate(z1, o2.t, z2, d1.t);
-        } else {
-            /* Interpolate between o2 and d2 */
-            z1 = TransSign(o1, o2, d1);
-            z2 = -TransSign(o1, d2, d1);
-            if (z1 + z2 < 0) {
-                z1 = -z1;
-                z2 = -z2;
-            }
-            v.t = Interpolate(z1, o2.t, z2, d2.t);
-        }
-    }
-
-    static boolean VertEq(GLUvertex u, GLUvertex v) {
-        return u.s == v.s && u.t == v.t;
-    }
-
-    static boolean VertLeq(GLUvertex u, GLUvertex v) {
-        return u.s < v.s || (u.s == v.s && u.t <= v.t);
-    }
-
-/* Versions of VertLeq, EdgeSign, EdgeEval with s and t transposed. */
-
-    static boolean TransLeq(GLUvertex u, GLUvertex v) {
-        return u.t < v.t || (u.t == v.t && u.s <= v.s);
-    }
-
-    static boolean EdgeGoesLeft(GLUhalfEdge e) {
-        return VertLeq(e.Sym.Org, e.Org);
-    }
-
-    static boolean EdgeGoesRight(GLUhalfEdge e) {
-        return VertLeq(e.Org, e.Sym.Org);
-    }
-
-    static double VertL1dist(GLUvertex u, GLUvertex v) {
-        return Math.abs(u.s - v.s) + Math.abs(u.t - v.t);
-    }
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Mesh.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Mesh.java
deleted file mode 100644
index 7f36517..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Mesh.java
+++ /dev/null
@@ -1,766 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-class Mesh {
-    private Mesh() {
-    }
-
-    /************************ Utility Routines ************************/
-/* MakeEdge creates a new pair of half-edges which form their own loop.
- * No vertex or face structures are allocated, but these must be assigned
- * before the current edge operation is completed.
- */
-    static GLUhalfEdge MakeEdge(GLUhalfEdge eNext) {
-        GLUhalfEdge e;
-        GLUhalfEdge eSym;
-        GLUhalfEdge ePrev;
-
-//        EdgePair * pair = (EdgePair *)
-//        memAlloc(sizeof(EdgePair));
-//        if (pair == NULL) return NULL;
-//
-//        e = &pair - > e;
-        e = new GLUhalfEdge(true);
-//        eSym = &pair - > eSym;
-        eSym = new GLUhalfEdge(false);
-
-
-        /* Make sure eNext points to the first edge of the edge pair */
-        if (!eNext.first) {
-            eNext = eNext.Sym;
-        }
-
-        /* Insert in circular doubly-linked list before eNext.
-         * Note that the prev pointer is stored in Sym->next.
-         */
-        ePrev = eNext.Sym.next;
-        eSym.next = ePrev;
-        ePrev.Sym.next = e;
-        e.next = eNext;
-        eNext.Sym.next = eSym;
-
-        e.Sym = eSym;
-        e.Onext = e;
-        e.Lnext = eSym;
-        e.Org = null;
-        e.Lface = null;
-        e.winding = 0;
-        e.activeRegion = null;
-
-        eSym.Sym = e;
-        eSym.Onext = eSym;
-        eSym.Lnext = e;
-        eSym.Org = null;
-        eSym.Lface = null;
-        eSym.winding = 0;
-        eSym.activeRegion = null;
-
-        return e;
-    }
-
-/* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
- * CS348a notes (see mesh.h).  Basically it modifies the mesh so that
- * a->Onext and b->Onext are exchanged.  This can have various effects
- * depending on whether a and b belong to different face or vertex rings.
- * For more explanation see __gl_meshSplice() below.
- */
-    static void Splice(GLUhalfEdge a, GLUhalfEdge b) {
-        GLUhalfEdge aOnext = a.Onext;
-        GLUhalfEdge bOnext = b.Onext;
-
-        aOnext.Sym.Lnext = b;
-        bOnext.Sym.Lnext = a;
-        a.Onext = bOnext;
-        b.Onext = aOnext;
-    }
-
-/* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the
- * origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
- * a place to insert the new vertex in the global vertex list.  We insert
- * the new vertex *before* vNext so that algorithms which walk the vertex
- * list will not see the newly created vertices.
- */
-    static void MakeVertex(GLUvertex newVertex,
-                           GLUhalfEdge eOrig, GLUvertex vNext) {
-        GLUhalfEdge e;
-        GLUvertex vPrev;
-        GLUvertex vNew = newVertex;
-
-        assert (vNew != null);
-
-        /* insert in circular doubly-linked list before vNext */
-        vPrev = vNext.prev;
-        vNew.prev = vPrev;
-        vPrev.next = vNew;
-        vNew.next = vNext;
-        vNext.prev = vNew;
-
-        vNew.anEdge = eOrig;
-        vNew.data = null;
-        /* leave coords, s, t undefined */
-
-        /* fix other edges on this vertex loop */
-        e = eOrig;
-        do {
-            e.Org = vNew;
-            e = e.Onext;
-        } while (e != eOrig);
-    }
-
-/* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left
- * face of all edges in the face loop to which eOrig belongs.  "fNext" gives
- * a place to insert the new face in the global face list.  We insert
- * the new face *before* fNext so that algorithms which walk the face
- * list will not see the newly created faces.
- */
-    static void MakeFace(GLUface newFace, GLUhalfEdge eOrig, GLUface fNext) {
-        GLUhalfEdge e;
-        GLUface fPrev;
-        GLUface fNew = newFace;
-
-        assert (fNew != null);
-
-        /* insert in circular doubly-linked list before fNext */
-        fPrev = fNext.prev;
-        fNew.prev = fPrev;
-        fPrev.next = fNew;
-        fNew.next = fNext;
-        fNext.prev = fNew;
-
-        fNew.anEdge = eOrig;
-        fNew.data = null;
-        fNew.trail = null;
-        fNew.marked = false;
-
-        /* The new face is marked "inside" if the old one was.  This is a
-         * convenience for the common case where a face has been split in two.
-         */
-        fNew.inside = fNext.inside;
-
-        /* fix other edges on this face loop */
-        e = eOrig;
-        do {
-            e.Lface = fNew;
-            e = e.Lnext;
-        } while (e != eOrig);
-    }
-
-/* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
- * and removes from the global edge list.
- */
-    static void KillEdge(GLUhalfEdge eDel) {
-        GLUhalfEdge ePrev, eNext;
-
-        /* Half-edges are allocated in pairs, see EdgePair above */
-        if (!eDel.first) {
-            eDel = eDel.Sym;
-        }
-
-        /* delete from circular doubly-linked list */
-        eNext = eDel.next;
-        ePrev = eDel.Sym.next;
-        eNext.Sym.next = ePrev;
-        ePrev.Sym.next = eNext;
-    }
-
-
-/* KillVertex( vDel ) destroys a vertex and removes it from the global
- * vertex list.  It updates the vertex loop to point to a given new vertex.
- */
-    static void KillVertex(GLUvertex vDel, GLUvertex newOrg) {
-        GLUhalfEdge e, eStart = vDel.anEdge;
-        GLUvertex vPrev, vNext;
-
-        /* change the origin of all affected edges */
-        e = eStart;
-        do {
-            e.Org = newOrg;
-            e = e.Onext;
-        } while (e != eStart);
-
-        /* delete from circular doubly-linked list */
-        vPrev = vDel.prev;
-        vNext = vDel.next;
-        vNext.prev = vPrev;
-        vPrev.next = vNext;
-    }
-
-/* KillFace( fDel ) destroys a face and removes it from the global face
- * list.  It updates the face loop to point to a given new face.
- */
-    static void KillFace(GLUface fDel, GLUface newLface) {
-        GLUhalfEdge e, eStart = fDel.anEdge;
-        GLUface fPrev, fNext;
-
-        /* change the left face of all affected edges */
-        e = eStart;
-        do {
-            e.Lface = newLface;
-            e = e.Lnext;
-        } while (e != eStart);
-
-        /* delete from circular doubly-linked list */
-        fPrev = fDel.prev;
-        fNext = fDel.next;
-        fNext.prev = fPrev;
-        fPrev.next = fNext;
-    }
-
-
-    /****************** Basic Edge Operations **********************/
-
-/* __gl_meshMakeEdge creates one edge, two vertices, and a loop (face).
- * The loop consists of the two new half-edges.
- */
-    public static GLUhalfEdge __gl_meshMakeEdge(GLUmesh mesh) {
-        GLUvertex newVertex1 = new GLUvertex();
-        GLUvertex newVertex2 = new GLUvertex();
-        GLUface newFace = new GLUface();
-        GLUhalfEdge e;
-
-        e = MakeEdge(mesh.eHead);
-        if (e == null) return null;
-
-        MakeVertex(newVertex1, e, mesh.vHead);
-        MakeVertex(newVertex2, e.Sym, mesh.vHead);
-        MakeFace(newFace, e, mesh.fHead);
-        return e;
-    }
-
-
-/* __gl_meshSplice( eOrg, eDst ) is the basic operation for changing the
- * mesh connectivity and topology.  It changes the mesh so that
- *	eOrg->Onext <- OLD( eDst->Onext )
- *	eDst->Onext <- OLD( eOrg->Onext )
- * where OLD(...) means the value before the meshSplice operation.
- *
- * This can have two effects on the vertex structure:
- *  - if eOrg->Org != eDst->Org, the two vertices are merged together
- *  - if eOrg->Org == eDst->Org, the origin is split into two vertices
- * In both cases, eDst->Org is changed and eOrg->Org is untouched.
- *
- * Similarly (and independently) for the face structure,
- *  - if eOrg->Lface == eDst->Lface, one loop is split into two
- *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
- * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
- *
- * Some special cases:
- * If eDst == eOrg, the operation has no effect.
- * If eDst == eOrg->Lnext, the new face will have a single edge.
- * If eDst == eOrg->Lprev, the old face will have a single edge.
- * If eDst == eOrg->Onext, the new vertex will have a single edge.
- * If eDst == eOrg->Oprev, the old vertex will have a single edge.
- */
-    public static boolean __gl_meshSplice(GLUhalfEdge eOrg, GLUhalfEdge eDst) {
-        boolean joiningLoops = false;
-        boolean joiningVertices = false;
-
-        if (eOrg == eDst) return true;
-
-        if (eDst.Org != eOrg.Org) {
-            /* We are merging two disjoint vertices -- destroy eDst->Org */
-            joiningVertices = true;
-            KillVertex(eDst.Org, eOrg.Org);
-        }
-        if (eDst.Lface != eOrg.Lface) {
-            /* We are connecting two disjoint loops -- destroy eDst.Lface */
-            joiningLoops = true;
-            KillFace(eDst.Lface, eOrg.Lface);
-        }
-
-        /* Change the edge structure */
-        Splice(eDst, eOrg);
-
-        if (!joiningVertices) {
-            GLUvertex newVertex = new GLUvertex();
-
-            /* We split one vertex into two -- the new vertex is eDst.Org.
-             * Make sure the old vertex points to a valid half-edge.
-             */
-            MakeVertex(newVertex, eDst, eOrg.Org);
-            eOrg.Org.anEdge = eOrg;
-        }
-        if (!joiningLoops) {
-            GLUface newFace = new GLUface();
-
-            /* We split one loop into two -- the new loop is eDst.Lface.
-             * Make sure the old face points to a valid half-edge.
-             */
-            MakeFace(newFace, eDst, eOrg.Lface);
-            eOrg.Lface.anEdge = eOrg;
-        }
-
-        return true;
-    }
-
-
-/* __gl_meshDelete( eDel ) removes the edge eDel.  There are several cases:
- * if (eDel.Lface != eDel.Rface), we join two loops into one; the loop
- * eDel.Lface is deleted.  Otherwise, we are splitting one loop into two;
- * the newly created loop will contain eDel.Dst.  If the deletion of eDel
- * would create isolated vertices, those are deleted as well.
- *
- * This function could be implemented as two calls to __gl_meshSplice
- * plus a few calls to memFree, but this would allocate and delete
- * unnecessary vertices and faces.
- */
-    static boolean __gl_meshDelete(GLUhalfEdge eDel) {
-        GLUhalfEdge eDelSym = eDel.Sym;
-        boolean joiningLoops = false;
-
-        /* First step: disconnect the origin vertex eDel.Org.  We make all
-         * changes to get a consistent mesh in this "intermediate" state.
-         */
-        if (eDel.Lface != eDel.Sym.Lface) {
-            /* We are joining two loops into one -- remove the left face */
-            joiningLoops = true;
-            KillFace(eDel.Lface, eDel.Sym.Lface);
-        }
-
-        if (eDel.Onext == eDel) {
-            KillVertex(eDel.Org, null);
-        } else {
-            /* Make sure that eDel.Org and eDel.Sym.Lface point to valid half-edges */
-            eDel.Sym.Lface.anEdge = eDel.Sym.Lnext;
-            eDel.Org.anEdge = eDel.Onext;
-
-            Splice(eDel, eDel.Sym.Lnext);
-            if (!joiningLoops) {
-                GLUface newFace = new GLUface();
-
-                /* We are splitting one loop into two -- create a new loop for eDel. */
-                MakeFace(newFace, eDel, eDel.Lface);
-            }
-        }
-
-        /* Claim: the mesh is now in a consistent state, except that eDel.Org
-         * may have been deleted.  Now we disconnect eDel.Dst.
-         */
-        if (eDelSym.Onext == eDelSym) {
-            KillVertex(eDelSym.Org, null);
-            KillFace(eDelSym.Lface, null);
-        } else {
-            /* Make sure that eDel.Dst and eDel.Lface point to valid half-edges */
-            eDel.Lface.anEdge = eDelSym.Sym.Lnext;
-            eDelSym.Org.anEdge = eDelSym.Onext;
-            Splice(eDelSym, eDelSym.Sym.Lnext);
-        }
-
-        /* Any isolated vertices or faces have already been freed. */
-        KillEdge(eDel);
-
-        return true;
-    }
-
-
-    /******************** Other Edge Operations **********************/
-
-/* All these routines can be implemented with the basic edge
- * operations above.  They are provided for convenience and efficiency.
- */
-
-
-/* __gl_meshAddEdgeVertex( eOrg ) creates a new edge eNew such that
- * eNew == eOrg.Lnext, and eNew.Dst is a newly created vertex.
- * eOrg and eNew will have the same left face.
- */
-    static GLUhalfEdge __gl_meshAddEdgeVertex(GLUhalfEdge eOrg) {
-        GLUhalfEdge eNewSym;
-        GLUhalfEdge eNew = MakeEdge(eOrg);
-
-        eNewSym = eNew.Sym;
-
-        /* Connect the new edge appropriately */
-        Splice(eNew, eOrg.Lnext);
-
-        /* Set the vertex and face information */
-        eNew.Org = eOrg.Sym.Org;
-        {
-            GLUvertex newVertex = new GLUvertex();
-
-            MakeVertex(newVertex, eNewSym, eNew.Org);
-        }
-        eNew.Lface = eNewSym.Lface = eOrg.Lface;
-
-        return eNew;
-    }
-
-
-/* __gl_meshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
- * such that eNew == eOrg.Lnext.  The new vertex is eOrg.Sym.Org == eNew.Org.
- * eOrg and eNew will have the same left face.
- */
-    public static GLUhalfEdge __gl_meshSplitEdge(GLUhalfEdge eOrg) {
-        GLUhalfEdge eNew;
-        GLUhalfEdge tempHalfEdge = __gl_meshAddEdgeVertex(eOrg);
-
-        eNew = tempHalfEdge.Sym;
-
-        /* Disconnect eOrg from eOrg.Sym.Org and connect it to eNew.Org */
-        Splice(eOrg.Sym, eOrg.Sym.Sym.Lnext);
-        Splice(eOrg.Sym, eNew);
-
-        /* Set the vertex and face information */
-        eOrg.Sym.Org = eNew.Org;
-        eNew.Sym.Org.anEdge = eNew.Sym;	/* may have pointed to eOrg.Sym */
-        eNew.Sym.Lface = eOrg.Sym.Lface;
-        eNew.winding = eOrg.winding;	/* copy old winding information */
-        eNew.Sym.winding = eOrg.Sym.winding;
-
-        return eNew;
-    }
-
-
-/* __gl_meshConnect( eOrg, eDst ) creates a new edge from eOrg.Sym.Org
- * to eDst.Org, and returns the corresponding half-edge eNew.
- * If eOrg.Lface == eDst.Lface, this splits one loop into two,
- * and the newly created loop is eNew.Lface.  Otherwise, two disjoint
- * loops are merged into one, and the loop eDst.Lface is destroyed.
- *
- * If (eOrg == eDst), the new face will have only two edges.
- * If (eOrg.Lnext == eDst), the old face is reduced to a single edge.
- * If (eOrg.Lnext.Lnext == eDst), the old face is reduced to two edges.
- */
-    static GLUhalfEdge __gl_meshConnect(GLUhalfEdge eOrg, GLUhalfEdge eDst) {
-        GLUhalfEdge eNewSym;
-        boolean joiningLoops = false;
-        GLUhalfEdge eNew = MakeEdge(eOrg);
-
-        eNewSym = eNew.Sym;
-
-        if (eDst.Lface != eOrg.Lface) {
-            /* We are connecting two disjoint loops -- destroy eDst.Lface */
-            joiningLoops = true;
-            KillFace(eDst.Lface, eOrg.Lface);
-        }
-
-        /* Connect the new edge appropriately */
-        Splice(eNew, eOrg.Lnext);
-        Splice(eNewSym, eDst);
-
-        /* Set the vertex and face information */
-        eNew.Org = eOrg.Sym.Org;
-        eNewSym.Org = eDst.Org;
-        eNew.Lface = eNewSym.Lface = eOrg.Lface;
-
-        /* Make sure the old face points to a valid half-edge */
-        eOrg.Lface.anEdge = eNewSym;
-
-        if (!joiningLoops) {
-            GLUface newFace = new GLUface();
-
-            /* We split one loop into two -- the new loop is eNew.Lface */
-            MakeFace(newFace, eNew, eOrg.Lface);
-        }
-        return eNew;
-    }
-
-
-    /******************** Other Operations **********************/
-
-/* __gl_meshZapFace( fZap ) destroys a face and removes it from the
- * global face list.  All edges of fZap will have a null pointer as their
- * left face.  Any edges which also have a null pointer as their right face
- * are deleted entirely (along with any isolated vertices this produces).
- * An entire mesh can be deleted by zapping its faces, one at a time,
- * in any order.  Zapped faces cannot be used in further mesh operations!
- */
-    static void __gl_meshZapFace(GLUface fZap) {
-        GLUhalfEdge eStart = fZap.anEdge;
-        GLUhalfEdge e, eNext, eSym;
-        GLUface fPrev, fNext;
-
-        /* walk around face, deleting edges whose right face is also null */
-        eNext = eStart.Lnext;
-        do {
-            e = eNext;
-            eNext = e.Lnext;
-
-            e.Lface = null;
-            if (e.Sym.Lface == null) {
-                /* delete the edge -- see __gl_MeshDelete above */
-
-                if (e.Onext == e) {
-                    KillVertex(e.Org, null);
-                } else {
-                    /* Make sure that e.Org points to a valid half-edge */
-                    e.Org.anEdge = e.Onext;
-                    Splice(e, e.Sym.Lnext);
-                }
-                eSym = e.Sym;
-                if (eSym.Onext == eSym) {
-                    KillVertex(eSym.Org, null);
-                } else {
-                    /* Make sure that eSym.Org points to a valid half-edge */
-                    eSym.Org.anEdge = eSym.Onext;
-                    Splice(eSym, eSym.Sym.Lnext);
-                }
-                KillEdge(e);
-            }
-        } while (e != eStart);
-
-        /* delete from circular doubly-linked list */
-        fPrev = fZap.prev;
-        fNext = fZap.next;
-        fNext.prev = fPrev;
-        fPrev.next = fNext;
-    }
-
-
-/* __gl_meshNewMesh() creates a new mesh with no edges, no vertices,
- * and no loops (what we usually call a "face").
- */
-    public static GLUmesh __gl_meshNewMesh() {
-        GLUvertex v;
-        GLUface f;
-        GLUhalfEdge e;
-        GLUhalfEdge eSym;
-        GLUmesh mesh = new GLUmesh();
-
-        v = mesh.vHead;
-        f = mesh.fHead;
-        e = mesh.eHead;
-        eSym = mesh.eHeadSym;
-
-        v.next = v.prev = v;
-        v.anEdge = null;
-        v.data = null;
-
-        f.next = f.prev = f;
-        f.anEdge = null;
-        f.data = null;
-        f.trail = null;
-        f.marked = false;
-        f.inside = false;
-
-        e.next = e;
-        e.Sym = eSym;
-        e.Onext = null;
-        e.Lnext = null;
-        e.Org = null;
-        e.Lface = null;
-        e.winding = 0;
-        e.activeRegion = null;
-
-        eSym.next = eSym;
-        eSym.Sym = e;
-        eSym.Onext = null;
-        eSym.Lnext = null;
-        eSym.Org = null;
-        eSym.Lface = null;
-        eSym.winding = 0;
-        eSym.activeRegion = null;
-
-        return mesh;
-    }
-
-
-/* __gl_meshUnion( mesh1, mesh2 ) forms the union of all structures in
- * both meshes, and returns the new mesh (the old meshes are destroyed).
- */
-    static GLUmesh __gl_meshUnion(GLUmesh mesh1, GLUmesh mesh2) {
-        GLUface f1 = mesh1.fHead;
-        GLUvertex v1 = mesh1.vHead;
-        GLUhalfEdge e1 = mesh1.eHead;
-        GLUface f2 = mesh2.fHead;
-        GLUvertex v2 = mesh2.vHead;
-        GLUhalfEdge e2 = mesh2.eHead;
-
-        /* Add the faces, vertices, and edges of mesh2 to those of mesh1 */
-        if (f2.next != f2) {
-            f1.prev.next = f2.next;
-            f2.next.prev = f1.prev;
-            f2.prev.next = f1;
-            f1.prev = f2.prev;
-        }
-
-        if (v2.next != v2) {
-            v1.prev.next = v2.next;
-            v2.next.prev = v1.prev;
-            v2.prev.next = v1;
-            v1.prev = v2.prev;
-        }
-
-        if (e2.next != e2) {
-            e1.Sym.next.Sym.next = e2.next;
-            e2.next.Sym.next = e1.Sym.next;
-            e2.Sym.next.Sym.next = e1;
-            e1.Sym.next = e2.Sym.next;
-        }
-
-        return mesh1;
-    }
-
-
-/* __gl_meshDeleteMesh( mesh ) will free all storage for any valid mesh.
- */
-    static void __gl_meshDeleteMeshZap(GLUmesh mesh) {
-        GLUface fHead = mesh.fHead;
-
-        while (fHead.next != fHead) {
-            __gl_meshZapFace(fHead.next);
-        }
-        assert (mesh.vHead.next == mesh.vHead);
-    }
-
-/* __gl_meshDeleteMesh( mesh ) will free all storage for any valid mesh.
- */
-    public static void __gl_meshDeleteMesh(GLUmesh mesh) {
-        GLUface f, fNext;
-        GLUvertex v, vNext;
-        GLUhalfEdge e, eNext;
-
-        for (f = mesh.fHead.next; f != mesh.fHead; f = fNext) {
-            fNext = f.next;
-        }
-
-        for (v = mesh.vHead.next; v != mesh.vHead; v = vNext) {
-            vNext = v.next;
-        }
-
-        for (e = mesh.eHead.next; e != mesh.eHead; e = eNext) {
-            /* One call frees both e and e.Sym (see EdgePair above) */
-            eNext = e.next;
-        }
-    }
-
-/* __gl_meshCheckMesh( mesh ) checks a mesh for self-consistency.
- */
-    public static void __gl_meshCheckMesh(GLUmesh mesh) {
-        GLUface fHead = mesh.fHead;
-        GLUvertex vHead = mesh.vHead;
-        GLUhalfEdge eHead = mesh.eHead;
-        GLUface f, fPrev;
-        GLUvertex v, vPrev;
-        GLUhalfEdge e, ePrev;
-
-        fPrev = fHead;
-        for (fPrev = fHead; (f = fPrev.next) != fHead; fPrev = f) {
-            assert (f.prev == fPrev);
-            e = f.anEdge;
-            do {
-                assert (e.Sym != e);
-                assert (e.Sym.Sym == e);
-                assert (e.Lnext.Onext.Sym == e);
-                assert (e.Onext.Sym.Lnext == e);
-                assert (e.Lface == f);
-                e = e.Lnext;
-            } while (e != f.anEdge);
-        }
-        assert (f.prev == fPrev && f.anEdge == null && f.data == null);
-
-        vPrev = vHead;
-        for (vPrev = vHead; (v = vPrev.next) != vHead; vPrev = v) {
-            assert (v.prev == vPrev);
-            e = v.anEdge;
-            do {
-                assert (e.Sym != e);
-                assert (e.Sym.Sym == e);
-                assert (e.Lnext.Onext.Sym == e);
-                assert (e.Onext.Sym.Lnext == e);
-                assert (e.Org == v);
-                e = e.Onext;
-            } while (e != v.anEdge);
-        }
-        assert (v.prev == vPrev && v.anEdge == null && v.data == null);
-
-        ePrev = eHead;
-        for (ePrev = eHead; (e = ePrev.next) != eHead; ePrev = e) {
-            assert (e.Sym.next == ePrev.Sym);
-            assert (e.Sym != e);
-            assert (e.Sym.Sym == e);
-            assert (e.Org != null);
-            assert (e.Sym.Org != null);
-            assert (e.Lnext.Onext.Sym == e);
-            assert (e.Onext.Sym.Lnext == e);
-        }
-        assert (e.Sym.next == ePrev.Sym
-                && e.Sym == mesh.eHeadSym
-                && e.Sym.Sym == e
-                && e.Org == null && e.Sym.Org == null
-                && e.Lface == null && e.Sym.Lface == null);
-    }
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Normal.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Normal.java
deleted file mode 100644
index eb51916..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Normal.java
+++ /dev/null
@@ -1,319 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-import org.lwjglx.util.glu.GLU;
-
-class Normal {
-    private Normal() {
-    }
-
-    static boolean SLANTED_SWEEP;
-    static double S_UNIT_X;	/* Pre-normalized */
-    static double S_UNIT_Y;
-    private static final boolean TRUE_PROJECT = false;
-
-    static {
-        if (SLANTED_SWEEP) {
-/* The "feature merging" is not intended to be complete.  There are
- * special cases where edges are nearly parallel to the sweep line
- * which are not implemented.  The algorithm should still behave
- * robustly (ie. produce a reasonable tesselation) in the presence
- * of such edges, however it may miss features which could have been
- * merged.  We could minimize this effect by choosing the sweep line
- * direction to be something unusual (ie. not parallel to one of the
- * coordinate axes).
- */
-            S_UNIT_X = 0.50941539564955385;	/* Pre-normalized */
-            S_UNIT_Y = 0.86052074622010633;
-        } else {
-            S_UNIT_X = 1.0;
-            S_UNIT_Y = 0.0;
-        }
-    }
-
-    private static double Dot(double[] u, double[] v) {
-        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2]);
-    }
-
-    static void Normalize(double[] v) {
-        double len = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
-
-        assert (len > 0);
-        len = Math.sqrt(len);
-        v[0] /= len;
-        v[1] /= len;
-        v[2] /= len;
-    }
-
-    static int LongAxis(double[] v) {
-        int i = 0;
-
-        if (Math.abs(v[1]) > Math.abs(v[0])) {
-            i = 1;
-        }
-        if (Math.abs(v[2]) > Math.abs(v[i])) {
-            i = 2;
-        }
-        return i;
-    }
-
-    static void ComputeNormal(GLUtessellatorImpl tess, double[] norm) {
-        GLUvertex v, v1, v2;
-        double c, tLen2, maxLen2;
-        double[] maxVal, minVal, d1, d2, tNorm;
-        GLUvertex[] maxVert, minVert;
-        GLUvertex vHead = tess.mesh.vHead;
-        int i;
-
-        maxVal = new double[3];
-        minVal = new double[3];
-        minVert = new GLUvertex[3];
-        maxVert = new GLUvertex[3];
-        d1 = new double[3];
-        d2 = new double[3];
-        tNorm = new double[3];
-
-        maxVal[0] = maxVal[1] = maxVal[2] = -2 * GLU.TESS_MAX_COORD;
-        minVal[0] = minVal[1] = minVal[2] = 2 * GLU.TESS_MAX_COORD;
-
-        for (v = vHead.next; v != vHead; v = v.next) {
-            for (i = 0; i < 3; ++i) {
-                c = v.coords[i];
-                if (c < minVal[i]) {
-                    minVal[i] = c;
-                    minVert[i] = v;
-                }
-                if (c > maxVal[i]) {
-                    maxVal[i] = c;
-                    maxVert[i] = v;
-                }
-            }
-        }
-
-/* Find two vertices separated by at least 1/sqrt(3) of the maximum
-         * distance between any two vertices
-         */
-        i = 0;
-        if (maxVal[1] - minVal[1] > maxVal[0] - minVal[0]) {
-            i = 1;
-        }
-        if (maxVal[2] - minVal[2] > maxVal[i] - minVal[i]) {
-            i = 2;
-        }
-        if (minVal[i] >= maxVal[i]) {
-/* All vertices are the same -- normal doesn't matter */
-            norm[0] = 0;
-            norm[1] = 0;
-            norm[2] = 1;
-            return;
-        }
-
-/* Look for a third vertex which forms the triangle with maximum area
-         * (Length of normal == twice the triangle area)
-         */
-        maxLen2 = 0;
-        v1 = minVert[i];
-        v2 = maxVert[i];
-        d1[0] = v1.coords[0] - v2.coords[0];
-        d1[1] = v1.coords[1] - v2.coords[1];
-        d1[2] = v1.coords[2] - v2.coords[2];
-        for (v = vHead.next; v != vHead; v = v.next) {
-            d2[0] = v.coords[0] - v2.coords[0];
-            d2[1] = v.coords[1] - v2.coords[1];
-            d2[2] = v.coords[2] - v2.coords[2];
-            tNorm[0] = d1[1] * d2[2] - d1[2] * d2[1];
-            tNorm[1] = d1[2] * d2[0] - d1[0] * d2[2];
-            tNorm[2] = d1[0] * d2[1] - d1[1] * d2[0];
-            tLen2 = tNorm[0] * tNorm[0] + tNorm[1] * tNorm[1] + tNorm[2] * tNorm[2];
-            if (tLen2 > maxLen2) {
-                maxLen2 = tLen2;
-                norm[0] = tNorm[0];
-                norm[1] = tNorm[1];
-                norm[2] = tNorm[2];
-            }
-        }
-
-        if (maxLen2 <= 0) {
-/* All points lie on a single line -- any decent normal will do */
-            norm[0] = norm[1] = norm[2] = 0;
-            norm[LongAxis(d1)] = 1;
-        }
-    }
-
-    static void CheckOrientation(GLUtessellatorImpl tess) {
-        double area;
-        GLUface f, fHead = tess.mesh.fHead;
-        GLUvertex v, vHead = tess.mesh.vHead;
-        GLUhalfEdge e;
-
-/* When we compute the normal automatically, we choose the orientation
- * so that the the sum of the signed areas of all contours is non-negative.
- */
-        area = 0;
-        for (f = fHead.next; f != fHead; f = f.next) {
-            e = f.anEdge;
-            if (e.winding <= 0) continue;
-            do {
-                area += (e.Org.s - e.Sym.Org.s) * (e.Org.t + e.Sym.Org.t);
-                e = e.Lnext;
-            } while (e != f.anEdge);
-        }
-        if (area < 0) {
-/* Reverse the orientation by flipping all the t-coordinates */
-            for (v = vHead.next; v != vHead; v = v.next) {
-                v.t = -v.t;
-            }
-            tess.tUnit[0] = -tess.tUnit[0];
-            tess.tUnit[1] = -tess.tUnit[1];
-            tess.tUnit[2] = -tess.tUnit[2];
-        }
-    }
-
-/* Determine the polygon normal and project vertices onto the plane
- * of the polygon.
- */
-    public static void __gl_projectPolygon(GLUtessellatorImpl tess) {
-        GLUvertex v, vHead = tess.mesh.vHead;
-        double w;
-        double[] norm = new double[3];
-        double[] sUnit, tUnit;
-        int i;
-        boolean computedNormal = false;
-
-        norm[0] = tess.normal[0];
-        norm[1] = tess.normal[1];
-        norm[2] = tess.normal[2];
-        if (norm[0] == 0 && norm[1] == 0 && norm[2] == 0) {
-            ComputeNormal(tess, norm);
-            computedNormal = true;
-        }
-        sUnit = tess.sUnit;
-        tUnit = tess.tUnit;
-        i = LongAxis(norm);
-
-        if (TRUE_PROJECT) {
-/* Choose the initial sUnit vector to be approximately perpendicular
- * to the normal.
- */
-            Normalize(norm);
-
-            sUnit[i] = 0;
-            sUnit[(i + 1) % 3] = S_UNIT_X;
-            sUnit[(i + 2) % 3] = S_UNIT_Y;
-
-/* Now make it exactly perpendicular */
-            w = Dot(sUnit, norm);
-            sUnit[0] -= w * norm[0];
-            sUnit[1] -= w * norm[1];
-            sUnit[2] -= w * norm[2];
-            Normalize(sUnit);
-
-/* Choose tUnit so that (sUnit,tUnit,norm) form a right-handed frame */
-            tUnit[0] = norm[1] * sUnit[2] - norm[2] * sUnit[1];
-            tUnit[1] = norm[2] * sUnit[0] - norm[0] * sUnit[2];
-            tUnit[2] = norm[0] * sUnit[1] - norm[1] * sUnit[0];
-            Normalize(tUnit);
-        } else {
-/* Project perpendicular to a coordinate axis -- better numerically */
-            sUnit[i] = 0;
-            sUnit[(i + 1) % 3] = S_UNIT_X;
-            sUnit[(i + 2) % 3] = S_UNIT_Y;
-
-            tUnit[i] = 0;
-            tUnit[(i + 1) % 3] = (norm[i] > 0) ? -S_UNIT_Y : S_UNIT_Y;
-            tUnit[(i + 2) % 3] = (norm[i] > 0) ? S_UNIT_X : -S_UNIT_X;
-        }
-
-/* Project the vertices onto the sweep plane */
-        for (v = vHead.next; v != vHead; v = v.next) {
-            v.s = Dot(v.coords, sUnit);
-            v.t = Dot(v.coords, tUnit);
-        }
-        if (computedNormal) {
-            CheckOrientation(tess);
-        }
-    }
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/PriorityQ.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/PriorityQ.java
deleted file mode 100644
index 8fdcf91..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/PriorityQ.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-abstract class PriorityQ {
-    public static final int INIT_SIZE = 32;
-
-    public static class PQnode {
-        int handle;
-    }
-
-    public static class PQhandleElem {
-        Object key;
-        int node;
-    }
-
-    public interface Leq {
-        boolean leq(Object key1, Object key2);
-    }
-
-    //    #ifdef FOR_TRITE_TEST_PROGRAM
-//    private static boolean LEQ(PriorityQCommon.Leq leq, Object x,Object y) {
-//        return pq.leq.leq(x,y);
-//    }
-//    #else
-/* Violates modularity, but a little faster */
-//    #include "geom.h"
-    public static boolean LEQ(Leq leq, Object x, Object y) {
-        return Geom.VertLeq((GLUvertex) x, (GLUvertex) y);
-    }
-
-    static PriorityQ pqNewPriorityQ(Leq leq) {
-        return new PriorityQSort(leq);
-    }
-
-    abstract void pqDeletePriorityQ();
-
-    abstract boolean pqInit();
-
-    abstract int pqInsert(Object keyNew);
-
-    abstract Object pqExtractMin();
-
-    abstract void pqDelete(int hCurr);
-
-    abstract Object pqMinimum();
-
-    abstract boolean pqIsEmpty();
-//    #endif
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/PriorityQHeap.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/PriorityQHeap.java
deleted file mode 100644
index 44a0043..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/PriorityQHeap.java
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-
-
-class PriorityQHeap extends PriorityQ {
-    PriorityQ.PQnode[] nodes;
-    PriorityQ.PQhandleElem[] handles;
-    int size, max;
-    int freeList;
-    boolean initialized;
-    PriorityQ.Leq leq;
-
-/* really __gl_pqHeapNewPriorityQ */
-PriorityQHeap(PriorityQ.Leq leq) {
-        size = 0;
-        max = PriorityQ.INIT_SIZE;
-        nodes = new PriorityQ.PQnode[PriorityQ.INIT_SIZE + 1];
-        for (int i = 0; i < nodes.length; i++) {
-            nodes[i] = new PQnode();
-        }
-        handles = new PriorityQ.PQhandleElem[PriorityQ.INIT_SIZE + 1];
-        for (int i = 0; i < handles.length; i++) {
-            handles[i] = new PQhandleElem();
-        }
-        initialized = false;
-        freeList = 0;
-        this.leq = leq;
-
-        nodes[1].handle = 1;	/* so that Minimum() returns NULL */
-        handles[1].key = null;
-    }
-
-/* really __gl_pqHeapDeletePriorityQ */
-    void pqDeletePriorityQ() {
-        handles = null;
-        nodes = null;
-    }
-
-    void FloatDown(int curr) {
-        PriorityQ.PQnode[] n = nodes;
-        PriorityQ.PQhandleElem[] h = handles;
-        int hCurr, hChild;
-        int child;
-
-        hCurr = n[curr].handle;
-        for (; ;) {
-            child = curr << 1;
-            if (child < size && LEQ(leq, h[n[child + 1].handle].key,
-                    h[n[child].handle].key)) {
-                ++child;
-            }
-
-            assert (child <= max);
-
-            hChild = n[child].handle;
-            if (child > size || LEQ(leq, h[hCurr].key, h[hChild].key)) {
-                n[curr].handle = hCurr;
-                h[hCurr].node = curr;
-                break;
-            }
-            n[curr].handle = hChild;
-            h[hChild].node = curr;
-            curr = child;
-        }
-    }
-
-
-    void FloatUp(int curr) {
-        PriorityQ.PQnode[] n = nodes;
-        PriorityQ.PQhandleElem[] h = handles;
-        int hCurr, hParent;
-        int parent;
-
-        hCurr = n[curr].handle;
-        for (; ;) {
-            parent = curr >> 1;
-            hParent = n[parent].handle;
-            if (parent == 0 || LEQ(leq, h[hParent].key, h[hCurr].key)) {
-                n[curr].handle = hCurr;
-                h[hCurr].node = curr;
-                break;
-            }
-            n[curr].handle = hParent;
-            h[hParent].node = curr;
-            curr = parent;
-        }
-    }
-
-/* really __gl_pqHeapInit */
-    boolean pqInit() {
-        int i;
-
-        /* This method of building a heap is O(n), rather than O(n lg n). */
-
-        for (i = size; i >= 1; --i) {
-            FloatDown(i);
-        }
-        initialized = true;
-
-        return true;
-    }
-
-/* really __gl_pqHeapInsert */
-/* returns LONG_MAX iff out of memory */
-    int pqInsert(Object keyNew) {
-        int curr;
-        int free;
-
-        curr = ++size;
-        if ((curr * 2) > max) {
-            PriorityQ.PQnode[] saveNodes = nodes;
-            PriorityQ.PQhandleElem[] saveHandles = handles;
-
-            /* If the heap overflows, double its size. */
-            max <<= 1;
-//            pq->nodes = (PQnode *)memRealloc( pq->nodes, (size_t) ((pq->max + 1) * sizeof( pq->nodes[0] )));
-            PriorityQ.PQnode[] pqNodes = new PriorityQ.PQnode[max + 1];
-            System.arraycopy( nodes, 0, pqNodes, 0, nodes.length );
-            for (int i = nodes.length; i < pqNodes.length; i++) {
-                pqNodes[i] = new PQnode();
-            }
-            nodes = pqNodes;
-            if (nodes == null) {
-                nodes = saveNodes;	/* restore ptr to free upon return */
-                return Integer.MAX_VALUE;
-            }
-
-//            pq->handles = (PQhandleElem *)memRealloc( pq->handles,(size_t)((pq->max + 1) * sizeof( pq->handles[0] )));
-            PriorityQ.PQhandleElem[] pqHandles = new PriorityQ.PQhandleElem[max + 1];
-            System.arraycopy( handles, 0, pqHandles, 0, handles.length );
-            for (int i = handles.length; i < pqHandles.length; i++) {
-                pqHandles[i] = new PQhandleElem();
-            }
-            handles = pqHandles;
-            if (handles == null) {
-                handles = saveHandles; /* restore ptr to free upon return */
-                return Integer.MAX_VALUE;
-            }
-        }
-
-        if (freeList == 0) {
-            free = curr;
-        } else {
-            free = freeList;
-            freeList = handles[free].node;
-        }
-
-        nodes[curr].handle = free;
-        handles[free].node = curr;
-        handles[free].key = keyNew;
-
-        if (initialized) {
-            FloatUp(curr);
-        }
-        assert (free != Integer.MAX_VALUE);
-        return free;
-    }
-
-/* really __gl_pqHeapExtractMin */
-    Object pqExtractMin() {
-        PriorityQ.PQnode[] n = nodes;
-        PriorityQ.PQhandleElem[] h = handles;
-        int hMin = n[1].handle;
-        Object min = h[hMin].key;
-
-        if (size > 0) {
-            n[1].handle = n[size].handle;
-            h[n[1].handle].node = 1;
-
-            h[hMin].key = null;
-            h[hMin].node = freeList;
-            freeList = hMin;
-
-            if (--size > 0) {
-                FloatDown(1);
-            }
-        }
-        return min;
-    }
-
-/* really __gl_pqHeapDelete */
-    void pqDelete(int hCurr) {
-        PriorityQ.PQnode[] n = nodes;
-        PriorityQ.PQhandleElem[] h = handles;
-        int curr;
-
-        assert (hCurr >= 1 && hCurr <= max && h[hCurr].key != null);
-
-        curr = h[hCurr].node;
-        n[curr].handle = n[size].handle;
-        h[n[curr].handle].node = curr;
-
-        if (curr <= --size) {
-            if (curr <= 1 || LEQ(leq, h[n[curr >> 1].handle].key, h[n[curr].handle].key)) {
-                FloatDown(curr);
-            } else {
-                FloatUp(curr);
-            }
-        }
-        h[hCurr].key = null;
-        h[hCurr].node = freeList;
-        freeList = hCurr;
-    }
-
-    Object pqMinimum() {
-        return handles[nodes[1].handle].key;
-    }
-
-    boolean pqIsEmpty() {
-        return size == 0;
-    }
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/PriorityQSort.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/PriorityQSort.java
deleted file mode 100644
index 65b766f..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/PriorityQSort.java
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-
-
-class PriorityQSort extends PriorityQ {
-    PriorityQHeap heap;
-    Object[] keys;
-
-    // JAVA: 'order' contains indices into the keys array.
-    // This simulates the indirect pointers used in the original C code
-    // (from Frank Suykens, Luciad.com).
-    int[] order;
-    int size, max;
-    boolean initialized;
-    PriorityQ.Leq leq;
-
-    PriorityQSort(PriorityQ.Leq leq) {
-        heap = new PriorityQHeap(leq);
-
-        keys = new Object[PriorityQ.INIT_SIZE];
-
-        size = 0;
-        max = PriorityQ.INIT_SIZE;
-        initialized = false;
-        this.leq = leq;
-    }
-
-/* really __gl_pqSortDeletePriorityQ */
-    void pqDeletePriorityQ() {
-        if (heap != null) heap.pqDeletePriorityQ();
-        order = null;
-        keys = null;
-    }
-
-    private static boolean LT(PriorityQ.Leq leq, Object x, Object y) {
-        return (!PriorityQHeap.LEQ(leq, y, x));
-    }
-
-    private static boolean GT(PriorityQ.Leq leq, Object x, Object y) {
-        return (!PriorityQHeap.LEQ(leq, x, y));
-    }
-
-    private static void Swap(int[] array, int a, int b) {
-        if (true) {
-            int tmp = array[a];
-            array[a] = array[b];
-            array[b] = tmp;
-        }
-    }
-
-    private static class Stack {
-        int p, r;
-    }
-
-/* really __gl_pqSortInit */
-    boolean pqInit() {
-        int p, r, i, j;
-        int piv;
-        Stack[] stack = new Stack[50];
-        for (int k = 0; k < stack.length; k++) {
-            stack[k] = new Stack();
-        }
-        int top = 0;
-
-        int seed = 2016473283;
-
-        /* Create an array of indirect pointers to the keys, so that we
-         * the handles we have returned are still valid.
-         */
-        order = new int[size + 1];
-/* the previous line is a patch to compensate for the fact that IBM */
-/* machines return a null on a malloc of zero bytes (unlike SGI),   */
-/* so we have to put in this defense to guard against a memory      */
-/* fault four lines down. from fossum@austin.ibm.com.               */
-        p = 0;
-        r = size - 1;
-        for (piv = 0, i = p; i <= r; ++piv, ++i) {
-            // indirect pointers: keep an index into the keys array, not a direct pointer to its contents
-            order[i] = piv;
-        }
-
-        /* Sort the indirect pointers in descending order,
-         * using randomized Quicksort
-         */
-        stack[top].p = p;
-        stack[top].r = r;
-        ++top;
-        while (--top >= 0) {
-            p = stack[top].p;
-            r = stack[top].r;
-            while (r > p + 10) {
-                seed = Math.abs( seed * 1539415821 + 1 );
-                i = p + seed % (r - p + 1);
-                piv = order[i];
-                order[i] = order[p];
-                order[p] = piv;
-                i = p - 1;
-                j = r + 1;
-                do {
-                    do {
-                        ++i;
-                    } while (GT(leq, keys[order[i]], keys[piv]));
-                    do {
-                        --j;
-                    } while (LT(leq, keys[order[j]], keys[piv]));
-                    Swap(order, i, j);
-                } while (i < j);
-                Swap(order, i, j);	/* Undo last swap */
-                if (i - p < r - j) {
-                    stack[top].p = j + 1;
-                    stack[top].r = r;
-                    ++top;
-                    r = i - 1;
-                } else {
-                    stack[top].p = p;
-                    stack[top].r = i - 1;
-                    ++top;
-                    p = j + 1;
-                }
-            }
-            /* Insertion sort small lists */
-            for (i = p + 1; i <= r; ++i) {
-                piv = order[i];
-                for (j = i; j > p && LT(leq, keys[order[j - 1]], keys[piv]); --j) {
-                    order[j] = order[j - 1];
-                }
-                order[j] = piv;
-            }
-        }
-        max = size;
-        initialized = true;
-        heap.pqInit();	/* always succeeds */
-
-/*        #ifndef NDEBUG
-        p = order;
-        r = p + size - 1;
-        for (i = p; i < r; ++i) {
-            Assertion.doAssert(LEQ(     * * (i + 1), **i ));
-        }
-        #endif*/
-
-        return true;
-    }
-
-/* really __gl_pqSortInsert */
-/* returns LONG_MAX iff out of memory */
-    int pqInsert(Object keyNew) {
-        int curr;
-
-        if (initialized) {
-            return heap.pqInsert(keyNew);
-        }
-        curr = size;
-        if (++size >= max) {
-            Object[] saveKey = keys;
-
-            /* If the heap overflows, double its size. */
-            max <<= 1;
-//            pq->keys = (PQHeapKey *)memRealloc( pq->keys,(size_t)(pq->max * sizeof( pq->keys[0] )));
-            Object[] pqKeys = new Object[max];
-            System.arraycopy( keys, 0, pqKeys, 0, keys.length );
-            keys = pqKeys;
-            if (keys == null) {
-                keys = saveKey;	/* restore ptr to free upon return */
-                return Integer.MAX_VALUE;
-            }
-        }
-        assert curr != Integer.MAX_VALUE;
-        keys[curr] = keyNew;
-
-        /* Negative handles index the sorted array. */
-        return -(curr + 1);
-    }
-
-/* really __gl_pqSortExtractMin */
-    Object pqExtractMin() {
-        Object sortMin, heapMin;
-
-        if (size == 0) {
-            return heap.pqExtractMin();
-        }
-        sortMin = keys[order[size - 1]];
-        if (!heap.pqIsEmpty()) {
-            heapMin = heap.pqMinimum();
-            if (LEQ(leq, heapMin, sortMin)) {
-                return heap.pqExtractMin();
-            }
-        }
-        do {
-            --size;
-        } while (size > 0 && keys[order[size - 1]] == null);
-        return sortMin;
-    }
-
-/* really __gl_pqSortMinimum */
-    Object pqMinimum() {
-        Object sortMin, heapMin;
-
-        if (size == 0) {
-            return heap.pqMinimum();
-        }
-        sortMin = keys[order[size - 1]];
-        if (!heap.pqIsEmpty()) {
-            heapMin = heap.pqMinimum();
-            if (PriorityQHeap.LEQ(leq, heapMin, sortMin)) {
-                return heapMin;
-            }
-        }
-        return sortMin;
-    }
-
-/* really __gl_pqSortIsEmpty */
-    boolean pqIsEmpty() {
-        return (size == 0) && heap.pqIsEmpty();
-    }
-
-/* really __gl_pqSortDelete */
-    void pqDelete(int curr) {
-        if (curr >= 0) {
-            heap.pqDelete(curr);
-            return;
-        }
-        curr = -(curr + 1);
-        assert curr < max && keys[curr] != null;
-
-        keys[curr] = null;
-        while (size > 0 && keys[order[size - 1]] == null) {
-            --size;
-        }
-    }
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Render.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Render.java
deleted file mode 100644
index 954d432..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Render.java
+++ /dev/null
@@ -1,589 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-import static org.lwjgl.opengl.GL11.*;
-import static org.lwjglx.util.glu.GLU.*;
-
-class Render {
-    private static final boolean USE_OPTIMIZED_CODE_PATH = false;
-
-    private Render() {
-    }
-
-    private static final RenderFan renderFan = new RenderFan();
-    private static final RenderStrip renderStrip = new RenderStrip();
-    private static final RenderTriangle renderTriangle = new RenderTriangle();
-
-/* This structure remembers the information we need about a primitive
- * to be able to render it later, once we have determined which
- * primitive is able to use the most triangles.
- */
-    private static class FaceCount {
-        private FaceCount() {
-        }
-
-        private FaceCount(long size, GLUhalfEdge eStart, renderCallBack render) {
-            this.size = size;
-            this.eStart = eStart;
-            this.render = render;
-        }
-
-        long size;		/* number of triangles used */
-        GLUhalfEdge eStart;	/* edge where this primitive starts */
-        renderCallBack render;
-    };
-
-    private interface renderCallBack {
-        void render(GLUtessellatorImpl tess, GLUhalfEdge e, long size);
-    }
-
-    /************************ Strips and Fans decomposition ******************/
-
-/* __gl_renderMesh( tess, mesh ) takes a mesh and breaks it into triangle
- * fans, strips, and separate triangles.  A substantial effort is made
- * to use as few rendering primitives as possible (ie. to make the fans
- * and strips as large as possible).
- *
- * The rendering output is provided as callbacks (see the api).
- */
-    public static void __gl_renderMesh(GLUtessellatorImpl tess, GLUmesh mesh) {
-        GLUface f;
-
-        /* Make a list of separate triangles so we can render them all at once */
-        tess.lonelyTriList = null;
-
-        for (f = mesh.fHead.next; f != mesh.fHead; f = f.next) {
-            f.marked = false;
-        }
-        for (f = mesh.fHead.next; f != mesh.fHead; f = f.next) {
-
-            /* We examine all faces in an arbitrary order.  Whenever we find
-             * an unprocessed face F, we output a group of faces including F
-             * whose size is maximum.
-             */
-            if (f.inside && !f.marked) {
-                RenderMaximumFaceGroup(tess, f);
-                assert (f.marked);
-            }
-        }
-        if (tess.lonelyTriList != null) {
-            RenderLonelyTriangles(tess, tess.lonelyTriList);
-            tess.lonelyTriList = null;
-        }
-    }
-
-
-    static void RenderMaximumFaceGroup(GLUtessellatorImpl tess, GLUface fOrig) {
-        /* We want to find the largest triangle fan or strip of unmarked faces
-         * which includes the given face fOrig.  There are 3 possible fans
-         * passing through fOrig (one centered at each vertex), and 3 possible
-         * strips (one for each CCW permutation of the vertices).  Our strategy
-         * is to try all of these, and take the primitive which uses the most
-         * triangles (a greedy approach).
-         */
-        GLUhalfEdge e = fOrig.anEdge;
-        FaceCount max = new FaceCount();
-        FaceCount newFace;
-
-        max.size = 1;
-        max.eStart = e;
-        max.render = renderTriangle;
-
-        if (!tess.flagBoundary) {
-            newFace = MaximumFan(e);
-            if (newFace.size > max.size) {
-                max = newFace;
-            }
-            newFace = MaximumFan(e.Lnext);
-            if (newFace.size > max.size) {
-                max = newFace;
-            }
-            newFace = MaximumFan(e.Onext.Sym);
-            if (newFace.size > max.size) {
-                max = newFace;
-            }
-
-            newFace = MaximumStrip(e);
-            if (newFace.size > max.size) {
-                max = newFace;
-            }
-            newFace = MaximumStrip(e.Lnext);
-            if (newFace.size > max.size) {
-                max = newFace;
-            }
-            newFace = MaximumStrip(e.Onext.Sym);
-            if (newFace.size > max.size) {
-                max = newFace;
-            }
-        }
-        max.render.render(tess, max.eStart, max.size);
-    }
-
-
-/* Macros which keep track of faces we have marked temporarily, and allow
- * us to backtrack when necessary.  With triangle fans, this is not
- * really necessary, since the only awkward case is a loop of triangles
- * around a single origin vertex.  However with strips the situation is
- * more complicated, and we need a general tracking method like the
- * one here.
- */
-    private static boolean Marked(GLUface f) {
-        return !f.inside || f.marked;
-    }
-
-    private static GLUface AddToTrail(GLUface f, GLUface t) {
-        f.trail = t;
-        f.marked = true;
-        return f;
-    }
-
-    private static void FreeTrail(GLUface t) {
-        if (true) {
-            while (t != null) {
-                t.marked = false;
-                t = t.trail;
-            }
-        } 
-        
-        /* else absorb trailing semicolon */
-    }
-
-    static FaceCount MaximumFan(GLUhalfEdge eOrig) {
-        /* eOrig.Lface is the face we want to render.  We want to find the size
-         * of a maximal fan around eOrig.Org.  To do this we just walk around
-         * the origin vertex as far as possible in both directions.
-         */
-        FaceCount newFace = new FaceCount(0, null, renderFan);
-        GLUface trail = null;
-        GLUhalfEdge e;
-
-        for (e = eOrig; !Marked(e.Lface); e = e.Onext) {
-            trail = AddToTrail(e.Lface, trail);
-            ++newFace.size;
-        }
-        for (e = eOrig; !Marked(e.Sym.Lface); e = e.Sym.Lnext) {
-            trail = AddToTrail(e.Sym.Lface, trail);
-            ++newFace.size;
-        }
-        newFace.eStart = e;
-        /*LINTED*/
-        FreeTrail(trail);
-        return newFace;
-    }
-
-
-    private static boolean IsEven(long n) {
-        return (n & 0x1L) == 0;
-    }
-
-    static FaceCount MaximumStrip(GLUhalfEdge eOrig) {
-        /* Here we are looking for a maximal strip that contains the vertices
-         * eOrig.Org, eOrig.Dst, eOrig.Lnext.Dst (in that order or the
-         * reverse, such that all triangles are oriented CCW).
-         *
-         * Again we walk forward and backward as far as possible.  However for
-         * strips there is a twist: to get CCW orientations, there must be
-         * an *even* number of triangles in the strip on one side of eOrig.
-         * We walk the strip starting on a side with an even number of triangles;
-         * if both side have an odd number, we are forced to shorten one side.
-         */
-        FaceCount newFace = new FaceCount(0, null, renderStrip);
-        long headSize = 0, tailSize = 0;
-        GLUface trail = null;
-        GLUhalfEdge e, eTail, eHead;
-
-        for (e = eOrig; !Marked(e.Lface); ++tailSize, e = e.Onext) {
-            trail = AddToTrail(e.Lface, trail);
-            ++tailSize;
-            e = e.Lnext.Sym;
-            if (Marked(e.Lface)) break;
-            trail = AddToTrail(e.Lface, trail);
-        }
-        eTail = e;
-
-        for (e = eOrig; !Marked(e.Sym.Lface); ++headSize, e = e.Sym.Onext.Sym) {
-            trail = AddToTrail(e.Sym.Lface, trail);
-            ++headSize;
-            e = e.Sym.Lnext;
-            if (Marked(e.Sym.Lface)) break;
-            trail = AddToTrail(e.Sym.Lface, trail);
-        }
-        eHead = e;
-
-        newFace.size = tailSize + headSize;
-        if (IsEven(tailSize)) {
-            newFace.eStart = eTail.Sym;
-        } else if (IsEven(headSize)) {
-            newFace.eStart = eHead;
-        } else {
-            /* Both sides have odd length, we must shorten one of them.  In fact,
-             * we must start from eHead to guarantee inclusion of eOrig.Lface.
-             */
-            --newFace.size;
-            newFace.eStart = eHead.Onext;
-        }
-        /*LINTED*/
-        FreeTrail(trail);
-        return newFace;
-    }
-
-    private static class RenderTriangle implements renderCallBack {
-        public void render(GLUtessellatorImpl tess, GLUhalfEdge e, long size) {
-            /* Just add the triangle to a triangle list, so we can render all
-             * the separate triangles at once.
-             */
-            assert (size == 1);
-            tess.lonelyTriList = AddToTrail(e.Lface, tess.lonelyTriList);
-        }
-    }
-
-
-    static void RenderLonelyTriangles(GLUtessellatorImpl tess, GLUface f) {
-        /* Now we render all the separate triangles which could not be
-         * grouped into a triangle fan or strip.
-         */
-        GLUhalfEdge e;
-        int newState;
-        int edgeState = -1;	/* force edge state output for first vertex */
-
-        tess.callBeginOrBeginData(GL_TRIANGLES);
-
-        for (; f != null; f = f.trail) {
-            /* Loop once for each edge (there will always be 3 edges) */
-
-            e = f.anEdge;
-            do {
-                if (tess.flagBoundary) {
-                    /* Set the "edge state" to true just before we output the
-                     * first vertex of each edge on the polygon boundary.
-                     */
-                    newState = (!e.Sym.Lface.inside) ? 1 : 0;
-                    if (edgeState != newState) {
-                        edgeState = newState;
-                        tess.callEdgeFlagOrEdgeFlagData( edgeState != 0);
-                    }
-                }
-                tess.callVertexOrVertexData( e.Org.data);
-
-                e = e.Lnext;
-            } while (e != f.anEdge);
-        }
-        tess.callEndOrEndData();
-    }
-
-    private static class RenderFan implements renderCallBack {
-        public void render(GLUtessellatorImpl tess, GLUhalfEdge e, long size) {
-            /* Render as many CCW triangles as possible in a fan starting from
-             * edge "e".  The fan *should* contain exactly "size" triangles
-             * (otherwise we've goofed up somewhere).
-             */
-            tess.callBeginOrBeginData(GL_TRIANGLE_FAN);
-            tess.callVertexOrVertexData( e.Org.data);
-            tess.callVertexOrVertexData( e.Sym.Org.data);
-
-            while (!Marked(e.Lface)) {
-                e.Lface.marked = true;
-                --size;
-                e = e.Onext;
-                tess.callVertexOrVertexData( e.Sym.Org.data);
-            }
-
-            assert (size == 0);
-            tess.callEndOrEndData();
-        }
-    }
-
-    private static class RenderStrip implements renderCallBack {
-        public void render(GLUtessellatorImpl tess, GLUhalfEdge e, long size) {
-            /* Render as many CCW triangles as possible in a strip starting from
-             * edge "e".  The strip *should* contain exactly "size" triangles
-             * (otherwise we've goofed up somewhere).
-             */
-            tess.callBeginOrBeginData(GL_TRIANGLE_STRIP);
-            tess.callVertexOrVertexData( e.Org.data);
-            tess.callVertexOrVertexData( e.Sym.Org.data);
-
-            while (!Marked(e.Lface)) {
-                e.Lface.marked = true;
-                --size;
-                e = e.Lnext.Sym;
-                tess.callVertexOrVertexData( e.Org.data);
-                if (Marked(e.Lface)) break;
-
-                e.Lface.marked = true;
-                --size;
-                e = e.Onext;
-                tess.callVertexOrVertexData( e.Sym.Org.data);
-            }
-
-            assert (size == 0);
-            tess.callEndOrEndData();
-        }
-    }
-
-    /************************ Boundary contour decomposition ******************/
-
-/* __gl_renderBoundary( tess, mesh ) takes a mesh, and outputs one
- * contour for each face marked "inside".  The rendering output is
- * provided as callbacks (see the api).
- */
-    public static void __gl_renderBoundary(GLUtessellatorImpl tess, GLUmesh mesh) {
-        GLUface f;
-        GLUhalfEdge e;
-
-        for (f = mesh.fHead.next; f != mesh.fHead; f = f.next) {
-            if (f.inside) {
-                tess.callBeginOrBeginData(GL_LINE_LOOP);
-                e = f.anEdge;
-                do {
-                    tess.callVertexOrVertexData( e.Org.data);
-                    e = e.Lnext;
-                } while (e != f.anEdge);
-                tess.callEndOrEndData();
-            }
-        }
-    }
-
-
-    /************************ Quick-and-dirty decomposition ******************/
-
-    private static final int SIGN_INCONSISTENT = 2;
-
-    static int ComputeNormal(GLUtessellatorImpl tess, double[] norm, boolean check)
-/*
- * If check==false, we compute the polygon normal and place it in norm[].
- * If check==true, we check that each triangle in the fan from v0 has a
- * consistent orientation with respect to norm[].  If triangles are
- * consistently oriented CCW, return 1; if CW, return -1; if all triangles
- * are degenerate return 0; otherwise (no consistent orientation) return
- * SIGN_INCONSISTENT.
- */ {
-        CachedVertex[] v = tess.cache;
-//            CachedVertex vn = v0 + tess.cacheCount;
-        int vn = tess.cacheCount;
-//            CachedVertex vc;
-        int vc;
-        double dot, xc, yc, zc, xp, yp, zp;
-        double[] n = new double[3];
-        int sign = 0;
-
-        /* Find the polygon normal.  It is important to get a reasonable
-         * normal even when the polygon is self-intersecting (eg. a bowtie).
-         * Otherwise, the computed normal could be very tiny, but perpendicular
-         * to the true plane of the polygon due to numerical noise.  Then all
-         * the triangles would appear to be degenerate and we would incorrectly
-         * decompose the polygon as a fan (or simply not render it at all).
-         *
-         * We use a sum-of-triangles normal algorithm rather than the more
-         * efficient sum-of-trapezoids method (used in CheckOrientation()
-         * in normal.c).  This lets us explicitly reverse the signed area
-         * of some triangles to get a reasonable normal in the self-intersecting
-         * case.
-         */
-        if (!check) {
-            norm[0] = norm[1] = norm[2] = 0.0;
-        }
-
-        vc = 1;
-        xc = v[vc].coords[0] - v[0].coords[0];
-        yc = v[vc].coords[1] - v[0].coords[1];
-        zc = v[vc].coords[2] - v[0].coords[2];
-        while (++vc < vn) {
-            xp = xc;
-            yp = yc;
-            zp = zc;
-            xc = v[vc].coords[0] - v[0].coords[0];
-            yc = v[vc].coords[1] - v[0].coords[1];
-            zc = v[vc].coords[2] - v[0].coords[2];
-
-            /* Compute (vp - v0) cross (vc - v0) */
-            n[0] = yp * zc - zp * yc;
-            n[1] = zp * xc - xp * zc;
-            n[2] = xp * yc - yp * xc;
-
-            dot = n[0] * norm[0] + n[1] * norm[1] + n[2] * norm[2];
-            if (!check) {
-                /* Reverse the contribution of back-facing triangles to get
-                 * a reasonable normal for self-intersecting polygons (see above)
-                 */
-                if (dot >= 0) {
-                    norm[0] += n[0];
-                    norm[1] += n[1];
-                    norm[2] += n[2];
-                } else {
-                    norm[0] -= n[0];
-                    norm[1] -= n[1];
-                    norm[2] -= n[2];
-                }
-            } else if (dot != 0) {
-                /* Check the new orientation for consistency with previous triangles */
-                if (dot > 0) {
-                    if (sign < 0) return SIGN_INCONSISTENT;
-                    sign = 1;
-                } else {
-                    if (sign > 0) return SIGN_INCONSISTENT;
-                    sign = -1;
-                }
-            }
-        }
-        return sign;
-    }
-
-/* __gl_renderCache( tess ) takes a single contour and tries to render it
- * as a triangle fan.  This handles convex polygons, as well as some
- * non-convex polygons if we get lucky.
- *
- * Returns true if the polygon was successfully rendered.  The rendering
- * output is provided as callbacks (see the api).
- */
-    public static boolean __gl_renderCache(GLUtessellatorImpl tess) {
-        CachedVertex[] v = tess.cache;
-//            CachedVertex vn = v0 + tess.cacheCount;
-        int vn = tess.cacheCount;
-//            CachedVertex vc;
-        int vc;
-        double[] norm = new double[3];
-        int sign;
-
-        if (tess.cacheCount < 3) {
-            /* Degenerate contour -- no output */
-            return true;
-        }
-
-        norm[0] = tess.normal[0];
-        norm[1] = tess.normal[1];
-        norm[2] = tess.normal[2];
-        if (norm[0] == 0 && norm[1] == 0 && norm[2] == 0) {
-            ComputeNormal( tess, norm, false);
-        }
-
-        sign = ComputeNormal( tess, norm, true);
-        if (sign == SIGN_INCONSISTENT) {
-            /* Fan triangles did not have a consistent orientation */
-            return false;
-        }
-        if (sign == 0) {
-            /* All triangles were degenerate */
-            return true;
-        }
-
-        if ( !USE_OPTIMIZED_CODE_PATH ) {
-            return false;
-        } else {
-            /* Make sure we do the right thing for each winding rule */
-            switch (tess.windingRule) {
-                case GLU_TESS_WINDING_ODD:
-                case GLU_TESS_WINDING_NONZERO:
-                    break;
-                case GLU_TESS_WINDING_POSITIVE:
-                    if (sign < 0) return true;
-                    break;
-                case GLU_TESS_WINDING_NEGATIVE:
-                    if (sign > 0) return true;
-                    break;
-                case GLU_TESS_WINDING_ABS_GEQ_TWO:
-                    return true;
-            }
-
-            tess.callBeginOrBeginData( tess.boundaryOnly ? GL_LINE_LOOP
-                    : (tess.cacheCount > 3) ? GL_TRIANGLE_FAN
-                    : GL_TRIANGLES);
-
-            tess.callVertexOrVertexData( v[0].data);
-            if (sign > 0) {
-                for (vc = 1; vc < vn; ++vc) {
-                    tess.callVertexOrVertexData( v[vc].data);
-                }
-            } else {
-                for (vc = vn - 1; vc > 0; --vc) {
-                    tess.callVertexOrVertexData( v[vc].data);
-                }
-            }
-            tess.callEndOrEndData();
-            return true;
-        }
-    }
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Sweep.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Sweep.java
deleted file mode 100644
index b0ad489..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/Sweep.java
+++ /dev/null
@@ -1,1384 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-import static org.lwjglx.util.glu.GLU.*;
-
-class Sweep {
-    private Sweep() {
-    }
-
-//    #ifdef FOR_TRITE_TEST_PROGRAM
-//    extern void DebugEvent( GLUtessellator *tess );
-//    #else
-    private static void DebugEvent(GLUtessellatorImpl tess) {
-
-    }
-//    #endif
-
-/*
- * Invariants for the Edge Dictionary.
- * - each pair of adjacent edges e2=Succ(e1) satisfies EdgeLeq(e1,e2)
- *   at any valid location of the sweep event
- * - if EdgeLeq(e2,e1) as well (at any valid sweep event), then e1 and e2
- *   share a common endpoint
- * - for each e, e.Dst has been processed, but not e.Org
- * - each edge e satisfies VertLeq(e.Dst,event) && VertLeq(event,e.Org)
- *   where "event" is the current sweep line event.
- * - no edge e has zero length
- *
- * Invariants for the Mesh (the processed portion).
- * - the portion of the mesh left of the sweep line is a planar graph,
- *   ie. there is *some* way to embed it in the plane
- * - no processed edge has zero length
- * - no two processed vertices have identical coordinates
- * - each "inside" region is monotone, ie. can be broken into two chains
- *   of monotonically increasing vertices according to VertLeq(v1,v2)
- *   - a non-invariant: these chains may intersect (very slightly)
- *
- * Invariants for the Sweep.
- * - if none of the edges incident to the event vertex have an activeRegion
- *   (ie. none of these edges are in the edge dictionary), then the vertex
- *   has only right-going edges.
- * - if an edge is marked "fixUpperEdge" (it is a temporary edge introduced
- *   by ConnectRightVertex), then it is the only right-going edge from
- *   its associated vertex.  (This says that these edges exist only
- *   when it is necessary.)
- */
-
-/* When we merge two edges into one, we need to compute the combined
- * winding of the new edge.
- */
-    private static void AddWinding(GLUhalfEdge eDst, GLUhalfEdge eSrc) {
-        eDst.winding += eSrc.winding;
-        eDst.Sym.winding += eSrc.Sym.winding;
-    }
-
-
-    private static ActiveRegion RegionBelow(ActiveRegion r) {
-        return ((ActiveRegion) Dict.dictKey(Dict.dictPred(r.nodeUp)));
-    }
-
-    private static ActiveRegion RegionAbove(ActiveRegion r) {
-        return ((ActiveRegion) Dict.dictKey(Dict.dictSucc(r.nodeUp)));
-    }
-
-    static boolean EdgeLeq(GLUtessellatorImpl tess, ActiveRegion reg1, ActiveRegion reg2)
-/*
- * Both edges must be directed from right to left (this is the canonical
- * direction for the upper edge of each region).
- *
- * The strategy is to evaluate a "t" value for each edge at the
- * current sweep line position, given by tess.event.  The calculations
- * are designed to be very stable, but of course they are not perfect.
- *
- * Special case: if both edge destinations are at the sweep event,
- * we sort the edges by slope (they would otherwise compare equally).
- */ {
-        GLUvertex event = tess.event;
-        GLUhalfEdge e1, e2;
-        double t1, t2;
-
-        e1 = reg1.eUp;
-        e2 = reg2.eUp;
-
-        if (e1.Sym.Org == event) {
-            if (e2.Sym.Org == event) {
-                /* Two edges right of the sweep line which meet at the sweep event.
-                 * Sort them by slope.
-                 */
-                if (Geom.VertLeq(e1.Org, e2.Org)) {
-                    return Geom.EdgeSign(e2.Sym.Org, e1.Org, e2.Org) <= 0;
-                }
-                return Geom.EdgeSign(e1.Sym.Org, e2.Org, e1.Org) >= 0;
-            }
-            return Geom.EdgeSign(e2.Sym.Org, event, e2.Org) <= 0;
-        }
-        if (e2.Sym.Org == event) {
-            return Geom.EdgeSign(e1.Sym.Org, event, e1.Org) >= 0;
-        }
-
-        /* General case - compute signed distance *from* e1, e2 to event */
-        t1 = Geom.EdgeEval(e1.Sym.Org, event, e1.Org);
-        t2 = Geom.EdgeEval(e2.Sym.Org, event, e2.Org);
-        return (t1 >= t2);
-    }
-
-
-    static void DeleteRegion(GLUtessellatorImpl tess, ActiveRegion reg) {
-        if (reg.fixUpperEdge) {
-            /* It was created with zero winding number, so it better be
-             * deleted with zero winding number (ie. it better not get merged
-             * with a real edge).
-             */
-            assert (reg.eUp.winding == 0);
-        }
-        reg.eUp.activeRegion = null;
-        Dict.dictDelete(tess.dict, reg.nodeUp); /* __gl_dictListDelete */
-    }
-
-
-    static boolean FixUpperEdge(ActiveRegion reg, GLUhalfEdge newEdge)
-/*
- * Replace an upper edge which needs fixing (see ConnectRightVertex).
- */ {
-        assert (reg.fixUpperEdge);
-        if (!Mesh.__gl_meshDelete(reg.eUp)) return false;
-        reg.fixUpperEdge = false;
-        reg.eUp = newEdge;
-        newEdge.activeRegion = reg;
-
-        return true;
-    }
-
-    static ActiveRegion TopLeftRegion(ActiveRegion reg) {
-        GLUvertex org = reg.eUp.Org;
-        GLUhalfEdge e;
-
-        /* Find the region above the uppermost edge with the same origin */
-        do {
-            reg = RegionAbove(reg);
-        } while (reg.eUp.Org == org);
-
-        /* If the edge above was a temporary edge introduced by ConnectRightVertex,
-         * now is the time to fix it.
-         */
-        if (reg.fixUpperEdge) {
-            e = Mesh.__gl_meshConnect(RegionBelow(reg).eUp.Sym, reg.eUp.Lnext);
-            if (e == null) return null;
-            if (!FixUpperEdge(reg, e)) return null;
-            reg = RegionAbove(reg);
-        }
-        return reg;
-    }
-
-    static ActiveRegion TopRightRegion(ActiveRegion reg) {
-        GLUvertex dst = reg.eUp.Sym.Org;
-
-        /* Find the region above the uppermost edge with the same destination */
-        do {
-            reg = RegionAbove(reg);
-        } while (reg.eUp.Sym.Org == dst);
-        return reg;
-    }
-
-    static ActiveRegion AddRegionBelow(GLUtessellatorImpl tess,
-                                       ActiveRegion regAbove,
-                                       GLUhalfEdge eNewUp)
-/*
- * Add a new active region to the sweep line, *somewhere* below "regAbove"
- * (according to where the new edge belongs in the sweep-line dictionary).
- * The upper edge of the new region will be "eNewUp".
- * Winding number and "inside" flag are not updated.
- */ {
-        ActiveRegion regNew = new ActiveRegion();
-        //if (regNew == null) throw new RuntimeException();
-
-        regNew.eUp = eNewUp;
-        /* __gl_dictListInsertBefore */
-        regNew.nodeUp = Dict.dictInsertBefore(tess.dict, regAbove.nodeUp, regNew);
-        if (regNew.nodeUp == null) throw new RuntimeException();
-        regNew.fixUpperEdge = false;
-        regNew.sentinel = false;
-        regNew.dirty = false;
-
-        eNewUp.activeRegion = regNew;
-        return regNew;
-    }
-
-    static boolean IsWindingInside(GLUtessellatorImpl tess, int n) {
-        switch (tess.windingRule) {
-            case GLU_TESS_WINDING_ODD:
-                return (n & 1) != 0;
-            case GLU_TESS_WINDING_NONZERO:
-                return (n != 0);
-            case GLU_TESS_WINDING_POSITIVE:
-                return (n > 0);
-            case GLU_TESS_WINDING_NEGATIVE:
-                return (n < 0);
-            case GLU_TESS_WINDING_ABS_GEQ_TWO:
-                return (n >= 2) || (n <= -2);
-        }
-        /*LINTED*/
-//        assert (false);
-        throw new InternalError();
-        /*NOTREACHED*/
-    }
-
-
-    static void ComputeWinding(GLUtessellatorImpl tess, ActiveRegion reg) {
-        reg.windingNumber = RegionAbove(reg).windingNumber + reg.eUp.winding;
-        reg.inside = IsWindingInside(tess, reg.windingNumber);
-    }
-
-
-    static void FinishRegion(GLUtessellatorImpl tess, ActiveRegion reg)
-/*
- * Delete a region from the sweep line.  This happens when the upper
- * and lower chains of a region meet (at a vertex on the sweep line).
- * The "inside" flag is copied to the appropriate mesh face (we could
- * not do this before -- since the structure of the mesh is always
- * changing, this face may not have even existed until now).
- */ {
-        GLUhalfEdge e = reg.eUp;
-        GLUface f = e.Lface;
-
-        f.inside = reg.inside;
-        f.anEdge = e;   /* optimization for __gl_meshTessellateMonoRegion() */
-        DeleteRegion(tess, reg);
-    }
-
-
-    static GLUhalfEdge FinishLeftRegions(GLUtessellatorImpl tess,
-                                         ActiveRegion regFirst, ActiveRegion regLast)
-/*
- * We are given a vertex with one or more left-going edges.  All affected
- * edges should be in the edge dictionary.  Starting at regFirst.eUp,
- * we walk down deleting all regions where both edges have the same
- * origin vOrg.  At the same time we copy the "inside" flag from the
- * active region to the face, since at this point each face will belong
- * to at most one region (this was not necessarily true until this point
- * in the sweep).  The walk stops at the region above regLast; if regLast
- * is null we walk as far as possible.  At the same time we relink the
- * mesh if necessary, so that the ordering of edges around vOrg is the
- * same as in the dictionary.
- */ {
-        ActiveRegion reg, regPrev;
-        GLUhalfEdge e, ePrev;
-
-        regPrev = regFirst;
-        ePrev = regFirst.eUp;
-        while (regPrev != regLast) {
-            regPrev.fixUpperEdge = false;	/* placement was OK */
-            reg = RegionBelow(regPrev);
-            e = reg.eUp;
-            if (e.Org != ePrev.Org) {
-                if (!reg.fixUpperEdge) {
-                    /* Remove the last left-going edge.  Even though there are no further
-                     * edges in the dictionary with this origin, there may be further
-                     * such edges in the mesh (if we are adding left edges to a vertex
-                     * that has already been processed).  Thus it is important to call
-                     * FinishRegion rather than just DeleteRegion.
-                     */
-                    FinishRegion(tess, regPrev);
-                    break;
-                }
-                /* If the edge below was a temporary edge introduced by
-                 * ConnectRightVertex, now is the time to fix it.
-                 */
-                e = Mesh.__gl_meshConnect(ePrev.Onext.Sym, e.Sym);
-                if (e == null) throw new RuntimeException();
-                if (!FixUpperEdge(reg, e)) throw new RuntimeException();
-            }
-
-            /* Relink edges so that ePrev.Onext == e */
-            if (ePrev.Onext != e) {
-                if (!Mesh.__gl_meshSplice(e.Sym.Lnext, e)) throw new RuntimeException();
-                if (!Mesh.__gl_meshSplice(ePrev, e)) throw new RuntimeException();
-            }
-            FinishRegion(tess, regPrev);	/* may change reg.eUp */
-            ePrev = reg.eUp;
-            regPrev = reg;
-        }
-        return ePrev;
-    }
-
-
-    static void AddRightEdges(GLUtessellatorImpl tess, ActiveRegion regUp,
-                              GLUhalfEdge eFirst, GLUhalfEdge eLast, GLUhalfEdge eTopLeft,
-                              boolean cleanUp)
-/*
- * Purpose: insert right-going edges into the edge dictionary, and update
- * winding numbers and mesh connectivity appropriately.  All right-going
- * edges share a common origin vOrg.  Edges are inserted CCW starting at
- * eFirst; the last edge inserted is eLast.Sym.Lnext.  If vOrg has any
- * left-going edges already processed, then eTopLeft must be the edge
- * such that an imaginary upward vertical segment from vOrg would be
- * contained between eTopLeft.Sym.Lnext and eTopLeft; otherwise eTopLeft
- * should be null.
- */ {
-        ActiveRegion reg, regPrev;
-        GLUhalfEdge e, ePrev;
-        boolean firstTime = true;
-
-        /* Insert the new right-going edges in the dictionary */
-        e = eFirst;
-        do {
-            assert (Geom.VertLeq(e.Org, e.Sym.Org));
-            AddRegionBelow(tess, regUp, e.Sym);
-            e = e.Onext;
-        } while (e != eLast);
-
-        /* Walk *all* right-going edges from e.Org, in the dictionary order,
-         * updating the winding numbers of each region, and re-linking the mesh
-         * edges to match the dictionary ordering (if necessary).
-         */
-        if (eTopLeft == null) {
-            eTopLeft = RegionBelow(regUp).eUp.Sym.Onext;
-        }
-        regPrev = regUp;
-        ePrev = eTopLeft;
-        for (; ;) {
-            reg = RegionBelow(regPrev);
-            e = reg.eUp.Sym;
-            if (e.Org != ePrev.Org) break;
-
-            if (e.Onext != ePrev) {
-                /* Unlink e from its current position, and relink below ePrev */
-                if (!Mesh.__gl_meshSplice(e.Sym.Lnext, e)) throw new RuntimeException();
-                if (!Mesh.__gl_meshSplice(ePrev.Sym.Lnext, e)) throw new RuntimeException();
-            }
-            /* Compute the winding number and "inside" flag for the new regions */
-            reg.windingNumber = regPrev.windingNumber - e.winding;
-            reg.inside = IsWindingInside(tess, reg.windingNumber);
-
-            /* Check for two outgoing edges with same slope -- process these
-             * before any intersection tests (see example in __gl_computeInterior).
-             */
-            regPrev.dirty = true;
-            if (!firstTime && CheckForRightSplice(tess, regPrev)) {
-                AddWinding(e, ePrev);
-                DeleteRegion(tess, regPrev);
-                if (!Mesh.__gl_meshDelete(ePrev)) throw new RuntimeException();
-            }
-            firstTime = false;
-            regPrev = reg;
-            ePrev = e;
-        }
-        regPrev.dirty = true;
-        assert (regPrev.windingNumber - e.winding == reg.windingNumber);
-
-        if (cleanUp) {
-            /* Check for intersections between newly adjacent edges. */
-            WalkDirtyRegions(tess, regPrev);
-        }
-    }
-
-
-    static void CallCombine(GLUtessellatorImpl tess, GLUvertex isect,
-                            Object[] data, float[] weights, boolean needed) {
-        double[] coords = new double[3];
-
-        /* Copy coord data in case the callback changes it. */
-        coords[0] = isect.coords[0];
-        coords[1] = isect.coords[1];
-        coords[2] = isect.coords[2];
-
-        Object[] outData = new Object[1];
-        tess.callCombineOrCombineData(coords, data, weights, outData);
-        isect.data = outData[0];
-        if (isect.data == null) {
-            if (!needed) {
-                isect.data = data[0];
-            } else if (!tess.fatalError) {
-                /* The only way fatal error is when two edges are found to intersect,
-                 * but the user has not provided the callback necessary to handle
-                 * generated intersection points.
-                 */
-                tess.callErrorOrErrorData(GLU_TESS_NEED_COMBINE_CALLBACK);
-                tess.fatalError = true;
-            }
-        }
-    }
-
-    static void SpliceMergeVertices(GLUtessellatorImpl tess, GLUhalfEdge e1,
-                                    GLUhalfEdge e2)
-/*
- * Two vertices with idential coordinates are combined into one.
- * e1.Org is kept, while e2.Org is discarded.
- */ {
-        Object[] data = new Object[4];
-        float[] weights = new float[]{0.5f, 0.5f, 0.0f, 0.0f};
-
-        data[0] = e1.Org.data;
-        data[1] = e2.Org.data;
-        CallCombine(tess, e1.Org, data, weights, false);
-        if (!Mesh.__gl_meshSplice(e1, e2)) throw new RuntimeException();
-    }
-
-    static void VertexWeights(GLUvertex isect, GLUvertex org, GLUvertex dst,
-                              float[] weights)
-/*
- * Find some weights which describe how the intersection vertex is
- * a linear combination of "org" and "dest".  Each of the two edges
- * which generated "isect" is allocated 50% of the weight; each edge
- * splits the weight between its org and dst according to the
- * relative distance to "isect".
- */ {
-        double t1 = Geom.VertL1dist(org, isect);
-        double t2 = Geom.VertL1dist(dst, isect);
-
-        weights[0] = (float) (0.5 * t2 / (t1 + t2));
-        weights[1] = (float) (0.5 * t1 / (t1 + t2));
-        isect.coords[0] += weights[0] * org.coords[0] + weights[1] * dst.coords[0];
-        isect.coords[1] += weights[0] * org.coords[1] + weights[1] * dst.coords[1];
-        isect.coords[2] += weights[0] * org.coords[2] + weights[1] * dst.coords[2];
-    }
-
-
-    static void GetIntersectData(GLUtessellatorImpl tess, GLUvertex isect,
-                                 GLUvertex orgUp, GLUvertex dstUp,
-                                 GLUvertex orgLo, GLUvertex dstLo)
-/*
- * We've computed a new intersection point, now we need a "data" pointer
- * from the user so that we can refer to this new vertex in the
- * rendering callbacks.
- */ {
-        Object[] data = new Object[4];
-        float[] weights = new float[4];
-        float[] weights1 = new float[2];
-        float[] weights2 = new float[2];
-
-        data[0] = orgUp.data;
-        data[1] = dstUp.data;
-        data[2] = orgLo.data;
-        data[3] = dstLo.data;
-
-        isect.coords[0] = isect.coords[1] = isect.coords[2] = 0;
-        VertexWeights(isect, orgUp, dstUp, weights1);
-        VertexWeights(isect, orgLo, dstLo, weights2);
-        System.arraycopy(weights1, 0, weights, 0, 2);
-        System.arraycopy(weights2, 0, weights, 2, 2);
-
-        CallCombine(tess, isect, data, weights, true);
-    }
-
-    static boolean CheckForRightSplice(GLUtessellatorImpl tess, ActiveRegion regUp)
-/*
- * Check the upper and lower edge of "regUp", to make sure that the
- * eUp.Org is above eLo, or eLo.Org is below eUp (depending on which
- * origin is leftmost).
- *
- * The main purpose is to splice right-going edges with the same
- * dest vertex and nearly identical slopes (ie. we can't distinguish
- * the slopes numerically).  However the splicing can also help us
- * to recover from numerical errors.  For example, suppose at one
- * point we checked eUp and eLo, and decided that eUp.Org is barely
- * above eLo.  Then later, we split eLo into two edges (eg. from
- * a splice operation like this one).  This can change the result of
- * our test so that now eUp.Org is incident to eLo, or barely below it.
- * We must correct this condition to maintain the dictionary invariants.
- *
- * One possibility is to check these edges for intersection again
- * (ie. CheckForIntersect).  This is what we do if possible.  However
- * CheckForIntersect requires that tess.event lies between eUp and eLo,
- * so that it has something to fall back on when the intersection
- * calculation gives us an unusable answer.  So, for those cases where
- * we can't check for intersection, this routine fixes the problem
- * by just splicing the offending vertex into the other edge.
- * This is a guaranteed solution, no matter how degenerate things get.
- * Basically this is a combinatorial solution to a numerical problem.
- */ {
-        ActiveRegion regLo = RegionBelow(regUp);
-        GLUhalfEdge eUp = regUp.eUp;
-        GLUhalfEdge eLo = regLo.eUp;
-
-        if (Geom.VertLeq(eUp.Org, eLo.Org)) {
-            if (Geom.EdgeSign(eLo.Sym.Org, eUp.Org, eLo.Org) > 0) return false;
-
-            /* eUp.Org appears to be below eLo */
-            if (!Geom.VertEq(eUp.Org, eLo.Org)) {
-                /* Splice eUp.Org into eLo */
-                if (Mesh.__gl_meshSplitEdge(eLo.Sym) == null) throw new RuntimeException();
-                if (!Mesh.__gl_meshSplice(eUp, eLo.Sym.Lnext)) throw new RuntimeException();
-                regUp.dirty = regLo.dirty = true;
-
-            } else if (eUp.Org != eLo.Org) {
-                /* merge the two vertices, discarding eUp.Org */
-                tess.pq.pqDelete(eUp.Org.pqHandle); /* __gl_pqSortDelete */
-                SpliceMergeVertices(tess, eLo.Sym.Lnext, eUp);
-            }
-        } else {
-            if (Geom.EdgeSign(eUp.Sym.Org, eLo.Org, eUp.Org) < 0) return false;
-
-            /* eLo.Org appears to be above eUp, so splice eLo.Org into eUp */
-            RegionAbove(regUp).dirty = regUp.dirty = true;
-            if (Mesh.__gl_meshSplitEdge(eUp.Sym) == null) throw new RuntimeException();
-            if (!Mesh.__gl_meshSplice(eLo.Sym.Lnext, eUp)) throw new RuntimeException();
-        }
-        return true;
-    }
-
-    static boolean CheckForLeftSplice(GLUtessellatorImpl tess, ActiveRegion regUp)
-/*
- * Check the upper and lower edge of "regUp", to make sure that the
- * eUp.Sym.Org is above eLo, or eLo.Sym.Org is below eUp (depending on which
- * destination is rightmost).
- *
- * Theoretically, this should always be true.  However, splitting an edge
- * into two pieces can change the results of previous tests.  For example,
- * suppose at one point we checked eUp and eLo, and decided that eUp.Sym.Org
- * is barely above eLo.  Then later, we split eLo into two edges (eg. from
- * a splice operation like this one).  This can change the result of
- * the test so that now eUp.Sym.Org is incident to eLo, or barely below it.
- * We must correct this condition to maintain the dictionary invariants
- * (otherwise new edges might get inserted in the wrong place in the
- * dictionary, and bad stuff will happen).
- *
- * We fix the problem by just splicing the offending vertex into the
- * other edge.
- */ {
-        ActiveRegion regLo = RegionBelow(regUp);
-        GLUhalfEdge eUp = regUp.eUp;
-        GLUhalfEdge eLo = regLo.eUp;
-        GLUhalfEdge e;
-
-        assert (!Geom.VertEq(eUp.Sym.Org, eLo.Sym.Org));
-
-        if (Geom.VertLeq(eUp.Sym.Org, eLo.Sym.Org)) {
-            if (Geom.EdgeSign(eUp.Sym.Org, eLo.Sym.Org, eUp.Org) < 0) return false;
-
-            /* eLo.Sym.Org is above eUp, so splice eLo.Sym.Org into eUp */
-            RegionAbove(regUp).dirty = regUp.dirty = true;
-            e = Mesh.__gl_meshSplitEdge(eUp);
-            if (e == null) throw new RuntimeException();
-            if (!Mesh.__gl_meshSplice(eLo.Sym, e)) throw new RuntimeException();
-            e.Lface.inside = regUp.inside;
-        } else {
-            if (Geom.EdgeSign(eLo.Sym.Org, eUp.Sym.Org, eLo.Org) > 0) return false;
-
-            /* eUp.Sym.Org is below eLo, so splice eUp.Sym.Org into eLo */
-            regUp.dirty = regLo.dirty = true;
-            e = Mesh.__gl_meshSplitEdge(eLo);
-            if (e == null) throw new RuntimeException();
-            if (!Mesh.__gl_meshSplice(eUp.Lnext, eLo.Sym)) throw new RuntimeException();
-            e.Sym.Lface.inside = regUp.inside;
-        }
-        return true;
-    }
-
-
-    static boolean CheckForIntersect(GLUtessellatorImpl tess, ActiveRegion regUp)
-/*
- * Check the upper and lower edges of the given region to see if
- * they intersect.  If so, create the intersection and add it
- * to the data structures.
- *
- * Returns true if adding the new intersection resulted in a recursive
- * call to AddRightEdges(); in this case all "dirty" regions have been
- * checked for intersections, and possibly regUp has been deleted.
- */ {
-        ActiveRegion regLo = RegionBelow(regUp);
-        GLUhalfEdge eUp = regUp.eUp;
-        GLUhalfEdge eLo = regLo.eUp;
-        GLUvertex orgUp = eUp.Org;
-        GLUvertex orgLo = eLo.Org;
-        GLUvertex dstUp = eUp.Sym.Org;
-        GLUvertex dstLo = eLo.Sym.Org;
-        double tMinUp, tMaxLo;
-        GLUvertex isect = new GLUvertex();
-        GLUvertex orgMin;
-        GLUhalfEdge e;
-
-        assert (!Geom.VertEq(dstLo, dstUp));
-        assert (Geom.EdgeSign(dstUp, tess.event, orgUp) <= 0);
-        assert (Geom.EdgeSign(dstLo, tess.event, orgLo) >= 0);
-        assert (orgUp != tess.event && orgLo != tess.event);
-        assert (!regUp.fixUpperEdge && !regLo.fixUpperEdge);
-
-        if (orgUp == orgLo) return false;	/* right endpoints are the same */
-
-        tMinUp = Math.min(orgUp.t, dstUp.t);
-        tMaxLo = Math.max(orgLo.t, dstLo.t);
-        if (tMinUp > tMaxLo) return false;	/* t ranges do not overlap */
-
-        if (Geom.VertLeq(orgUp, orgLo)) {
-            if (Geom.EdgeSign(dstLo, orgUp, orgLo) > 0) return false;
-        } else {
-            if (Geom.EdgeSign(dstUp, orgLo, orgUp) < 0) return false;
-        }
-
-        /* At this point the edges intersect, at least marginally */
-        DebugEvent(tess);
-
-        Geom.EdgeIntersect(dstUp, orgUp, dstLo, orgLo, isect);
-        /* The following properties are guaranteed: */
-        assert (Math.min(orgUp.t, dstUp.t) <= isect.t);
-        assert (isect.t <= Math.max(orgLo.t, dstLo.t));
-        assert (Math.min(dstLo.s, dstUp.s) <= isect.s);
-        assert (isect.s <= Math.max(orgLo.s, orgUp.s));
-
-        if (Geom.VertLeq(isect, tess.event)) {
-            /* The intersection point lies slightly to the left of the sweep line,
-             * so move it until it''s slightly to the right of the sweep line.
-             * (If we had perfect numerical precision, this would never happen
-             * in the first place).  The easiest and safest thing to do is
-             * replace the intersection by tess.event.
-             */
-            isect.s = tess.event.s;
-            isect.t = tess.event.t;
-        }
-        /* Similarly, if the computed intersection lies to the right of the
-         * rightmost origin (which should rarely happen), it can cause
-         * unbelievable inefficiency on sufficiently degenerate inputs.
-         * (If you have the test program, try running test54.d with the
-         * "X zoom" option turned on).
-         */
-        orgMin = Geom.VertLeq(orgUp, orgLo) ? orgUp : orgLo;
-        if (Geom.VertLeq(orgMin, isect)) {
-            isect.s = orgMin.s;
-            isect.t = orgMin.t;
-        }
-
-        if (Geom.VertEq(isect, orgUp) || Geom.VertEq(isect, orgLo)) {
-            /* Easy case -- intersection at one of the right endpoints */
-            CheckForRightSplice(tess, regUp);
-            return false;
-        }
-
-        if ((!Geom.VertEq(dstUp, tess.event)
-                && Geom.EdgeSign(dstUp, tess.event, isect) >= 0)
-                || (!Geom.VertEq(dstLo, tess.event)
-                && Geom.EdgeSign(dstLo, tess.event, isect) <= 0)) {
-            /* Very unusual -- the new upper or lower edge would pass on the
-             * wrong side of the sweep event, or through it.  This can happen
-             * due to very small numerical errors in the intersection calculation.
-             */
-            if (dstLo == tess.event) {
-                /* Splice dstLo into eUp, and process the new region(s) */
-                if (Mesh.__gl_meshSplitEdge(eUp.Sym) == null) throw new RuntimeException();
-                if (!Mesh.__gl_meshSplice(eLo.Sym, eUp)) throw new RuntimeException();
-                regUp = TopLeftRegion(regUp);
-                if (regUp == null) throw new RuntimeException();
-                eUp = RegionBelow(regUp).eUp;
-                FinishLeftRegions(tess, RegionBelow(regUp), regLo);
-                AddRightEdges(tess, regUp, eUp.Sym.Lnext, eUp, eUp, true);
-                return true;
-            }
-            if (dstUp == tess.event) {
-                /* Splice dstUp into eLo, and process the new region(s) */
-                if (Mesh.__gl_meshSplitEdge(eLo.Sym) == null) throw new RuntimeException();
-                if (!Mesh.__gl_meshSplice(eUp.Lnext, eLo.Sym.Lnext)) throw new RuntimeException();
-                regLo = regUp;
-                regUp = TopRightRegion(regUp);
-                e = RegionBelow(regUp).eUp.Sym.Onext;
-                regLo.eUp = eLo.Sym.Lnext;
-                eLo = FinishLeftRegions(tess, regLo, null);
-                AddRightEdges(tess, regUp, eLo.Onext, eUp.Sym.Onext, e, true);
-                return true;
-            }
-            /* Special case: called from ConnectRightVertex.  If either
-             * edge passes on the wrong side of tess.event, split it
-             * (and wait for ConnectRightVertex to splice it appropriately).
-             */
-            if (Geom.EdgeSign(dstUp, tess.event, isect) >= 0) {
-                RegionAbove(regUp).dirty = regUp.dirty = true;
-                if (Mesh.__gl_meshSplitEdge(eUp.Sym) == null) throw new RuntimeException();
-                eUp.Org.s = tess.event.s;
-                eUp.Org.t = tess.event.t;
-            }
-            if (Geom.EdgeSign(dstLo, tess.event, isect) <= 0) {
-                regUp.dirty = regLo.dirty = true;
-                if (Mesh.__gl_meshSplitEdge(eLo.Sym) == null) throw new RuntimeException();
-                eLo.Org.s = tess.event.s;
-                eLo.Org.t = tess.event.t;
-            }
-            /* leave the rest for ConnectRightVertex */
-            return false;
-        }
-
-        /* General case -- split both edges, splice into new vertex.
-         * When we do the splice operation, the order of the arguments is
-         * arbitrary as far as correctness goes.  However, when the operation
-         * creates a new face, the work done is proportional to the size of
-         * the new face.  We expect the faces in the processed part of
-         * the mesh (ie. eUp.Lface) to be smaller than the faces in the
-         * unprocessed original contours (which will be eLo.Sym.Lnext.Lface).
-         */
-        if (Mesh.__gl_meshSplitEdge(eUp.Sym) == null) throw new RuntimeException();
-        if (Mesh.__gl_meshSplitEdge(eLo.Sym) == null) throw new RuntimeException();
-        if (!Mesh.__gl_meshSplice(eLo.Sym.Lnext, eUp)) throw new RuntimeException();
-        eUp.Org.s = isect.s;
-        eUp.Org.t = isect.t;
-        eUp.Org.pqHandle = tess.pq.pqInsert(eUp.Org); /* __gl_pqSortInsert */
-        if (eUp.Org.pqHandle == Long.MAX_VALUE) {
-            tess.pq.pqDeletePriorityQ();	/* __gl_pqSortDeletePriorityQ */
-            tess.pq = null;
-            throw new RuntimeException();
-        }
-        GetIntersectData(tess, eUp.Org, orgUp, dstUp, orgLo, dstLo);
-        RegionAbove(regUp).dirty = regUp.dirty = regLo.dirty = true;
-        return false;
-    }
-
-    static void WalkDirtyRegions(GLUtessellatorImpl tess, ActiveRegion regUp)
-/*
- * When the upper or lower edge of any region changes, the region is
- * marked "dirty".  This routine walks through all the dirty regions
- * and makes sure that the dictionary invariants are satisfied
- * (see the comments at the beginning of this file).  Of course
- * new dirty regions can be created as we make changes to restore
- * the invariants.
- */ {
-        ActiveRegion regLo = RegionBelow(regUp);
-        GLUhalfEdge eUp, eLo;
-
-        for (; ;) {
-            /* Find the lowest dirty region (we walk from the bottom up). */
-            while (regLo.dirty) {
-                regUp = regLo;
-                regLo = RegionBelow(regLo);
-            }
-            if (!regUp.dirty) {
-                regLo = regUp;
-                regUp = RegionAbove(regUp);
-                if (regUp == null || !regUp.dirty) {
-                    /* We've walked all the dirty regions */
-                    return;
-                }
-            }
-            regUp.dirty = false;
-            eUp = regUp.eUp;
-            eLo = regLo.eUp;
-
-            if (eUp.Sym.Org != eLo.Sym.Org) {
-                /* Check that the edge ordering is obeyed at the Dst vertices. */
-                if (CheckForLeftSplice(tess, regUp)) {
-
-                    /* If the upper or lower edge was marked fixUpperEdge, then
-                     * we no longer need it (since these edges are needed only for
-                     * vertices which otherwise have no right-going edges).
-                     */
-                    if (regLo.fixUpperEdge) {
-                        DeleteRegion(tess, regLo);
-                        if (!Mesh.__gl_meshDelete(eLo)) throw new RuntimeException();
-                        regLo = RegionBelow(regUp);
-                        eLo = regLo.eUp;
-                    } else if (regUp.fixUpperEdge) {
-                        DeleteRegion(tess, regUp);
-                        if (!Mesh.__gl_meshDelete(eUp)) throw new RuntimeException();
-                        regUp = RegionAbove(regLo);
-                        eUp = regUp.eUp;
-                    }
-                }
-            }
-            if (eUp.Org != eLo.Org) {
-                if (eUp.Sym.Org != eLo.Sym.Org
-                        && !regUp.fixUpperEdge && !regLo.fixUpperEdge
-                        && (eUp.Sym.Org == tess.event || eLo.Sym.Org == tess.event)) {
-                    /* When all else fails in CheckForIntersect(), it uses tess.event
-                     * as the intersection location.  To make this possible, it requires
-                     * that tess.event lie between the upper and lower edges, and also
-                     * that neither of these is marked fixUpperEdge (since in the worst
-                     * case it might splice one of these edges into tess.event, and
-                     * violate the invariant that fixable edges are the only right-going
-                     * edge from their associated vertex).
-                         */
-                    if (CheckForIntersect(tess, regUp)) {
-                        /* WalkDirtyRegions() was called recursively; we're done */
-                        return;
-                    }
-                } else {
-                    /* Even though we can't use CheckForIntersect(), the Org vertices
-                     * may violate the dictionary edge ordering.  Check and correct this.
-                     */
-                    CheckForRightSplice(tess, regUp);
-                }
-            }
-            if (eUp.Org == eLo.Org && eUp.Sym.Org == eLo.Sym.Org) {
-                /* A degenerate loop consisting of only two edges -- delete it. */
-                AddWinding(eLo, eUp);
-                DeleteRegion(tess, regUp);
-                if (!Mesh.__gl_meshDelete(eUp)) throw new RuntimeException();
-                regUp = RegionAbove(regLo);
-            }
-        }
-    }
-
-
-    static void ConnectRightVertex(GLUtessellatorImpl tess, ActiveRegion regUp,
-                                   GLUhalfEdge eBottomLeft)
-/*
- * Purpose: connect a "right" vertex vEvent (one where all edges go left)
- * to the unprocessed portion of the mesh.  Since there are no right-going
- * edges, two regions (one above vEvent and one below) are being merged
- * into one.  "regUp" is the upper of these two regions.
- *
- * There are two reasons for doing this (adding a right-going edge):
- *  - if the two regions being merged are "inside", we must add an edge
- *    to keep them separated (the combined region would not be monotone).
- *  - in any case, we must leave some record of vEvent in the dictionary,
- *    so that we can merge vEvent with features that we have not seen yet.
- *    For example, maybe there is a vertical edge which passes just to
- *    the right of vEvent; we would like to splice vEvent into this edge.
- *
- * However, we don't want to connect vEvent to just any vertex.  We don''t
- * want the new edge to cross any other edges; otherwise we will create
- * intersection vertices even when the input data had no self-intersections.
- * (This is a bad thing; if the user's input data has no intersections,
- * we don't want to generate any false intersections ourselves.)
- *
- * Our eventual goal is to connect vEvent to the leftmost unprocessed
- * vertex of the combined region (the union of regUp and regLo).
- * But because of unseen vertices with all right-going edges, and also
- * new vertices which may be created by edge intersections, we don''t
- * know where that leftmost unprocessed vertex is.  In the meantime, we
- * connect vEvent to the closest vertex of either chain, and mark the region
- * as "fixUpperEdge".  This flag says to delete and reconnect this edge
- * to the next processed vertex on the boundary of the combined region.
- * Quite possibly the vertex we connected to will turn out to be the
- * closest one, in which case we won''t need to make any changes.
- */ {
-        GLUhalfEdge eNew;
-        GLUhalfEdge eTopLeft = eBottomLeft.Onext;
-        ActiveRegion regLo = RegionBelow(regUp);
-        GLUhalfEdge eUp = regUp.eUp;
-        GLUhalfEdge eLo = regLo.eUp;
-        boolean degenerate = false;
-
-        if (eUp.Sym.Org != eLo.Sym.Org) {
-            CheckForIntersect(tess, regUp);
-        }
-
-        /* Possible new degeneracies: upper or lower edge of regUp may pass
-         * through vEvent, or may coincide with new intersection vertex
-         */
-        if (Geom.VertEq(eUp.Org, tess.event)) {
-            if (!Mesh.__gl_meshSplice(eTopLeft.Sym.Lnext, eUp)) throw new RuntimeException();
-            regUp = TopLeftRegion(regUp);
-            if (regUp == null) throw new RuntimeException();
-            eTopLeft = RegionBelow(regUp).eUp;
-            FinishLeftRegions(tess, RegionBelow(regUp), regLo);
-            degenerate = true;
-        }
-        if (Geom.VertEq(eLo.Org, tess.event)) {
-            if (!Mesh.__gl_meshSplice(eBottomLeft, eLo.Sym.Lnext)) throw new RuntimeException();
-            eBottomLeft = FinishLeftRegions(tess, regLo, null);
-            degenerate = true;
-        }
-        if (degenerate) {
-            AddRightEdges(tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, true);
-            return;
-        }
-
-        /* Non-degenerate situation -- need to add a temporary, fixable edge.
-         * Connect to the closer of eLo.Org, eUp.Org.
-         */
-        if (Geom.VertLeq(eLo.Org, eUp.Org)) {
-            eNew = eLo.Sym.Lnext;
-        } else {
-            eNew = eUp;
-        }
-        eNew = Mesh.__gl_meshConnect(eBottomLeft.Onext.Sym, eNew);
-        if (eNew == null) throw new RuntimeException();
-
-        /* Prevent cleanup, otherwise eNew might disappear before we've even
-         * had a chance to mark it as a temporary edge.
-         */
-        AddRightEdges(tess, regUp, eNew, eNew.Onext, eNew.Onext, false);
-        eNew.Sym.activeRegion.fixUpperEdge = true;
-        WalkDirtyRegions(tess, regUp);
-    }
-
-/* Because vertices at exactly the same location are merged together
- * before we process the sweep event, some degenerate cases can't occur.
- * However if someone eventually makes the modifications required to
- * merge features which are close together, the cases below marked
- * TOLERANCE_NONZERO will be useful.  They were debugged before the
- * code to merge identical vertices in the main loop was added.
- */
-    private static final boolean TOLERANCE_NONZERO = false;
-
-    static void ConnectLeftDegenerate(GLUtessellatorImpl tess,
-                                      ActiveRegion regUp, GLUvertex vEvent)
-/*
- * The event vertex lies exacty on an already-processed edge or vertex.
- * Adding the new vertex involves splicing it into the already-processed
- * part of the mesh.
- */ {
-        GLUhalfEdge e, eTopLeft, eTopRight, eLast;
-        ActiveRegion reg;
-
-        e = regUp.eUp;
-        if (Geom.VertEq(e.Org, vEvent)) {
-            /* e.Org is an unprocessed vertex - just combine them, and wait
-             * for e.Org to be pulled from the queue
-             */
-            assert (TOLERANCE_NONZERO);
-            SpliceMergeVertices(tess, e, vEvent.anEdge);
-            return;
-        }
-
-        if (!Geom.VertEq(e.Sym.Org, vEvent)) {
-            /* General case -- splice vEvent into edge e which passes through it */
-            if (Mesh.__gl_meshSplitEdge(e.Sym) == null) throw new RuntimeException();
-            if (regUp.fixUpperEdge) {
-                /* This edge was fixable -- delete unused portion of original edge */
-                if (!Mesh.__gl_meshDelete(e.Onext)) throw new RuntimeException();
-                regUp.fixUpperEdge = false;
-            }
-            if (!Mesh.__gl_meshSplice(vEvent.anEdge, e)) throw new RuntimeException();
-            SweepEvent(tess, vEvent);	/* recurse */
-            return;
-        }
-
-        /* vEvent coincides with e.Sym.Org, which has already been processed.
-         * Splice in the additional right-going edges.
-         */
-        assert (TOLERANCE_NONZERO);
-        regUp = TopRightRegion(regUp);
-        reg = RegionBelow(regUp);
-        eTopRight = reg.eUp.Sym;
-        eTopLeft = eLast = eTopRight.Onext;
-        if (reg.fixUpperEdge) {
-            /* Here e.Sym.Org has only a single fixable edge going right.
-             * We can delete it since now we have some real right-going edges.
-             */
-            assert (eTopLeft != eTopRight);   /* there are some left edges too */
-            DeleteRegion(tess, reg);
-            if (!Mesh.__gl_meshDelete(eTopRight)) throw new RuntimeException();
-            eTopRight = eTopLeft.Sym.Lnext;
-        }
-        if (!Mesh.__gl_meshSplice(vEvent.anEdge, eTopRight)) throw new RuntimeException();
-        if (!Geom.EdgeGoesLeft(eTopLeft)) {
-            /* e.Sym.Org had no left-going edges -- indicate this to AddRightEdges() */
-            eTopLeft = null;
-        }
-        AddRightEdges(tess, regUp, eTopRight.Onext, eLast, eTopLeft, true);
-    }
-
-
-    static void ConnectLeftVertex(GLUtessellatorImpl tess, GLUvertex vEvent)
-/*
- * Purpose: connect a "left" vertex (one where both edges go right)
- * to the processed portion of the mesh.  Let R be the active region
- * containing vEvent, and let U and L be the upper and lower edge
- * chains of R.  There are two possibilities:
- *
- * - the normal case: split R into two regions, by connecting vEvent to
- *   the rightmost vertex of U or L lying to the left of the sweep line
- *
- * - the degenerate case: if vEvent is close enough to U or L, we
- *   merge vEvent into that edge chain.  The subcases are:
- *	- merging with the rightmost vertex of U or L
- *	- merging with the active edge of U or L
- *	- merging with an already-processed portion of U or L
- */ {
-        ActiveRegion regUp, regLo, reg;
-        GLUhalfEdge eUp, eLo, eNew;
-        ActiveRegion tmp = new ActiveRegion();
-
-        /* assert ( vEvent.anEdge.Onext.Onext == vEvent.anEdge ); */
-
-        /* Get a pointer to the active region containing vEvent */
-        tmp.eUp = vEvent.anEdge.Sym;
-        /* __GL_DICTLISTKEY */ /* __gl_dictListSearch */
-        regUp = (ActiveRegion) Dict.dictKey(Dict.dictSearch(tess.dict, tmp));
-        regLo = RegionBelow(regUp);
-        eUp = regUp.eUp;
-        eLo = regLo.eUp;
-
-        /* Try merging with U or L first */
-        if (Geom.EdgeSign(eUp.Sym.Org, vEvent, eUp.Org) == 0) {
-            ConnectLeftDegenerate(tess, regUp, vEvent);
-            return;
-        }
-
-        /* Connect vEvent to rightmost processed vertex of either chain.
-         * e.Sym.Org is the vertex that we will connect to vEvent.
-         */
-        reg = Geom.VertLeq(eLo.Sym.Org, eUp.Sym.Org) ? regUp : regLo;
-
-        if (regUp.inside || reg.fixUpperEdge) {
-            if (reg == regUp) {
-                eNew = Mesh.__gl_meshConnect(vEvent.anEdge.Sym, eUp.Lnext);
-                if (eNew == null) throw new RuntimeException();
-            } else {
-                GLUhalfEdge tempHalfEdge = Mesh.__gl_meshConnect(eLo.Sym.Onext.Sym, vEvent.anEdge);
-                if (tempHalfEdge == null) throw new RuntimeException();
-
-                eNew = tempHalfEdge.Sym;
-            }
-            if (reg.fixUpperEdge) {
-                if (!FixUpperEdge(reg, eNew)) throw new RuntimeException();
-            } else {
-                ComputeWinding(tess, AddRegionBelow(tess, regUp, eNew));
-            }
-            SweepEvent(tess, vEvent);
-        } else {
-            /* The new vertex is in a region which does not belong to the polygon.
-             * We don''t need to connect this vertex to the rest of the mesh.
-             */
-            AddRightEdges(tess, regUp, vEvent.anEdge, vEvent.anEdge, null, true);
-        }
-    }
-
-
-    static void SweepEvent(GLUtessellatorImpl tess, GLUvertex vEvent)
-/*
- * Does everything necessary when the sweep line crosses a vertex.
- * Updates the mesh and the edge dictionary.
- */ {
-        ActiveRegion regUp, reg;
-        GLUhalfEdge e, eTopLeft, eBottomLeft;
-
-        tess.event = vEvent;		/* for access in EdgeLeq() */
-        DebugEvent(tess);
-
-        /* Check if this vertex is the right endpoint of an edge that is
-         * already in the dictionary.  In this case we don't need to waste
-         * time searching for the location to insert new edges.
-         */
-        e = vEvent.anEdge;
-        while (e.activeRegion == null) {
-            e = e.Onext;
-            if (e == vEvent.anEdge) {
-                /* All edges go right -- not incident to any processed edges */
-                ConnectLeftVertex(tess, vEvent);
-                return;
-            }
-        }
-
-        /* Processing consists of two phases: first we "finish" all the
-         * active regions where both the upper and lower edges terminate
-         * at vEvent (ie. vEvent is closing off these regions).
-         * We mark these faces "inside" or "outside" the polygon according
-         * to their winding number, and delete the edges from the dictionary.
-         * This takes care of all the left-going edges from vEvent.
-         */
-        regUp = TopLeftRegion(e.activeRegion);
-        if (regUp == null) throw new RuntimeException();
-        reg = RegionBelow(regUp);
-        eTopLeft = reg.eUp;
-        eBottomLeft = FinishLeftRegions(tess, reg, null);
-
-        /* Next we process all the right-going edges from vEvent.  This
-         * involves adding the edges to the dictionary, and creating the
-         * associated "active regions" which record information about the
-         * regions between adjacent dictionary edges.
-         */
-        if (eBottomLeft.Onext == eTopLeft) {
-            /* No right-going edges -- add a temporary "fixable" edge */
-            ConnectRightVertex(tess, regUp, eBottomLeft);
-        } else {
-            AddRightEdges(tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, true);
-        }
-    }
-
-
-/* Make the sentinel coordinates big enough that they will never be
- * merged with real input features.  (Even with the largest possible
- * input contour and the maximum tolerance of 1.0, no merging will be
- * done with coordinates larger than 3 * GLU_TESS_MAX_COORD).
- */
-    private static final double SENTINEL_COORD = (4.0 * GLU_TESS_MAX_COORD);
-
-    static void AddSentinel(GLUtessellatorImpl tess, double t)
-/*
- * We add two sentinel edges above and below all other edges,
- * to avoid special cases at the top and bottom.
- */ {
-        GLUhalfEdge e;
-        ActiveRegion reg = new ActiveRegion();
-        //if (reg == null) throw new RuntimeException();
-
-        e = Mesh.__gl_meshMakeEdge(tess.mesh);
-        if (e == null) throw new RuntimeException();
-
-        e.Org.s = SENTINEL_COORD;
-        e.Org.t = t;
-        e.Sym.Org.s = -SENTINEL_COORD;
-        e.Sym.Org.t = t;
-        tess.event = e.Sym.Org;		/* initialize it */
-
-        reg.eUp = e;
-        reg.windingNumber = 0;
-        reg.inside = false;
-        reg.fixUpperEdge = false;
-        reg.sentinel = true;
-        reg.dirty = false;
-        reg.nodeUp = Dict.dictInsert(tess.dict, reg); /* __gl_dictListInsertBefore */
-        if (reg.nodeUp == null) throw new RuntimeException();
-    }
-
-
-    static void InitEdgeDict(final GLUtessellatorImpl tess)
-/*
- * We maintain an ordering of edge intersections with the sweep line.
- * This order is maintained in a dynamic dictionary.
- */ {
-        /* __gl_dictListNewDict */
-        tess.dict = Dict.dictNewDict(tess, new Dict.DictLeq() {
-            public boolean leq(Object frame, Object key1, Object key2) {
-                return EdgeLeq(tess, (ActiveRegion) key1, (ActiveRegion) key2);
-            }
-        });
-        if (tess.dict == null) throw new RuntimeException();
-
-        AddSentinel(tess, -SENTINEL_COORD);
-        AddSentinel(tess, SENTINEL_COORD);
-    }
-
-
-    static void DoneEdgeDict(GLUtessellatorImpl tess) {
-        ActiveRegion reg;
-        int fixedEdges = 0;
-
-        /* __GL_DICTLISTKEY */ /* __GL_DICTLISTMIN */
-        while ((reg = (ActiveRegion) Dict.dictKey(Dict.dictMin(tess.dict))) != null) {
-            /*
-             * At the end of all processing, the dictionary should contain
-             * only the two sentinel edges, plus at most one "fixable" edge
-             * created by ConnectRightVertex().
-             */
-            if (!reg.sentinel) {
-                assert (reg.fixUpperEdge);
-                assert (++fixedEdges == 1);
-            }
-            assert (reg.windingNumber == 0);
-            DeleteRegion(tess, reg);
-/*    __gl_meshDelete( reg.eUp );*/
-        }
-        Dict.dictDeleteDict(tess.dict);	/* __gl_dictListDeleteDict */
-    }
-
-
-    static void RemoveDegenerateEdges(GLUtessellatorImpl tess)
-/*
- * Remove zero-length edges, and contours with fewer than 3 vertices.
- */ {
-        GLUhalfEdge e, eNext, eLnext;
-        GLUhalfEdge eHead = tess.mesh.eHead;
-
-        /*LINTED*/
-        for (e = eHead.next; e != eHead; e = eNext) {
-            eNext = e.next;
-            eLnext = e.Lnext;
-
-            if (Geom.VertEq(e.Org, e.Sym.Org) && e.Lnext.Lnext != e) {
-                /* Zero-length edge, contour has at least 3 edges */
-
-                SpliceMergeVertices(tess, eLnext, e);	/* deletes e.Org */
-                if (!Mesh.__gl_meshDelete(e)) throw new RuntimeException(); /* e is a self-loop */
-                e = eLnext;
-                eLnext = e.Lnext;
-            }
-            if (eLnext.Lnext == e) {
-                /* Degenerate contour (one or two edges) */
-
-                if (eLnext != e) {
-                    if (eLnext == eNext || eLnext == eNext.Sym) {
-                        eNext = eNext.next;
-                    }
-                    if (!Mesh.__gl_meshDelete(eLnext)) throw new RuntimeException();
-                }
-                if (e == eNext || e == eNext.Sym) {
-                    eNext = eNext.next;
-                }
-                if (!Mesh.__gl_meshDelete(e)) throw new RuntimeException();
-            }
-        }
-    }
-
-    static boolean InitPriorityQ(GLUtessellatorImpl tess)
-/*
- * Insert all vertices into the priority queue which determines the
- * order in which vertices cross the sweep line.
- */ {
-        PriorityQ pq;
-        GLUvertex v, vHead;
-
-        /* __gl_pqSortNewPriorityQ */
-        pq = tess.pq = PriorityQ.pqNewPriorityQ(new PriorityQ.Leq() {
-            public boolean leq(Object key1, Object key2) {
-                return Geom.VertLeq(((GLUvertex) key1), (GLUvertex) key2);
-            }
-        });
-        if (pq == null) return false;
-
-        vHead = tess.mesh.vHead;
-        for (v = vHead.next; v != vHead; v = v.next) {
-            v.pqHandle = pq.pqInsert(v); /* __gl_pqSortInsert */
-            if (v.pqHandle == Long.MAX_VALUE) break;
-        }
-        if (v != vHead || !pq.pqInit()) { /* __gl_pqSortInit */
-            tess.pq.pqDeletePriorityQ();	/* __gl_pqSortDeletePriorityQ */
-            tess.pq = null;
-            return false;
-        }
-
-        return true;
-    }
-
-
-    static void DonePriorityQ(GLUtessellatorImpl tess) {
-        tess.pq.pqDeletePriorityQ(); /* __gl_pqSortDeletePriorityQ */
-    }
-
-
-    static boolean RemoveDegenerateFaces(GLUmesh mesh)
-/*
- * Delete any degenerate faces with only two edges.  WalkDirtyRegions()
- * will catch almost all of these, but it won't catch degenerate faces
- * produced by splice operations on already-processed edges.
- * The two places this can happen are in FinishLeftRegions(), when
- * we splice in a "temporary" edge produced by ConnectRightVertex(),
- * and in CheckForLeftSplice(), where we splice already-processed
- * edges to ensure that our dictionary invariants are not violated
- * by numerical errors.
- *
- * In both these cases it is *very* dangerous to delete the offending
- * edge at the time, since one of the routines further up the stack
- * will sometimes be keeping a pointer to that edge.
- */ {
-        GLUface f, fNext;
-        GLUhalfEdge e;
-
-        /*LINTED*/
-        for (f = mesh.fHead.next; f != mesh.fHead; f = fNext) {
-            fNext = f.next;
-            e = f.anEdge;
-            assert (e.Lnext != e);
-
-            if (e.Lnext.Lnext == e) {
-                /* A face with only two edges */
-                AddWinding(e.Onext, e);
-                if (!Mesh.__gl_meshDelete(e)) return false;
-            }
-        }
-        return true;
-    }
-
-    public static boolean __gl_computeInterior(GLUtessellatorImpl tess)
-/*
- * __gl_computeInterior( tess ) computes the planar arrangement specified
- * by the given contours, and further subdivides this arrangement
- * into regions.  Each region is marked "inside" if it belongs
- * to the polygon, according to the rule given by tess.windingRule.
- * Each interior region is guaranteed be monotone.
- */ {
-        GLUvertex v, vNext;
-
-        tess.fatalError = false;
-
-        /* Each vertex defines an event for our sweep line.  Start by inserting
-         * all the vertices in a priority queue.  Events are processed in
-         * lexicographic order, ie.
-         *
-         *	e1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)
-         */
-        RemoveDegenerateEdges(tess);
-        if (!InitPriorityQ(tess)) return false; /* if error */
-        InitEdgeDict(tess);
-
-        /* __gl_pqSortExtractMin */
-        while ((v = (GLUvertex) tess.pq.pqExtractMin()) != null) {
-            for (; ;) {
-                vNext = (GLUvertex) tess.pq.pqMinimum(); /* __gl_pqSortMinimum */
-                if (vNext == null || !Geom.VertEq(vNext, v)) break;
-
-                /* Merge together all vertices at exactly the same location.
-                 * This is more efficient than processing them one at a time,
-                 * simplifies the code (see ConnectLeftDegenerate), and is also
-                 * important for correct handling of certain degenerate cases.
-                 * For example, suppose there are two identical edges A and B
-                 * that belong to different contours (so without this code they would
-                 * be processed by separate sweep events).  Suppose another edge C
-                 * crosses A and B from above.  When A is processed, we split it
-                 * at its intersection point with C.  However this also splits C,
-                 * so when we insert B we may compute a slightly different
-                 * intersection point.  This might leave two edges with a small
-                 * gap between them.  This kind of error is especially obvious
-                 * when using boundary extraction (GLU_TESS_BOUNDARY_ONLY).
-                 */
-                vNext = (GLUvertex) tess.pq.pqExtractMin(); /* __gl_pqSortExtractMin*/
-                SpliceMergeVertices(tess, v.anEdge, vNext.anEdge);
-            }
-            SweepEvent(tess, v);
-        }
-
-        /* Set tess.event for debugging purposes */
-        /* __GL_DICTLISTKEY */ /* __GL_DICTLISTMIN */
-        tess.event = ((ActiveRegion) Dict.dictKey(Dict.dictMin(tess.dict))).eUp.Org;
-        DebugEvent(tess);
-        DoneEdgeDict(tess);
-        DonePriorityQ(tess);
-
-        if (!RemoveDegenerateFaces(tess.mesh)) return false;
-        Mesh.__gl_meshCheckMesh(tess.mesh);
-
-        return true;
-    }
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/TessMono.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/TessMono.java
deleted file mode 100644
index 94547b1..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/TessMono.java
+++ /dev/null
@@ -1,241 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-class TessMono {
-/* __gl_meshTessellateMonoRegion( face ) tessellates a monotone region
- * (what else would it do??)  The region must consist of a single
- * loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
- * case means that any vertical line intersects the interior of the
- * region in a single interval.
- *
- * Tessellation consists of adding interior edges (actually pairs of
- * half-edges), to split the region into non-overlapping triangles.
- *
- * The basic idea is explained in Preparata and Shamos (which I don''t
- * have handy right now), although their implementation is more
- * complicated than this one.  The are two edge chains, an upper chain
- * and a lower chain.  We process all vertices from both chains in order,
- * from right to left.
- *
- * The algorithm ensures that the following invariant holds after each
- * vertex is processed: the untessellated region consists of two
- * chains, where one chain (say the upper) is a single edge, and
- * the other chain is concave.  The left vertex of the single edge
- * is always to the left of all vertices in the concave chain.
- *
- * Each step consists of adding the rightmost unprocessed vertex to one
- * of the two chains, and forming a fan of triangles from the rightmost
- * of two chain endpoints.  Determining whether we can add each triangle
- * to the fan is a simple orientation test.  By making the fan as large
- * as possible, we restore the invariant (check it yourself).
- */
-    static boolean __gl_meshTessellateMonoRegion(GLUface face) {
-        GLUhalfEdge up, lo;
-
-        /* All edges are oriented CCW around the boundary of the region.
-         * First, find the half-edge whose origin vertex is rightmost.
-         * Since the sweep goes from left to right, face->anEdge should
-         * be close to the edge we want.
-         */
-        up = face.anEdge;
-        assert (up.Lnext != up && up.Lnext.Lnext != up);
-
-        for (; Geom.VertLeq(up.Sym.Org, up.Org); up = up.Onext.Sym)
-            ;
-        for (; Geom.VertLeq(up.Org, up.Sym.Org); up = up.Lnext)
-            ;
-        lo = up.Onext.Sym;
-
-        while (up.Lnext != lo) {
-            if (Geom.VertLeq(up.Sym.Org, lo.Org)) {
-                /* up.Sym.Org is on the left.  It is safe to form triangles from lo.Org.
-                 * The EdgeGoesLeft test guarantees progress even when some triangles
-                 * are CW, given that the upper and lower chains are truly monotone.
-                 */
-                while (lo.Lnext != up && (Geom.EdgeGoesLeft(lo.Lnext)
-                        || Geom.EdgeSign(lo.Org, lo.Sym.Org, lo.Lnext.Sym.Org) <= 0)) {
-                    GLUhalfEdge tempHalfEdge = Mesh.__gl_meshConnect(lo.Lnext, lo);
-                    if (tempHalfEdge == null) return false;
-                    lo = tempHalfEdge.Sym;
-                }
-                lo = lo.Onext.Sym;
-            } else {
-                /* lo.Org is on the left.  We can make CCW triangles from up.Sym.Org. */
-                while (lo.Lnext != up && (Geom.EdgeGoesRight(up.Onext.Sym)
-                        || Geom.EdgeSign(up.Sym.Org, up.Org, up.Onext.Sym.Org) >= 0)) {
-                    GLUhalfEdge tempHalfEdge = Mesh.__gl_meshConnect(up, up.Onext.Sym);
-                    if (tempHalfEdge == null) return false;
-                    up = tempHalfEdge.Sym;
-                }
-                up = up.Lnext;
-            }
-        }
-
-        /* Now lo.Org == up.Sym.Org == the leftmost vertex.  The remaining region
-         * can be tessellated in a fan from this leftmost vertex.
-         */
-        assert (lo.Lnext != up);
-        while (lo.Lnext.Lnext != up) {
-            GLUhalfEdge tempHalfEdge = Mesh.__gl_meshConnect(lo.Lnext, lo);
-            if (tempHalfEdge == null) return false;
-            lo = tempHalfEdge.Sym;
-        }
-
-        return true;
-    }
-
-
-/* __gl_meshTessellateInterior( mesh ) tessellates each region of
- * the mesh which is marked "inside" the polygon.  Each such region
- * must be monotone.
- */
-    public static boolean __gl_meshTessellateInterior(GLUmesh mesh) {
-        GLUface f, next;
-
-        /*LINTED*/
-        for (f = mesh.fHead.next; f != mesh.fHead; f = next) {
-            /* Make sure we don''t try to tessellate the new triangles. */
-            next = f.next;
-            if (f.inside) {
-                if (!__gl_meshTessellateMonoRegion(f)) return false;
-            }
-        }
-
-        return true;
-    }
-
-
-/* __gl_meshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
- * which are not marked "inside" the polygon.  Since further mesh operations
- * on NULL faces are not allowed, the main purpose is to clean up the
- * mesh so that exterior loops are not represented in the data structure.
- */
-    public static void __gl_meshDiscardExterior(GLUmesh mesh) {
-        GLUface f, next;
-
-        /*LINTED*/
-        for (f = mesh.fHead.next; f != mesh.fHead; f = next) {
-            /* Since f will be destroyed, save its next pointer. */
-            next = f.next;
-            if (!f.inside) {
-                Mesh.__gl_meshZapFace(f);
-            }
-        }
-    }
-
-//    private static final int MARKED_FOR_DELETION = 0x7fffffff;
-
-/* __gl_meshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
- * winding numbers on all edges so that regions marked "inside" the
- * polygon have a winding number of "value", and regions outside
- * have a winding number of 0.
- *
- * If keepOnlyBoundary is TRUE, it also deletes all edges which do not
- * separate an interior region from an exterior one.
- */
-    public static boolean __gl_meshSetWindingNumber(GLUmesh mesh, int value, boolean keepOnlyBoundary) {
-        GLUhalfEdge e, eNext;
-
-        for (e = mesh.eHead.next; e != mesh.eHead; e = eNext) {
-            eNext = e.next;
-            if (e.Sym.Lface.inside != e.Lface.inside) {
-
-                /* This is a boundary edge (one side is interior, one is exterior). */
-                e.winding = (e.Lface.inside) ? value : -value;
-            } else {
-
-                /* Both regions are interior, or both are exterior. */
-                if (!keepOnlyBoundary) {
-                    e.winding = 0;
-                } else {
-                    if (!Mesh.__gl_meshDelete(e)) return false;
-                }
-            }
-        }
-        return true;
-    }
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/TessState.java b/src/embeddedlibs/org/lwjglx/util/glu/tessellation/TessState.java
deleted file mode 100644
index e0d4d7d..0000000
--- a/src/embeddedlibs/org/lwjglx/util/glu/tessellation/TessState.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.
-* All rights reserved.
-*/
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.1 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** NOTE:  The Original Code (as defined below) has been licensed to Sun
-** Microsystems, Inc. ("Sun") under the SGI Free Software License B
-** (Version 1.1), shown above ("SGI License").   Pursuant to Section
-** 3.2(3) of the SGI License, Sun is distributing the Covered Code to
-** you under an alternative license ("Alternative License").  This
-** Alternative License includes all of the provisions of the SGI License
-** except that Section 2.2 and 11 are omitted.  Any differences between
-** the Alternative License and the SGI License are offered solely by Sun
-** and not by SGI.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-**
-** Author: Eric Veach, July 1994
-** Java Port: Pepijn Van Eeckhoudt, July 2003
-** Java Port: Nathan Parker Burg, August 2003
-*/
-package org.lwjglx.util.glu.tessellation;
-
-class TessState {
-    public static final int T_DORMANT = 0;
-    public static final int T_IN_POLYGON = 1;
-    public static final int T_IN_CONTOUR = 2;
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/vector/Matrix.java b/src/embeddedlibs/org/lwjglx/util/vector/Matrix.java
deleted file mode 100644
index 162fc34..0000000
--- a/src/embeddedlibs/org/lwjglx/util/vector/Matrix.java
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.vector;
-
-import java.io.Serializable;
-import java.nio.FloatBuffer;
-
-/**
- *
- * Base class for matrices. When a matrix is constructed it will be the identity
- * matrix unless otherwise stated.
- *
- * @author cix_foo <cix_foo@users.sourceforge.net>
- * @version $Revision: 3418 $
- * $Id: Matrix.java 3418 2010-09-28 21:11:35Z spasi $
- */
-public abstract class Matrix implements Serializable {
-
-	/**
-	 * Constructor for Matrix.
-	 */
-	protected Matrix() {
-		super();
-	}
-
-	/**
-	 * Set this matrix to be the identity matrix.
-	 * @return this
-	 */
-	public abstract Matrix setIdentity();
-
-
-	/**
-	 * Invert this matrix
-	 * @return this
-	 */
-	public abstract Matrix invert();
-
-
-	/**
-	 * Load from a float buffer. The buffer stores the matrix in column major
-	 * (OpenGL) order.
-	 *
-	 * @param buf A float buffer to read from
-	 * @return this
-	 */
-	public abstract Matrix load(FloatBuffer buf);
-
-
-	/**
-	 * Load from a float buffer. The buffer stores the matrix in row major
-	 * (mathematical) order.
-	 *
-	 * @param buf A float buffer to read from
-	 * @return this
-	 */
-	public abstract Matrix loadTranspose(FloatBuffer buf);
-
-
-	/**
-	 * Negate this matrix
-	 * @return this
-	 */
-	public abstract Matrix negate();
-
-
-	/**
-	 * Store this matrix in a float buffer. The matrix is stored in column
-	 * major (openGL) order.
-	 * @param buf The buffer to store this matrix in
-	 * @return this
-	 */
-	public abstract Matrix store(FloatBuffer buf);
-
-
-	/**
-	 * Store this matrix in a float buffer. The matrix is stored in row
-	 * major (maths) order.
-	 * @param buf The buffer to store this matrix in
-	 * @return this
-	 */
-	public abstract Matrix storeTranspose(FloatBuffer buf);
-
-
-	/**
-	 * Transpose this matrix
-	 * @return this
-	 */
-	public abstract Matrix transpose();
-
-
-	/**
-	 * Set this matrix to 0.
-	 * @return this
-	 */
-	public abstract Matrix setZero();
-
-
-	/**
-	 * @return the determinant of the matrix
-	 */
-	public abstract float determinant();
-
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/vector/Matrix2f.java b/src/embeddedlibs/org/lwjglx/util/vector/Matrix2f.java
deleted file mode 100644
index 98be10b..0000000
--- a/src/embeddedlibs/org/lwjglx/util/vector/Matrix2f.java
+++ /dev/null
@@ -1,400 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.vector;
-
-import java.io.Serializable;
-import java.nio.FloatBuffer;
-
-/**
- *
- * Holds a 2x2 matrix
- *
- * @author cix_foo <cix_foo@users.sourceforge.net>
- * @version $Revision: 3799 $
- * $Id: Matrix2f.java 3799 2012-09-12 11:29:40Z kappa1 $
- */
-
-public class Matrix2f extends Matrix implements Serializable {
-
-	private static final long serialVersionUID = 1L;
-
-	public float m00, m01, m10, m11;
-
-	/**
-	 * Constructor for Matrix2f. The matrix is initialised to the identity.
-	 */
-	public Matrix2f() {
-		setIdentity();
-	}
-
-	/**
-	 * Constructor
-	 */
-	public Matrix2f(Matrix2f src) {
-		load(src);
-	}
-
-	/**
-	 * Load from another matrix
-	 * @param src The source matrix
-	 * @return this
-	 */
-	public Matrix2f load(Matrix2f src) {
-		return load(src, this);
-	}
-
-	/**
-	 * Copy the source matrix to the destination matrix.
-	 * @param src The source matrix
-	 * @param dest The destination matrix, or null if a new one should be created.
-	 * @return The copied matrix
-	 */
-	public static Matrix2f load(Matrix2f src, Matrix2f dest) {
-		if (dest == null)
-			dest = new Matrix2f();
-
-		dest.m00 = src.m00;
-		dest.m01 = src.m01;
-		dest.m10 = src.m10;
-		dest.m11 = src.m11;
-
-		return dest;
-	}
-
-	/**
-	 * Load from a float buffer. The buffer stores the matrix in column major
-	 * (OpenGL) order.
-	 *
-	 * @param buf A float buffer to read from
-	 * @return this
-	 */
-	public Matrix load(FloatBuffer buf) {
-
-		m00 = buf.get();
-		m01 = buf.get();
-		m10 = buf.get();
-		m11 = buf.get();
-
-		return this;
-	}
-
-	/**
-	 * Load from a float buffer. The buffer stores the matrix in row major
-	 * (mathematical) order.
-	 *
-	 * @param buf A float buffer to read from
-	 * @return this
-	 */
-	public Matrix loadTranspose(FloatBuffer buf) {
-
-		m00 = buf.get();
-		m10 = buf.get();
-		m01 = buf.get();
-		m11 = buf.get();
-
-		return this;
-	}
-
-	/**
-	 * Store this matrix in a float buffer. The matrix is stored in column
-	 * major (openGL) order.
-	 * @param buf The buffer to store this matrix in
-	 */
-	public Matrix store(FloatBuffer buf) {
-		buf.put(m00);
-		buf.put(m01);
-		buf.put(m10);
-		buf.put(m11);
-		return this;
-	}
-
-	/**
-	 * Store this matrix in a float buffer. The matrix is stored in row
-	 * major (maths) order.
-	 * @param buf The buffer to store this matrix in
-	 */
-	public Matrix storeTranspose(FloatBuffer buf) {
-		buf.put(m00);
-		buf.put(m10);
-		buf.put(m01);
-		buf.put(m11);
-		return this;
-	}
-
-
-
-	/**
-	 * Add two matrices together and place the result in a third matrix.
-	 * @param left The left source matrix
-	 * @param right The right source matrix
-	 * @param dest The destination matrix, or null if a new one is to be created
-	 * @return the destination matrix
-	 */
-	public static Matrix2f add(Matrix2f left, Matrix2f right, Matrix2f dest) {
-		if (dest == null)
-			dest = new Matrix2f();
-
-		dest.m00 = left.m00 + right.m00;
-		dest.m01 = left.m01 + right.m01;
-		dest.m10 = left.m10 + right.m10;
-		dest.m11 = left.m11 + right.m11;
-
-		return dest;
-	}
-
-	/**
-	 * Subtract the right matrix from the left and place the result in a third matrix.
-	 * @param left The left source matrix
-	 * @param right The right source matrix
-	 * @param dest The destination matrix, or null if a new one is to be created
-	 * @return the destination matrix
-	 */
-	public static Matrix2f sub(Matrix2f left, Matrix2f right, Matrix2f dest) {
-		if (dest == null)
-			dest = new Matrix2f();
-
-		dest.m00 = left.m00 - right.m00;
-		dest.m01 = left.m01 - right.m01;
-		dest.m10 = left.m10 - right.m10;
-		dest.m11 = left.m11 - right.m11;
-
-		return dest;
-	}
-
-	/**
-	 * Multiply the right matrix by the left and place the result in a third matrix.
-	 * @param left The left source matrix
-	 * @param right The right source matrix
-	 * @param dest The destination matrix, or null if a new one is to be created
-	 * @return the destination matrix
-	 */
-	public static Matrix2f mul(Matrix2f left, Matrix2f right, Matrix2f dest) {
-		if (dest == null)
-			dest = new Matrix2f();
-
-		float m00 = left.m00 * right.m00 + left.m10 * right.m01;
-		float m01 = left.m01 * right.m00 + left.m11 * right.m01;
-		float m10 = left.m00 * right.m10 + left.m10 * right.m11;
-		float m11 = left.m01 * right.m10 + left.m11 * right.m11;
-
-		dest.m00 = m00;
-		dest.m01 = m01;
-		dest.m10 = m10;
-		dest.m11 = m11;
-
-		return dest;
-	}
-
-	/**
-	 * Transform a Vector by a matrix and return the result in a destination
-	 * vector.
-	 * @param left The left matrix
-	 * @param right The right vector
-	 * @param dest The destination vector, or null if a new one is to be created
-	 * @return the destination vector
-	 */
-	public static Vector2f transform(Matrix2f left, Vector2f right, Vector2f dest) {
-		if (dest == null)
-			dest = new Vector2f();
-
-		float x = left.m00 * right.x + left.m10 * right.y;
-		float y = left.m01 * right.x + left.m11 * right.y;
-
-		dest.x = x;
-		dest.y = y;
-
-		return dest;
-	}
-
-	/**
-	 * Transpose this matrix
-	 * @return this
-	 */
-	public Matrix transpose() {
-		return transpose(this);
-	}
-
-	/**
-	 * Transpose this matrix and place the result in another matrix.
-	 * @param dest The destination matrix or null if a new matrix is to be created
-	 * @return the transposed matrix
-	 */
-	public Matrix2f transpose(Matrix2f dest) {
-		return transpose(this, dest);
-	}
-
-	/**
-	 * Transpose the source matrix and place the result in the destination matrix.
-	 * @param src The source matrix or null if a new matrix is to be created
-	 * @param dest The destination matrix or null if a new matrix is to be created
-	 * @return the transposed matrix
-	 */
-	public static Matrix2f transpose(Matrix2f src, Matrix2f dest) {
-		if (dest == null)
-			dest = new Matrix2f();
-
-		float m01 = src.m10;
-		float m10 = src.m01;
-
-		dest.m01 = m01;
-		dest.m10 = m10;
-
-		return dest;
-	}
-
-	/**
-	 * Invert this matrix
-	 * @return this if successful, null otherwise
-	 */
-	public Matrix invert() {
-		return invert(this, this);
-	}
-
-	/**
-	 * Invert the source matrix and place the result in the destination matrix.
-	 * @param src The source matrix to be inverted
-	 * @param dest The destination matrix or null if a new matrix is to be created
-	 * @return The inverted matrix, or null if source can't be reverted.
-	 */
-	public static Matrix2f invert(Matrix2f src, Matrix2f dest) {
-		/*
-		 *inv(A) = 1/det(A) * adj(A);
-		 */
-
-		float determinant = src.determinant();
-		if (determinant != 0) {
-			if (dest == null)
-				dest = new Matrix2f();
-			float determinant_inv = 1f/determinant;
-			float t00 =  src.m11*determinant_inv;
-			float t01 = -src.m01*determinant_inv;
-			float t11 =  src.m00*determinant_inv;
-			float t10 = -src.m10*determinant_inv;
-
-			dest.m00 = t00;
-			dest.m01 = t01;
-			dest.m10 = t10;
-			dest.m11 = t11;
-			return dest;
-		} else
-			return null;
-	}
-
-	/**
-	 * Returns a string representation of this matrix
-	 */
-	public String toString() {
-		StringBuilder buf = new StringBuilder();
-		buf.append(m00).append(' ').append(m10).append(' ').append('\n');
-		buf.append(m01).append(' ').append(m11).append(' ').append('\n');
-		return buf.toString();
-	}
-
-	/**
-	 * Negate this matrix
-	 * @return this
-	 */
-	public Matrix negate() {
-		return negate(this);
-	}
-
-	/**
-	 * Negate this matrix and stash the result in another matrix.
-	 * @param dest The destination matrix, or null if a new matrix is to be created
-	 * @return the negated matrix
-	 */
-	public Matrix2f negate(Matrix2f dest) {
-		return negate(this, dest);
-	}
-
-	/**
-	 * Negate the source matrix and stash the result in the destination matrix.
-	 * @param src The source matrix to be negated
-	 * @param dest The destination matrix, or null if a new matrix is to be created
-	 * @return the negated matrix
-	 */
-	public static Matrix2f negate(Matrix2f src, Matrix2f dest) {
-		if (dest == null)
-			dest = new Matrix2f();
-
-		dest.m00 = -src.m00;
-		dest.m01 = -src.m01;
-		dest.m10 = -src.m10;
-		dest.m11 = -src.m11;
-
-		return dest;
-	}
-
-	/**
-	 * Set this matrix to be the identity matrix.
-	 * @return this
-	 */
-	public Matrix setIdentity() {
-		return setIdentity(this);
-	}
-
-	/**
-	 * Set the source matrix to be the identity matrix.
-	 * @param src The matrix to set to the identity.
-	 * @return The source matrix
-	 */
-	public static Matrix2f setIdentity(Matrix2f src) {
-		src.m00 = 1.0f;
-		src.m01 = 0.0f;
-		src.m10 = 0.0f;
-		src.m11 = 1.0f;
-		return src;
-	}
-
-	/**
-	 * Set this matrix to 0.
-	 * @return this
-	 */
-	public Matrix setZero() {
-		return setZero(this);
-	}
-
-	public static Matrix2f setZero(Matrix2f src) {
-		src.m00 = 0.0f;
-		src.m01 = 0.0f;
-		src.m10 = 0.0f;
-		src.m11 = 0.0f;
-		return src;
-	}
-
-	/* (non-Javadoc)
-	 * @see org.lwjgl.vector.Matrix#determinant()
-	 */
-	public float determinant() {
-		return m00 * m11 - m01*m10;
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/vector/Matrix3f.java b/src/embeddedlibs/org/lwjglx/util/vector/Matrix3f.java
deleted file mode 100644
index ad810b0..0000000
--- a/src/embeddedlibs/org/lwjglx/util/vector/Matrix3f.java
+++ /dev/null
@@ -1,510 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.vector;
-
-import java.io.Serializable;
-import java.nio.FloatBuffer;
-
-/**
- *
- * Holds a 3x3 matrix.
- *
- * @author cix_foo <cix_foo@users.sourceforge.net>
- * @version $Revision: 3799 $
- * $Id: Matrix3f.java 3799 2012-09-12 11:29:40Z kappa1 $
- */
-
-public class Matrix3f extends Matrix implements Serializable {
-
-	private static final long serialVersionUID = 1L;
-
-	public float m00,
-		m01,
-		m02,
-		m10,
-		m11,
-		m12,
-		m20,
-		m21,
-		m22;
-
-	/**
-	 * Constructor for Matrix3f. Matrix is initialised to the identity.
-	 */
-	public Matrix3f() {
-		super();
-		setIdentity();
-	}
-
-	/**
-	 * Load from another matrix
-	 * @param src The source matrix
-	 * @return this
-	 */
-	public Matrix3f load(Matrix3f src) {
-		return load(src, this);
-	}
-
-	/**
-	 * Copy source matrix to destination matrix
-	 * @param src The source matrix
-	 * @param dest The destination matrix, or null of a new matrix is to be created
-	 * @return The copied matrix
-	 */
-	public static Matrix3f load(Matrix3f src, Matrix3f dest) {
-		if (dest == null)
-			dest = new Matrix3f();
-
-		dest.m00 = src.m00;
-		dest.m10 = src.m10;
-		dest.m20 = src.m20;
-		dest.m01 = src.m01;
-		dest.m11 = src.m11;
-		dest.m21 = src.m21;
-		dest.m02 = src.m02;
-		dest.m12 = src.m12;
-		dest.m22 = src.m22;
-
-		return dest;
-	}
-
-	/**
-	 * Load from a float buffer. The buffer stores the matrix in column major
-	 * (OpenGL) order.
-	 *
-	 * @param buf A float buffer to read from
-	 * @return this
-	 */
-	public Matrix load(FloatBuffer buf) {
-
-		m00 = buf.get();
-		m01 = buf.get();
-		m02 = buf.get();
-		m10 = buf.get();
-		m11 = buf.get();
-		m12 = buf.get();
-		m20 = buf.get();
-		m21 = buf.get();
-		m22 = buf.get();
-
-		return this;
-	}
-
-	/**
-	 * Load from a float buffer. The buffer stores the matrix in row major
-	 * (maths) order.
-	 *
-	 * @param buf A float buffer to read from
-	 * @return this
-	 */
-	public Matrix loadTranspose(FloatBuffer buf) {
-
-		m00 = buf.get();
-		m10 = buf.get();
-		m20 = buf.get();
-		m01 = buf.get();
-		m11 = buf.get();
-		m21 = buf.get();
-		m02 = buf.get();
-		m12 = buf.get();
-		m22 = buf.get();
-
-		return this;
-	}
-
-	/**
-	 * Store this matrix in a float buffer. The matrix is stored in column
-	 * major (openGL) order.
-	 * @param buf The buffer to store this matrix in
-	 */
-	public Matrix store(FloatBuffer buf) {
-		buf.put(m00);
-		buf.put(m01);
-		buf.put(m02);
-		buf.put(m10);
-		buf.put(m11);
-		buf.put(m12);
-		buf.put(m20);
-		buf.put(m21);
-		buf.put(m22);
-		return this;
-	}
-
-	/**
-	 * Store this matrix in a float buffer. The matrix is stored in row
-	 * major (maths) order.
-	 * @param buf The buffer to store this matrix in
-	 */
-	public Matrix storeTranspose(FloatBuffer buf) {
-		buf.put(m00);
-		buf.put(m10);
-		buf.put(m20);
-		buf.put(m01);
-		buf.put(m11);
-		buf.put(m21);
-		buf.put(m02);
-		buf.put(m12);
-		buf.put(m22);
-		return this;
-	}
-
-	/**
-	 * Add two matrices together and place the result in a third matrix.
-	 * @param left The left source matrix
-	 * @param right The right source matrix
-	 * @param dest The destination matrix, or null if a new one is to be created
-	 * @return the destination matrix
-	 */
-	public static Matrix3f add(Matrix3f left, Matrix3f right, Matrix3f dest) {
-		if (dest == null)
-			dest = new Matrix3f();
-
-		dest.m00 = left.m00 + right.m00;
-		dest.m01 = left.m01 + right.m01;
-		dest.m02 = left.m02 + right.m02;
-		dest.m10 = left.m10 + right.m10;
-		dest.m11 = left.m11 + right.m11;
-		dest.m12 = left.m12 + right.m12;
-		dest.m20 = left.m20 + right.m20;
-		dest.m21 = left.m21 + right.m21;
-		dest.m22 = left.m22 + right.m22;
-
-		return dest;
-	}
-
-	/**
-	 * Subtract the right matrix from the left and place the result in a third matrix.
-	 * @param left The left source matrix
-	 * @param right The right source matrix
-	 * @param dest The destination matrix, or null if a new one is to be created
-	 * @return the destination matrix
-	 */
-	public static Matrix3f sub(Matrix3f left, Matrix3f right, Matrix3f dest) {
-		if (dest == null)
-			dest = new Matrix3f();
-
-		dest.m00 = left.m00 - right.m00;
-		dest.m01 = left.m01 - right.m01;
-		dest.m02 = left.m02 - right.m02;
-		dest.m10 = left.m10 - right.m10;
-		dest.m11 = left.m11 - right.m11;
-		dest.m12 = left.m12 - right.m12;
-		dest.m20 = left.m20 - right.m20;
-		dest.m21 = left.m21 - right.m21;
-		dest.m22 = left.m22 - right.m22;
-
-		return dest;
-	}
-
-	/**
-	 * Multiply the right matrix by the left and place the result in a third matrix.
-	 * @param left The left source matrix
-	 * @param right The right source matrix
-	 * @param dest The destination matrix, or null if a new one is to be created
-	 * @return the destination matrix
-	 */
-	public static Matrix3f mul(Matrix3f left, Matrix3f right, Matrix3f dest) {
-		if (dest == null)
-			dest = new Matrix3f();
-
-		float m00 =
-			left.m00 * right.m00 + left.m10 * right.m01 + left.m20 * right.m02;
-		float m01 =
-			left.m01 * right.m00 + left.m11 * right.m01 + left.m21 * right.m02;
-		float m02 =
-			left.m02 * right.m00 + left.m12 * right.m01 + left.m22 * right.m02;
-		float m10 =
-			left.m00 * right.m10 + left.m10 * right.m11 + left.m20 * right.m12;
-		float m11 =
-			left.m01 * right.m10 + left.m11 * right.m11 + left.m21 * right.m12;
-		float m12 =
-			left.m02 * right.m10 + left.m12 * right.m11 + left.m22 * right.m12;
-		float m20 =
-			left.m00 * right.m20 + left.m10 * right.m21 + left.m20 * right.m22;
-		float m21 =
-			left.m01 * right.m20 + left.m11 * right.m21 + left.m21 * right.m22;
-		float m22 =
-			left.m02 * right.m20 + left.m12 * right.m21 + left.m22 * right.m22;
-
-		dest.m00 = m00;
-		dest.m01 = m01;
-		dest.m02 = m02;
-		dest.m10 = m10;
-		dest.m11 = m11;
-		dest.m12 = m12;
-		dest.m20 = m20;
-		dest.m21 = m21;
-		dest.m22 = m22;
-
-		return dest;
-	}
-
-	/**
-	 * Transform a Vector by a matrix and return the result in a destination
-	 * vector.
-	 * @param left The left matrix
-	 * @param right The right vector
-	 * @param dest The destination vector, or null if a new one is to be created
-	 * @return the destination vector
-	 */
-	public static Vector3f transform(Matrix3f left, Vector3f right, Vector3f dest) {
-		if (dest == null)
-			dest = new Vector3f();
-
-		float x = left.m00 * right.x + left.m10 * right.y + left.m20 * right.z;
-		float y = left.m01 * right.x + left.m11 * right.y + left.m21 * right.z;
-		float z = left.m02 * right.x + left.m12 * right.y + left.m22 * right.z;
-
-		dest.x = x;
-		dest.y = y;
-		dest.z = z;
-
-		return dest;
-	}
-
-	/**
-	 * Transpose this matrix
-	 * @return this
-	 */
-	public Matrix transpose() {
-		return transpose(this, this);
-	}
-
-	/**
-	 * Transpose this matrix and place the result in another matrix
-	 * @param dest The destination matrix or null if a new matrix is to be created
-	 * @return the transposed matrix
-	 */
-	public Matrix3f transpose(Matrix3f dest) {
-		return transpose(this, dest);
-	}
-
-	/**
-	 * Transpose the source matrix and place the result into the destination matrix
-	 * @param src The source matrix to be transposed
-	 * @param dest The destination matrix or null if a new matrix is to be created
-	 * @return the transposed matrix
-	 */
-	public static Matrix3f transpose(Matrix3f src, Matrix3f dest) {
-		if (dest == null)
-		   dest = new Matrix3f();
-		float m00 = src.m00;
-		float m01 = src.m10;
-		float m02 = src.m20;
-		float m10 = src.m01;
-		float m11 = src.m11;
-		float m12 = src.m21;
-		float m20 = src.m02;
-		float m21 = src.m12;
-		float m22 = src.m22;
-
-		dest.m00 = m00;
-		dest.m01 = m01;
-		dest.m02 = m02;
-		dest.m10 = m10;
-		dest.m11 = m11;
-		dest.m12 = m12;
-		dest.m20 = m20;
-		dest.m21 = m21;
-		dest.m22 = m22;
-		return dest;
-	}
-
-	/**
-	 * @return the determinant of the matrix
-	 */
-	public float determinant() {
-		float f =
-			m00 * (m11 * m22 - m12 * m21)
-				+ m01 * (m12 * m20 - m10 * m22)
-				+ m02 * (m10 * m21 - m11 * m20);
-		return f;
-	}
-
-	/**
-	 * Returns a string representation of this matrix
-	 */
-	public String toString() {
-		StringBuilder buf = new StringBuilder();
-		buf.append(m00).append(' ').append(m10).append(' ').append(m20).append(' ').append('\n');
-		buf.append(m01).append(' ').append(m11).append(' ').append(m21).append(' ').append('\n');
-		buf.append(m02).append(' ').append(m12).append(' ').append(m22).append(' ').append('\n');
-		return buf.toString();
-	}
-
-	/**
-	 * Invert this matrix
-	 * @return this if successful, null otherwise
-	 */
-	public Matrix invert() {
-		return invert(this, this);
-	}
-
-	/**
-	 * Invert the source matrix and put the result into the destination matrix
-	 * @param src The source matrix to be inverted
-	 * @param dest The destination matrix, or null if a new one is to be created
-	 * @return The inverted matrix if successful, null otherwise
-	 */
-	public static Matrix3f invert(Matrix3f src, Matrix3f dest) {
-		float determinant = src.determinant();
-
-		if (determinant != 0) {
-			if (dest == null)
-				dest = new Matrix3f();
-			 /* do it the ordinary way
-			  *
-			  * inv(A) = 1/det(A) * adj(T), where adj(T) = transpose(Conjugate Matrix)
-			  *
-			  * m00 m01 m02
-			  * m10 m11 m12
-			  * m20 m21 m22
-			  */
-			 float determinant_inv = 1f/determinant;
-
-			 // get the conjugate matrix
-			 float t00 = src.m11 * src.m22 - src.m12* src.m21;
-			 float t01 = - src.m10 * src.m22 + src.m12 * src.m20;
-			 float t02 = src.m10 * src.m21 - src.m11 * src.m20;
-			 float t10 = - src.m01 * src.m22 + src.m02 * src.m21;
-			 float t11 = src.m00 * src.m22 - src.m02 * src.m20;
-			 float t12 = - src.m00 * src.m21 + src.m01 * src.m20;
-			 float t20 = src.m01 * src.m12 - src.m02 * src.m11;
-			 float t21 = -src.m00 * src.m12 + src.m02 * src.m10;
-			 float t22 = src.m00 * src.m11 - src.m01 * src.m10;
-
-			 dest.m00 = t00*determinant_inv;
-			 dest.m11 = t11*determinant_inv;
-			 dest.m22 = t22*determinant_inv;
-			 dest.m01 = t10*determinant_inv;
-			 dest.m10 = t01*determinant_inv;
-			 dest.m20 = t02*determinant_inv;
-			 dest.m02 = t20*determinant_inv;
-			 dest.m12 = t21*determinant_inv;
-			 dest.m21 = t12*determinant_inv;
-			 return dest;
-		} else
-			 return null;
-	}
-
-
-	/**
-	 * Negate this matrix
-	 * @return this
-	 */
-	public Matrix negate() {
-		return negate(this);
-	}
-
-	/**
-	 * Negate this matrix and place the result in a destination matrix.
-	 * @param dest The destination matrix, or null if a new matrix is to be created
-	 * @return the negated matrix
-	 */
-	public Matrix3f negate(Matrix3f dest) {
-		return negate(this, dest);
-	}
-
-	/**
-	 * Negate the source matrix and place the result in the destination matrix.
-	 * @param src The source matrix
-	 * @param dest The destination matrix, or null if a new matrix is to be created
-	 * @return the negated matrix
-	 */
-	public static Matrix3f negate(Matrix3f src, Matrix3f dest) {
-		if (dest == null)
-			dest = new Matrix3f();
-
-		dest.m00 = -src.m00;
-		dest.m01 = -src.m02;
-		dest.m02 = -src.m01;
-		dest.m10 = -src.m10;
-		dest.m11 = -src.m12;
-		dest.m12 = -src.m11;
-		dest.m20 = -src.m20;
-		dest.m21 = -src.m22;
-		dest.m22 = -src.m21;
-		return dest;
-	}
-
-	/**
-	 * Set this matrix to be the identity matrix.
-	 * @return this
-	 */
-	public Matrix setIdentity() {
-		return setIdentity(this);
-	}
-
-	/**
-	 * Set the matrix to be the identity matrix.
-	 * @param m The matrix to be set to the identity
-	 * @return m
-	 */
-	public static Matrix3f setIdentity(Matrix3f m) {
-		m.m00 = 1.0f;
-		m.m01 = 0.0f;
-		m.m02 = 0.0f;
-		m.m10 = 0.0f;
-		m.m11 = 1.0f;
-		m.m12 = 0.0f;
-		m.m20 = 0.0f;
-		m.m21 = 0.0f;
-		m.m22 = 1.0f;
-		return m;
-	}
-
-	/**
-	 * Set this matrix to 0.
-	 * @return this
-	 */
-	public Matrix setZero() {
-		return setZero(this);
-	}
-
-	/**
-	 * Set the matrix matrix to 0.
-	 * @param m The matrix to be set to 0
-	 * @return m
-	 */
-	public static Matrix3f setZero(Matrix3f m) {
-		m.m00 = 0.0f;
-		m.m01 = 0.0f;
-		m.m02 = 0.0f;
-		m.m10 = 0.0f;
-		m.m11 = 0.0f;
-		m.m12 = 0.0f;
-		m.m20 = 0.0f;
-		m.m21 = 0.0f;
-		m.m22 = 0.0f;
-		return m;
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/vector/Matrix4f.java b/src/embeddedlibs/org/lwjglx/util/vector/Matrix4f.java
deleted file mode 100644
index 0fc772d..0000000
--- a/src/embeddedlibs/org/lwjglx/util/vector/Matrix4f.java
+++ /dev/null
@@ -1,849 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.vector;
-
-import java.io.Serializable;
-import java.nio.FloatBuffer;
-
-/**
- * Holds a 4x4 float matrix.
- *
- * @author foo
- */
-public class Matrix4f extends Matrix implements Serializable {
-	private static final long serialVersionUID = 1L;
-
-	public float m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33;
-
-	/**
-	 * Construct a new matrix, initialized to the identity.
-	 */
-	public Matrix4f() {
-		super();
-		setIdentity();
-	}
-
-	public Matrix4f(final Matrix4f src) {
-		super();
-		load(src);
-	}
-
-	/**
-	 * Returns a string representation of this matrix
-	 */
-	public String toString() {
-		StringBuilder buf = new StringBuilder();
-		buf.append(m00).append(' ').append(m10).append(' ').append(m20).append(' ').append(m30).append('\n');
-		buf.append(m01).append(' ').append(m11).append(' ').append(m21).append(' ').append(m31).append('\n');
-		buf.append(m02).append(' ').append(m12).append(' ').append(m22).append(' ').append(m32).append('\n');
-		buf.append(m03).append(' ').append(m13).append(' ').append(m23).append(' ').append(m33).append('\n');
-		return buf.toString();
-	}
-
-	/**
-	 * Set this matrix to be the identity matrix.
-	 * @return this
-	 */
-	public Matrix setIdentity() {
-		return setIdentity(this);
-	}
-
-	/**
-	 * Set the given matrix to be the identity matrix.
-	 * @param m The matrix to set to the identity
-	 * @return m
-	 */
-	public static Matrix4f setIdentity(Matrix4f m) {
-		m.m00 = 1.0f;
-		m.m01 = 0.0f;
-		m.m02 = 0.0f;
-		m.m03 = 0.0f;
-		m.m10 = 0.0f;
-		m.m11 = 1.0f;
-		m.m12 = 0.0f;
-		m.m13 = 0.0f;
-		m.m20 = 0.0f;
-		m.m21 = 0.0f;
-		m.m22 = 1.0f;
-		m.m23 = 0.0f;
-		m.m30 = 0.0f;
-		m.m31 = 0.0f;
-		m.m32 = 0.0f;
-		m.m33 = 1.0f;
-
-		return m;
-	}
-
-	/**
-	 * Set this matrix to 0.
-	 * @return this
-	 */
-	public Matrix setZero() {
-		return setZero(this);
-	}
-
-	/**
-	 * Set the given matrix to 0.
-	 * @param m The matrix to set to 0
-	 * @return m
-	 */
-	public static Matrix4f setZero(Matrix4f m) {
-		m.m00 = 0.0f;
-		m.m01 = 0.0f;
-		m.m02 = 0.0f;
-		m.m03 = 0.0f;
-		m.m10 = 0.0f;
-		m.m11 = 0.0f;
-		m.m12 = 0.0f;
-		m.m13 = 0.0f;
-		m.m20 = 0.0f;
-		m.m21 = 0.0f;
-		m.m22 = 0.0f;
-		m.m23 = 0.0f;
-		m.m30 = 0.0f;
-		m.m31 = 0.0f;
-		m.m32 = 0.0f;
-		m.m33 = 0.0f;
-
-		return m;
-	}
-
-	/**
-	 * Load from another matrix4f
-	 * @param src The source matrix
-	 * @return this
-	 */
-	public Matrix4f load(Matrix4f src) {
-		return load(src, this);
-	}
-
-	/**
-	 * Copy the source matrix to the destination matrix
-	 * @param src The source matrix
-	 * @param dest The destination matrix, or null of a new one is to be created
-	 * @return The copied matrix
-	 */
-	public static Matrix4f load(Matrix4f src, Matrix4f dest) {
-		if (dest == null)
-			dest = new Matrix4f();
-		dest.m00 = src.m00;
-		dest.m01 = src.m01;
-		dest.m02 = src.m02;
-		dest.m03 = src.m03;
-		dest.m10 = src.m10;
-		dest.m11 = src.m11;
-		dest.m12 = src.m12;
-		dest.m13 = src.m13;
-		dest.m20 = src.m20;
-		dest.m21 = src.m21;
-		dest.m22 = src.m22;
-		dest.m23 = src.m23;
-		dest.m30 = src.m30;
-		dest.m31 = src.m31;
-		dest.m32 = src.m32;
-		dest.m33 = src.m33;
-
-		return dest;
-	}
-
-	/**
-	 * Load from a float buffer. The buffer stores the matrix in column major
-	 * (OpenGL) order.
-	 *
-	 * @param buf A float buffer to read from
-	 * @return this
-	 */
-	public Matrix load(FloatBuffer buf) {
-
-		m00 = buf.get();
-		m01 = buf.get();
-		m02 = buf.get();
-		m03 = buf.get();
-		m10 = buf.get();
-		m11 = buf.get();
-		m12 = buf.get();
-		m13 = buf.get();
-		m20 = buf.get();
-		m21 = buf.get();
-		m22 = buf.get();
-		m23 = buf.get();
-		m30 = buf.get();
-		m31 = buf.get();
-		m32 = buf.get();
-		m33 = buf.get();
-
-		return this;
-	}
-
-	/**
-	 * Load from a float buffer. The buffer stores the matrix in row major
-	 * (maths) order.
-	 *
-	 * @param buf A float buffer to read from
-	 * @return this
-	 */
-	public Matrix loadTranspose(FloatBuffer buf) {
-
-		m00 = buf.get();
-		m10 = buf.get();
-		m20 = buf.get();
-		m30 = buf.get();
-		m01 = buf.get();
-		m11 = buf.get();
-		m21 = buf.get();
-		m31 = buf.get();
-		m02 = buf.get();
-		m12 = buf.get();
-		m22 = buf.get();
-		m32 = buf.get();
-		m03 = buf.get();
-		m13 = buf.get();
-		m23 = buf.get();
-		m33 = buf.get();
-
-		return this;
-	}
-
-	/**
-	 * Store this matrix in a float buffer. The matrix is stored in column
-	 * major (openGL) order.
-	 * @param buf The buffer to store this matrix in
-	 */
-	public Matrix store(FloatBuffer buf) {
-		buf.put(m00);
-		buf.put(m01);
-		buf.put(m02);
-		buf.put(m03);
-		buf.put(m10);
-		buf.put(m11);
-		buf.put(m12);
-		buf.put(m13);
-		buf.put(m20);
-		buf.put(m21);
-		buf.put(m22);
-		buf.put(m23);
-		buf.put(m30);
-		buf.put(m31);
-		buf.put(m32);
-		buf.put(m33);
-		return this;
-	}
-
-	/**
-	 * Store this matrix in a float buffer. The matrix is stored in row
-	 * major (maths) order.
-	 * @param buf The buffer to store this matrix in
-	 */
-	public Matrix storeTranspose(FloatBuffer buf) {
-		buf.put(m00);
-		buf.put(m10);
-		buf.put(m20);
-		buf.put(m30);
-		buf.put(m01);
-		buf.put(m11);
-		buf.put(m21);
-		buf.put(m31);
-		buf.put(m02);
-		buf.put(m12);
-		buf.put(m22);
-		buf.put(m32);
-		buf.put(m03);
-		buf.put(m13);
-		buf.put(m23);
-		buf.put(m33);
-		return this;
-	}
-
-	/**
-	 * Store the rotation portion of this matrix in a float buffer. The matrix is stored in column
-	 * major (openGL) order.
-	 * @param buf The buffer to store this matrix in
-	 */
-	public Matrix store3f(FloatBuffer buf) {
-		buf.put(m00);
-		buf.put(m01);
-		buf.put(m02);
-		buf.put(m10);
-		buf.put(m11);
-		buf.put(m12);
-		buf.put(m20);
-		buf.put(m21);
-		buf.put(m22);
-		return this;
-	}
-
-	/**
-	 * Add two matrices together and place the result in a third matrix.
-	 * @param left The left source matrix
-	 * @param right The right source matrix
-	 * @param dest The destination matrix, or null if a new one is to be created
-	 * @return the destination matrix
-	 */
-	public static Matrix4f add(Matrix4f left, Matrix4f right, Matrix4f dest) {
-		if (dest == null)
-			dest = new Matrix4f();
-
-		dest.m00 = left.m00 + right.m00;
-		dest.m01 = left.m01 + right.m01;
-		dest.m02 = left.m02 + right.m02;
-		dest.m03 = left.m03 + right.m03;
-		dest.m10 = left.m10 + right.m10;
-		dest.m11 = left.m11 + right.m11;
-		dest.m12 = left.m12 + right.m12;
-		dest.m13 = left.m13 + right.m13;
-		dest.m20 = left.m20 + right.m20;
-		dest.m21 = left.m21 + right.m21;
-		dest.m22 = left.m22 + right.m22;
-		dest.m23 = left.m23 + right.m23;
-		dest.m30 = left.m30 + right.m30;
-		dest.m31 = left.m31 + right.m31;
-		dest.m32 = left.m32 + right.m32;
-		dest.m33 = left.m33 + right.m33;
-
-		return dest;
-	}
-
-	/**
-	 * Subtract the right matrix from the left and place the result in a third matrix.
-	 * @param left The left source matrix
-	 * @param right The right source matrix
-	 * @param dest The destination matrix, or null if a new one is to be created
-	 * @return the destination matrix
-	 */
-	public static Matrix4f sub(Matrix4f left, Matrix4f right, Matrix4f dest) {
-		if (dest == null)
-			dest = new Matrix4f();
-
-		dest.m00 = left.m00 - right.m00;
-		dest.m01 = left.m01 - right.m01;
-		dest.m02 = left.m02 - right.m02;
-		dest.m03 = left.m03 - right.m03;
-		dest.m10 = left.m10 - right.m10;
-		dest.m11 = left.m11 - right.m11;
-		dest.m12 = left.m12 - right.m12;
-		dest.m13 = left.m13 - right.m13;
-		dest.m20 = left.m20 - right.m20;
-		dest.m21 = left.m21 - right.m21;
-		dest.m22 = left.m22 - right.m22;
-		dest.m23 = left.m23 - right.m23;
-		dest.m30 = left.m30 - right.m30;
-		dest.m31 = left.m31 - right.m31;
-		dest.m32 = left.m32 - right.m32;
-		dest.m33 = left.m33 - right.m33;
-
-		return dest;
-	}
-
-	/**
-	 * Multiply the right matrix by the left and place the result in a third matrix.
-	 * @param left The left source matrix
-	 * @param right The right source matrix
-	 * @param dest The destination matrix, or null if a new one is to be created
-	 * @return the destination matrix
-	 */
-	public static Matrix4f mul(Matrix4f left, Matrix4f right, Matrix4f dest) {
-		if (dest == null)
-			dest = new Matrix4f();
-
-		float m00 = left.m00 * right.m00 + left.m10 * right.m01 + left.m20 * right.m02 + left.m30 * right.m03;
-		float m01 = left.m01 * right.m00 + left.m11 * right.m01 + left.m21 * right.m02 + left.m31 * right.m03;
-		float m02 = left.m02 * right.m00 + left.m12 * right.m01 + left.m22 * right.m02 + left.m32 * right.m03;
-		float m03 = left.m03 * right.m00 + left.m13 * right.m01 + left.m23 * right.m02 + left.m33 * right.m03;
-		float m10 = left.m00 * right.m10 + left.m10 * right.m11 + left.m20 * right.m12 + left.m30 * right.m13;
-		float m11 = left.m01 * right.m10 + left.m11 * right.m11 + left.m21 * right.m12 + left.m31 * right.m13;
-		float m12 = left.m02 * right.m10 + left.m12 * right.m11 + left.m22 * right.m12 + left.m32 * right.m13;
-		float m13 = left.m03 * right.m10 + left.m13 * right.m11 + left.m23 * right.m12 + left.m33 * right.m13;
-		float m20 = left.m00 * right.m20 + left.m10 * right.m21 + left.m20 * right.m22 + left.m30 * right.m23;
-		float m21 = left.m01 * right.m20 + left.m11 * right.m21 + left.m21 * right.m22 + left.m31 * right.m23;
-		float m22 = left.m02 * right.m20 + left.m12 * right.m21 + left.m22 * right.m22 + left.m32 * right.m23;
-		float m23 = left.m03 * right.m20 + left.m13 * right.m21 + left.m23 * right.m22 + left.m33 * right.m23;
-		float m30 = left.m00 * right.m30 + left.m10 * right.m31 + left.m20 * right.m32 + left.m30 * right.m33;
-		float m31 = left.m01 * right.m30 + left.m11 * right.m31 + left.m21 * right.m32 + left.m31 * right.m33;
-		float m32 = left.m02 * right.m30 + left.m12 * right.m31 + left.m22 * right.m32 + left.m32 * right.m33;
-		float m33 = left.m03 * right.m30 + left.m13 * right.m31 + left.m23 * right.m32 + left.m33 * right.m33;
-
-		dest.m00 = m00;
-		dest.m01 = m01;
-		dest.m02 = m02;
-		dest.m03 = m03;
-		dest.m10 = m10;
-		dest.m11 = m11;
-		dest.m12 = m12;
-		dest.m13 = m13;
-		dest.m20 = m20;
-		dest.m21 = m21;
-		dest.m22 = m22;
-		dest.m23 = m23;
-		dest.m30 = m30;
-		dest.m31 = m31;
-		dest.m32 = m32;
-		dest.m33 = m33;
-
-		return dest;
-	}
-
-	/**
-	 * Transform a Vector by a matrix and return the result in a destination
-	 * vector.
-	 * @param left The left matrix
-	 * @param right The right vector
-	 * @param dest The destination vector, or null if a new one is to be created
-	 * @return the destination vector
-	 */
-	public static Vector4f transform(Matrix4f left, Vector4f right, Vector4f dest) {
-		if (dest == null)
-			dest = new Vector4f();
-
-		float x = left.m00 * right.x + left.m10 * right.y + left.m20 * right.z + left.m30 * right.w;
-		float y = left.m01 * right.x + left.m11 * right.y + left.m21 * right.z + left.m31 * right.w;
-		float z = left.m02 * right.x + left.m12 * right.y + left.m22 * right.z + left.m32 * right.w;
-		float w = left.m03 * right.x + left.m13 * right.y + left.m23 * right.z + left.m33 * right.w;
-
-		dest.x = x;
-		dest.y = y;
-		dest.z = z;
-		dest.w = w;
-
-		return dest;
-	}
-
-	/**
-	 * Transpose this matrix
-	 * @return this
-	 */
-	public Matrix transpose() {
-		return transpose(this);
-	}
-
-	/**
-	 * Translate this matrix
-	 * @param vec The vector to translate by
-	 * @return this
-	 */
-	public Matrix4f translate(Vector2f vec) {
-		return translate(vec, this);
-	}
-
-	/**
-	 * Translate this matrix
-	 * @param vec The vector to translate by
-	 * @return this
-	 */
-	public Matrix4f translate(Vector3f vec) {
-		return translate(vec, this);
-	}
-
-	/**
-	 * Scales this matrix
-	 * @param vec The vector to scale by
-	 * @return this
-	 */
-	public Matrix4f scale(Vector3f vec) {
-		return scale(vec, this, this);
-	}
-
-	/**
-	 * Scales the source matrix and put the result in the destination matrix
-	 * @param vec The vector to scale by
-	 * @param src The source matrix
-	 * @param dest The destination matrix, or null if a new matrix is to be created
-	 * @return The scaled matrix
-	 */
-	public static Matrix4f scale(Vector3f vec, Matrix4f src, Matrix4f dest) {
-		if (dest == null)
-			dest = new Matrix4f();
-		dest.m00 = src.m00 * vec.x;
-		dest.m01 = src.m01 * vec.x;
-		dest.m02 = src.m02 * vec.x;
-		dest.m03 = src.m03 * vec.x;
-		dest.m10 = src.m10 * vec.y;
-		dest.m11 = src.m11 * vec.y;
-		dest.m12 = src.m12 * vec.y;
-		dest.m13 = src.m13 * vec.y;
-		dest.m20 = src.m20 * vec.z;
-		dest.m21 = src.m21 * vec.z;
-		dest.m22 = src.m22 * vec.z;
-		dest.m23 = src.m23 * vec.z;
-		return dest;
-	}
-
-	/**
-	 * Rotates the matrix around the given axis the specified angle
-	 * @param angle the angle, in radians.
-	 * @param axis The vector representing the rotation axis. Must be normalized.
-	 * @return this
-	 */
-	public Matrix4f rotate(float angle, Vector3f axis) {
-		return rotate(angle, axis, this);
-	}
-
-	/**
-	 * Rotates the matrix around the given axis the specified angle
-	 * @param angle the angle, in radians.
-	 * @param axis The vector representing the rotation axis. Must be normalized.
-	 * @param dest The matrix to put the result, or null if a new matrix is to be created
-	 * @return The rotated matrix
-	 */
-	public Matrix4f rotate(float angle, Vector3f axis, Matrix4f dest) {
-		return rotate(angle, axis, this, dest);
-	}
-
-	/**
-	 * Rotates the source matrix around the given axis the specified angle and
-	 * put the result in the destination matrix.
-	 * @param angle the angle, in radians.
-	 * @param axis The vector representing the rotation axis. Must be normalized.
-	 * @param src The matrix to rotate
-	 * @param dest The matrix to put the result, or null if a new matrix is to be created
-	 * @return The rotated matrix
-	 */
-	public static Matrix4f rotate(float angle, Vector3f axis, Matrix4f src, Matrix4f dest) {
-		if (dest == null)
-			dest = new Matrix4f();
-		float c = (float) Math.cos(angle);
-		float s = (float) Math.sin(angle);
-		float oneminusc = 1.0f - c;
-		float xy = axis.x*axis.y;
-		float yz = axis.y*axis.z;
-		float xz = axis.x*axis.z;
-		float xs = axis.x*s;
-		float ys = axis.y*s;
-		float zs = axis.z*s;
-
-		float f00 = axis.x*axis.x*oneminusc+c;
-		float f01 = xy*oneminusc+zs;
-		float f02 = xz*oneminusc-ys;
-		// n[3] not used
-		float f10 = xy*oneminusc-zs;
-		float f11 = axis.y*axis.y*oneminusc+c;
-		float f12 = yz*oneminusc+xs;
-		// n[7] not used
-		float f20 = xz*oneminusc+ys;
-		float f21 = yz*oneminusc-xs;
-		float f22 = axis.z*axis.z*oneminusc+c;
-
-		float t00 = src.m00 * f00 + src.m10 * f01 + src.m20 * f02;
-		float t01 = src.m01 * f00 + src.m11 * f01 + src.m21 * f02;
-		float t02 = src.m02 * f00 + src.m12 * f01 + src.m22 * f02;
-		float t03 = src.m03 * f00 + src.m13 * f01 + src.m23 * f02;
-		float t10 = src.m00 * f10 + src.m10 * f11 + src.m20 * f12;
-		float t11 = src.m01 * f10 + src.m11 * f11 + src.m21 * f12;
-		float t12 = src.m02 * f10 + src.m12 * f11 + src.m22 * f12;
-		float t13 = src.m03 * f10 + src.m13 * f11 + src.m23 * f12;
-		dest.m20 = src.m00 * f20 + src.m10 * f21 + src.m20 * f22;
-		dest.m21 = src.m01 * f20 + src.m11 * f21 + src.m21 * f22;
-		dest.m22 = src.m02 * f20 + src.m12 * f21 + src.m22 * f22;
-		dest.m23 = src.m03 * f20 + src.m13 * f21 + src.m23 * f22;
-		dest.m00 = t00;
-		dest.m01 = t01;
-		dest.m02 = t02;
-		dest.m03 = t03;
-		dest.m10 = t10;
-		dest.m11 = t11;
-		dest.m12 = t12;
-		dest.m13 = t13;
-		return dest;
-	}
-
-	/**
-	 * Translate this matrix and stash the result in another matrix
-	 * @param vec The vector to translate by
-	 * @param dest The destination matrix or null if a new matrix is to be created
-	 * @return the translated matrix
-	 */
-	public Matrix4f translate(Vector3f vec, Matrix4f dest) {
-		return translate(vec, this, dest);
-	}
-
-	/**
-	 * Translate the source matrix and stash the result in the destination matrix
-	 * @param vec The vector to translate by
-	 * @param src The source matrix
-	 * @param dest The destination matrix or null if a new matrix is to be created
-	 * @return The translated matrix
-	 */
-	public static Matrix4f translate(Vector3f vec, Matrix4f src, Matrix4f dest) {
-		if (dest == null)
-			dest = new Matrix4f();
-
-		dest.m30 += src.m00 * vec.x + src.m10 * vec.y + src.m20 * vec.z;
-		dest.m31 += src.m01 * vec.x + src.m11 * vec.y + src.m21 * vec.z;
-		dest.m32 += src.m02 * vec.x + src.m12 * vec.y + src.m22 * vec.z;
-		dest.m33 += src.m03 * vec.x + src.m13 * vec.y + src.m23 * vec.z;
-
-		return dest;
-	}
-
-	/**
-	 * Translate this matrix and stash the result in another matrix
-	 * @param vec The vector to translate by
-	 * @param dest The destination matrix or null if a new matrix is to be created
-	 * @return the translated matrix
-	 */
-	public Matrix4f translate(Vector2f vec, Matrix4f dest) {
-		return translate(vec, this, dest);
-	}
-
-	/**
-	 * Translate the source matrix and stash the result in the destination matrix
-	 * @param vec The vector to translate by
-	 * @param src The source matrix
-	 * @param dest The destination matrix or null if a new matrix is to be created
-	 * @return The translated matrix
-	 */
-	public static Matrix4f translate(Vector2f vec, Matrix4f src, Matrix4f dest) {
-		if (dest == null)
-			dest = new Matrix4f();
-
-		dest.m30 += src.m00 * vec.x + src.m10 * vec.y;
-		dest.m31 += src.m01 * vec.x + src.m11 * vec.y;
-		dest.m32 += src.m02 * vec.x + src.m12 * vec.y;
-		dest.m33 += src.m03 * vec.x + src.m13 * vec.y;
-
-		return dest;
-	}
-
-	/**
-	 * Transpose this matrix and place the result in another matrix
-	 * @param dest The destination matrix or null if a new matrix is to be created
-	 * @return the transposed matrix
-	 */
-	public Matrix4f transpose(Matrix4f dest) {
-		return transpose(this, dest);
-	}
-
-	/**
-	 * Transpose the source matrix and place the result in the destination matrix
-	 * @param src The source matrix
-	 * @param dest The destination matrix or null if a new matrix is to be created
-	 * @return the transposed matrix
-	 */
-	public static Matrix4f transpose(Matrix4f src, Matrix4f dest) {
-		if (dest == null)
-		   dest = new Matrix4f();
-		float m00 = src.m00;
-		float m01 = src.m10;
-		float m02 = src.m20;
-		float m03 = src.m30;
-		float m10 = src.m01;
-		float m11 = src.m11;
-		float m12 = src.m21;
-		float m13 = src.m31;
-		float m20 = src.m02;
-		float m21 = src.m12;
-		float m22 = src.m22;
-		float m23 = src.m32;
-		float m30 = src.m03;
-		float m31 = src.m13;
-		float m32 = src.m23;
-		float m33 = src.m33;
-
-		dest.m00 = m00;
-		dest.m01 = m01;
-		dest.m02 = m02;
-		dest.m03 = m03;
-		dest.m10 = m10;
-		dest.m11 = m11;
-		dest.m12 = m12;
-		dest.m13 = m13;
-		dest.m20 = m20;
-		dest.m21 = m21;
-		dest.m22 = m22;
-		dest.m23 = m23;
-		dest.m30 = m30;
-		dest.m31 = m31;
-		dest.m32 = m32;
-		dest.m33 = m33;
-
-		return dest;
-	}
-
-	/**
-	 * @return the determinant of the matrix
-	 */
-	public float determinant() {
-		float f =
-			m00
-				* ((m11 * m22 * m33 + m12 * m23 * m31 + m13 * m21 * m32)
-					- m13 * m22 * m31
-					- m11 * m23 * m32
-					- m12 * m21 * m33);
-		f -= m01
-			* ((m10 * m22 * m33 + m12 * m23 * m30 + m13 * m20 * m32)
-				- m13 * m22 * m30
-				- m10 * m23 * m32
-				- m12 * m20 * m33);
-		f += m02
-			* ((m10 * m21 * m33 + m11 * m23 * m30 + m13 * m20 * m31)
-				- m13 * m21 * m30
-				- m10 * m23 * m31
-				- m11 * m20 * m33);
-		f -= m03
-			* ((m10 * m21 * m32 + m11 * m22 * m30 + m12 * m20 * m31)
-				- m12 * m21 * m30
-				- m10 * m22 * m31
-				- m11 * m20 * m32);
-		return f;
-	}
-
-	/**
-	 * Calculate the determinant of a 3x3 matrix
-	 * @return result
-	 */
-
-	private static float determinant3x3(float t00, float t01, float t02,
-				     float t10, float t11, float t12,
-				     float t20, float t21, float t22)
-	{
-		return   t00 * (t11 * t22 - t12 * t21)
-		       + t01 * (t12 * t20 - t10 * t22)
-		       + t02 * (t10 * t21 - t11 * t20);
-	}
-
-	/**
-	 * Invert this matrix
-	 * @return this if successful, null otherwise
-	 */
-	public Matrix invert() {
-		return invert(this, this);
-	}
-
-	/**
-	 * Invert the source matrix and put the result in the destination
-	 * @param src The source matrix
-	 * @param dest The destination matrix, or null if a new matrix is to be created
-	 * @return The inverted matrix if successful, null otherwise
-	 */
-	public static Matrix4f invert(Matrix4f src, Matrix4f dest) {
-		float determinant = src.determinant();
-
-		if (determinant != 0) {
-			/*
-			 * m00 m01 m02 m03
-			 * m10 m11 m12 m13
-			 * m20 m21 m22 m23
-			 * m30 m31 m32 m33
-			 */
-			if (dest == null)
-				dest = new Matrix4f();
-			float determinant_inv = 1f/determinant;
-
-			// first row
-			float t00 =  determinant3x3(src.m11, src.m12, src.m13, src.m21, src.m22, src.m23, src.m31, src.m32, src.m33);
-			float t01 = -determinant3x3(src.m10, src.m12, src.m13, src.m20, src.m22, src.m23, src.m30, src.m32, src.m33);
-			float t02 =  determinant3x3(src.m10, src.m11, src.m13, src.m20, src.m21, src.m23, src.m30, src.m31, src.m33);
-			float t03 = -determinant3x3(src.m10, src.m11, src.m12, src.m20, src.m21, src.m22, src.m30, src.m31, src.m32);
-			// second row
-			float t10 = -determinant3x3(src.m01, src.m02, src.m03, src.m21, src.m22, src.m23, src.m31, src.m32, src.m33);
-			float t11 =  determinant3x3(src.m00, src.m02, src.m03, src.m20, src.m22, src.m23, src.m30, src.m32, src.m33);
-			float t12 = -determinant3x3(src.m00, src.m01, src.m03, src.m20, src.m21, src.m23, src.m30, src.m31, src.m33);
-			float t13 =  determinant3x3(src.m00, src.m01, src.m02, src.m20, src.m21, src.m22, src.m30, src.m31, src.m32);
-			// third row
-			float t20 =  determinant3x3(src.m01, src.m02, src.m03, src.m11, src.m12, src.m13, src.m31, src.m32, src.m33);
-			float t21 = -determinant3x3(src.m00, src.m02, src.m03, src.m10, src.m12, src.m13, src.m30, src.m32, src.m33);
-			float t22 =  determinant3x3(src.m00, src.m01, src.m03, src.m10, src.m11, src.m13, src.m30, src.m31, src.m33);
-			float t23 = -determinant3x3(src.m00, src.m01, src.m02, src.m10, src.m11, src.m12, src.m30, src.m31, src.m32);
-			// fourth row
-			float t30 = -determinant3x3(src.m01, src.m02, src.m03, src.m11, src.m12, src.m13, src.m21, src.m22, src.m23);
-			float t31 =  determinant3x3(src.m00, src.m02, src.m03, src.m10, src.m12, src.m13, src.m20, src.m22, src.m23);
-			float t32 = -determinant3x3(src.m00, src.m01, src.m03, src.m10, src.m11, src.m13, src.m20, src.m21, src.m23);
-			float t33 =  determinant3x3(src.m00, src.m01, src.m02, src.m10, src.m11, src.m12, src.m20, src.m21, src.m22);
-
-			// transpose and divide by the determinant
-			dest.m00 = t00*determinant_inv;
-			dest.m11 = t11*determinant_inv;
-			dest.m22 = t22*determinant_inv;
-			dest.m33 = t33*determinant_inv;
-			dest.m01 = t10*determinant_inv;
-			dest.m10 = t01*determinant_inv;
-			dest.m20 = t02*determinant_inv;
-			dest.m02 = t20*determinant_inv;
-			dest.m12 = t21*determinant_inv;
-			dest.m21 = t12*determinant_inv;
-			dest.m03 = t30*determinant_inv;
-			dest.m30 = t03*determinant_inv;
-			dest.m13 = t31*determinant_inv;
-			dest.m31 = t13*determinant_inv;
-			dest.m32 = t23*determinant_inv;
-			dest.m23 = t32*determinant_inv;
-			return dest;
-		} else
-			return null;
-	}
-
-	/**
-	 * Negate this matrix
-	 * @return this
-	 */
-	public Matrix negate() {
-		return negate(this);
-	}
-
-	/**
-	 * Negate this matrix and place the result in a destination matrix.
-	 * @param dest The destination matrix, or null if a new matrix is to be created
-	 * @return the negated matrix
-	 */
-	public Matrix4f negate(Matrix4f dest) {
-		return negate(this, dest);
-	}
-
-	/**
-	 * Negate this matrix and place the result in a destination matrix.
-	 * @param src The source matrix
-	 * @param dest The destination matrix, or null if a new matrix is to be created
-	 * @return The negated matrix
-	 */
-	public static Matrix4f negate(Matrix4f src, Matrix4f dest) {
-		if (dest == null)
-			dest = new Matrix4f();
-
-		dest.m00 = -src.m00;
-		dest.m01 = -src.m01;
-		dest.m02 = -src.m02;
-		dest.m03 = -src.m03;
-		dest.m10 = -src.m10;
-		dest.m11 = -src.m11;
-		dest.m12 = -src.m12;
-		dest.m13 = -src.m13;
-		dest.m20 = -src.m20;
-		dest.m21 = -src.m21;
-		dest.m22 = -src.m22;
-		dest.m23 = -src.m23;
-		dest.m30 = -src.m30;
-		dest.m31 = -src.m31;
-		dest.m32 = -src.m32;
-		dest.m33 = -src.m33;
-
-		return dest;
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/vector/Quaternion.java b/src/embeddedlibs/org/lwjglx/util/vector/Quaternion.java
deleted file mode 100644
index 94d6408..0000000
--- a/src/embeddedlibs/org/lwjglx/util/vector/Quaternion.java
+++ /dev/null
@@ -1,530 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.vector;
-
-/**
- *
- * Quaternions for LWJGL!
- *
- * @author fbi
- * @version $Revision: 3418 $
- * $Id: Quaternion.java 3418 2010-09-28 21:11:35Z spasi $
- */
-
-import java.nio.FloatBuffer;
-
-public class Quaternion extends Vector implements ReadableVector4f {
-	private static final long serialVersionUID = 1L;
-
-	public float x, y, z, w;
-
-	/**
-	 * C'tor. The quaternion will be initialized to the identity.
-	 */
-	public Quaternion() {
-		super();
-		setIdentity();
-	}
-
-	/**
-	 * C'tor
-	 *
-	 * @param src
-	 */
-	public Quaternion(ReadableVector4f src) {
-		set(src);
-	}
-
-	/**
-	 * C'tor
-	 *
-	 */
-	public Quaternion(float x, float y, float z, float w) {
-		set(x, y, z, w);
-	}
-
-	/*
-	 * (non-Javadoc)
-	 *
-	 * @see org.lwjglx.util.vector.WritableVector2f#set(float, float)
-	 */
-	public void set(float x, float y) {
-		this.x = x;
-		this.y = y;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 *
-	 * @see org.lwjglx.util.vector.WritableVector3f#set(float, float, float)
-	 */
-	public void set(float x, float y, float z) {
-		this.x = x;
-		this.y = y;
-		this.z = z;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 *
-	 * @see org.lwjglx.util.vector.WritableVector4f#set(float, float, float,
-	 *      float)
-	 */
-	public void set(float x, float y, float z, float w) {
-		this.x = x;
-		this.y = y;
-		this.z = z;
-		this.w = w;
-	}
-
-	/**
-	 * Load from another Vector4f
-	 *
-	 * @param src
-	 *            The source vector
-	 * @return this
-	 */
-	public Quaternion set(ReadableVector4f src) {
-		x = src.getX();
-		y = src.getY();
-		z = src.getZ();
-		w = src.getW();
-		return this;
-	}
-
-	/**
-	 * Set this quaternion to the multiplication identity.
-	 * @return this
-	 */
-	public Quaternion setIdentity() {
-		return setIdentity(this);
-	}
-
-	/**
-	 * Set the given quaternion to the multiplication identity.
-	 * @param q The quaternion
-	 * @return q
-	 */
-	public static Quaternion setIdentity(Quaternion q) {
-		q.x = 0;
-		q.y = 0;
-		q.z = 0;
-		q.w = 1;
-		return q;
-	}
-
-	/**
-	 * @return the length squared of the quaternion
-	 */
-	public float lengthSquared() {
-		return x * x + y * y + z * z + w * w;
-	}
-
-	/**
-	 * Normalise the source quaternion and place the result in another quaternion.
-	 *
-	 * @param src
-	 *            The source quaternion
-	 * @param dest
-	 *            The destination quaternion, or null if a new quaternion is to be
-	 *            created
-	 * @return The normalised quaternion
-	 */
-	public static Quaternion normalise(Quaternion src, Quaternion dest) {
-		float inv_l = 1f/src.length();
-
-		if (dest == null)
-			dest = new Quaternion();
-
-		dest.set(src.x * inv_l, src.y * inv_l, src.z * inv_l, src.w * inv_l);
-
-		return dest;
-	}
-
-	/**
-	 * Normalise this quaternion and place the result in another quaternion.
-	 *
-	 * @param dest
-	 *            The destination quaternion, or null if a new quaternion is to be
-	 *            created
-	 * @return the normalised quaternion
-	 */
-	public Quaternion normalise(Quaternion dest) {
-		return normalise(this, dest);
-	}
-
-	/**
-	 * The dot product of two quaternions
-	 *
-	 * @param left
-	 *            The LHS quat
-	 * @param right
-	 *            The RHS quat
-	 * @return left dot right
-	 */
-	public static float dot(Quaternion left, Quaternion right) {
-		return left.x * right.x + left.y * right.y + left.z * right.z + left.w
-				* right.w;
-	}
-
-	/**
-	 * Calculate the conjugate of this quaternion and put it into the given one
-	 *
-	 * @param dest
-	 *            The quaternion which should be set to the conjugate of this
-	 *            quaternion
-	 */
-	public Quaternion negate(Quaternion dest) {
-		return negate(this, dest);
-	}
-
-	/**
-	 * Calculate the conjugate of this quaternion and put it into the given one
-	 *
-	 * @param src
-	 *            The source quaternion
-	 * @param dest
-	 *            The quaternion which should be set to the conjugate of this
-	 *            quaternion
-	 */
-	public static Quaternion negate(Quaternion src, Quaternion dest) {
-		if (dest == null)
-			dest = new Quaternion();
-
-		dest.x = -src.x;
-		dest.y = -src.y;
-		dest.z = -src.z;
-		dest.w = src.w;
-
-		return dest;
-	}
-
-	/**
-	 * Calculate the conjugate of this quaternion
-	 */
-	public Vector negate() {
-		return negate(this, this);
-	}
-
-	/* (non-Javadoc)
-	 * @see org.lwjglx.util.vector.Vector#load(java.nio.FloatBuffer)
-	 */
-	public Vector load(FloatBuffer buf) {
-		x = buf.get();
-		y = buf.get();
-		z = buf.get();
-		w = buf.get();
-		return this;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 *
-	 * @see org.lwjgl.vector.Vector#scale(float)
-	 */
-	public Vector scale(float scale) {
-		return scale(scale, this, this);
-	}
-
-	/**
-	 * Scale the source quaternion by scale and put the result in the destination
-	 * @param scale The amount to scale by
-	 * @param src The source quaternion
-	 * @param dest The destination quaternion, or null if a new quaternion is to be created
-	 * @return The scaled quaternion
-	 */
-	public static Quaternion scale(float scale, Quaternion src, Quaternion dest) {
-		if (dest == null)
-			dest = new Quaternion();
-		dest.x = src.x * scale;
-		dest.y = src.y * scale;
-		dest.z = src.z * scale;
-		dest.w = src.w * scale;
-		return dest;
-	}
-
-	/* (non-Javadoc)
-	 * @see org.lwjglx.util.vector.ReadableVector#store(java.nio.FloatBuffer)
-	 */
-	public Vector store(FloatBuffer buf) {
-		buf.put(x);
-		buf.put(y);
-		buf.put(z);
-		buf.put(w);
-
-		return this;
-	}
-
-	/**
-	 * @return x
-	 */
-	public final float getX() {
-		return x;
-	}
-
-	/**
-	 * @return y
-	 */
-	public final float getY() {
-		return y;
-	}
-
-	/**
-	 * Set X
-	 *
-	 * @param x
-	 */
-	public final void setX(float x) {
-		this.x = x;
-	}
-
-	/**
-	 * Set Y
-	 *
-	 * @param y
-	 */
-	public final void setY(float y) {
-		this.y = y;
-	}
-
-	/**
-	 * Set Z
-	 *
-	 * @param z
-	 */
-	public void setZ(float z) {
-		this.z = z;
-	}
-
-	/*
-	 * (Overrides)
-	 *
-	 * @see org.lwjgl.vector.ReadableVector3f#getZ()
-	 */
-	public float getZ() {
-		return z;
-	}
-
-	/**
-	 * Set W
-	 *
-	 * @param w
-	 */
-	public void setW(float w) {
-		this.w = w;
-	}
-
-	/*
-	 * (Overrides)
-	 *
-	 * @see org.lwjgl.vector.ReadableVector3f#getW()
-	 */
-	public float getW() {
-		return w;
-	}
-
-	public String toString() {
-		return "Quaternion: " + x + " " + y + " " + z + " " + w;
-	}
-
-	/**
-	 * Sets the value of this quaternion to the quaternion product of
-	 * quaternions left and right (this = left * right). Note that this is safe
-	 * for aliasing (e.g. this can be left or right).
-	 *
-	 * @param left
-	 *            the first quaternion
-	 * @param right
-	 *            the second quaternion
-	 */
-	public static Quaternion mul(Quaternion left, Quaternion right,
-			Quaternion dest) {
-		if (dest == null)
-			dest = new Quaternion();
-		dest.set(left.x * right.w + left.w * right.x + left.y * right.z
-				- left.z * right.y, left.y * right.w + left.w * right.y
-				+ left.z * right.x - left.x * right.z, left.z * right.w
-				+ left.w * right.z + left.x * right.y - left.y * right.x,
-				left.w * right.w - left.x * right.x - left.y * right.y
-				- left.z * right.z);
-		return dest;
-	}
-
-	/**
-	 *
-	 * Multiplies quaternion left by the inverse of quaternion right and places
-	 * the value into this quaternion. The value of both argument quaternions is
-	 * preservered (this = left * right^-1).
-	 *
-	 * @param left
-	 *            the left quaternion
-	 * @param right
-	 *            the right quaternion
-	 */
-	public static Quaternion mulInverse(Quaternion left, Quaternion right,
-			Quaternion dest) {
-		float n = right.lengthSquared();
-		// zero-div may occur.
-		n = (n == 0.0 ? n : 1 / n);
-		// store on stack once for aliasing-safty
-		if (dest == null)
-			dest = new Quaternion();
-		dest
-			.set((left.x * right.w - left.w * right.x - left.y
-						* right.z + left.z * right.y)
-					* n, (left.y * right.w - left.w * right.y - left.z
-						* right.x + left.x * right.z)
-					* n, (left.z * right.w - left.w * right.z - left.x
-						* right.y + left.y * right.x)
-					* n, (left.w * right.w + left.x * right.x + left.y
-						* right.y + left.z * right.z)
-					* n);
-
-		return dest;
-	}
-
-	/**
-	 * Sets the value of this quaternion to the equivalent rotation of the
-	 * Axis-Angle argument.
-	 *
-	 * @param a1
-	 *            the axis-angle: (x,y,z) is the axis and w is the angle
-	 */
-	public final void setFromAxisAngle(Vector4f a1) {
-		x = a1.x;
-		y = a1.y;
-		z = a1.z;
-		float n = (float) Math.sqrt(x * x + y * y + z * z);
-		// zero-div may occur.
-		float s = (float) (Math.sin(0.5 * a1.w) / n);
-		x *= s;
-		y *= s;
-		z *= s;
-		w = (float) Math.cos(0.5 * a1.w);
-	}
-
-	/**
-	 * Sets the value of this quaternion using the rotational component of the
-	 * passed matrix.
-	 *
-	 * @param m
-	 *            The matrix
-	 * @return this
-	 */
-	public final Quaternion setFromMatrix(Matrix4f m) {
-		return setFromMatrix(m, this);
-	}
-
-	/**
-	 * Sets the value of the source quaternion using the rotational component of the
-	 * passed matrix.
-	 *
-	 * @param m
-	 *            The source matrix
-	 * @param q
-	 *            The destination quaternion, or null if a new quaternion is to be created
-	 * @return q
-	 */
-	public static Quaternion setFromMatrix(Matrix4f m, Quaternion q) {
-		return q.setFromMat(m.m00, m.m01, m.m02, m.m10, m.m11, m.m12, m.m20,
-				m.m21, m.m22);
-	}
-
-	/**
-	 * Sets the value of this quaternion using the rotational component of the
-	 * passed matrix.
-	 *
-	 * @param m
-	 *            The source matrix
-	 */
-	public final Quaternion setFromMatrix(Matrix3f m) {
-		return setFromMatrix(m, this);
-	}
-
-	/**
-	 * Sets the value of the source quaternion using the rotational component of the
-	 * passed matrix.
-	 *
-	 * @param m
-	 *            The source matrix
-	 * @param q
-	 *            The destination quaternion, or null if a new quaternion is to be created
-	 * @return q
-	 */
-	public static Quaternion setFromMatrix(Matrix3f m, Quaternion q) {
-		return q.setFromMat(m.m00, m.m01, m.m02, m.m10, m.m11, m.m12, m.m20,
-				m.m21, m.m22);
-	}
-
-	/**
-	 * Private method to perform the matrix-to-quaternion conversion
-	 */
-	private Quaternion setFromMat(float m00, float m01, float m02, float m10,
-			float m11, float m12, float m20, float m21, float m22) {
-
-		float s;
-		float tr = m00 + m11 + m22;
-		if (tr >= 0.0) {
-			s = (float) Math.sqrt(tr + 1.0);
-			w = s * 0.5f;
-			s = 0.5f / s;
-			x = (m21 - m12) * s;
-			y = (m02 - m20) * s;
-			z = (m10 - m01) * s;
-		} else {
-			float max = Math.max(Math.max(m00, m11), m22);
-			if (max == m00) {
-				s = (float) Math.sqrt(m00 - (m11 + m22) + 1.0);
-				x = s * 0.5f;
-				s = 0.5f / s;
-				y = (m01 + m10) * s;
-				z = (m20 + m02) * s;
-				w = (m21 - m12) * s;
-			} else if (max == m11) {
-				s = (float) Math.sqrt(m11 - (m22 + m00) + 1.0);
-				y = s * 0.5f;
-				s = 0.5f / s;
-				z = (m12 + m21) * s;
-				x = (m01 + m10) * s;
-				w = (m02 - m20) * s;
-			} else {
-				s = (float) Math.sqrt(m22 - (m00 + m11) + 1.0);
-				z = s * 0.5f;
-				s = 0.5f / s;
-				x = (m20 + m02) * s;
-				y = (m12 + m21) * s;
-				w = (m10 - m01) * s;
-			}
-		}
-		return this;
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/vector/ReadableVector.java b/src/embeddedlibs/org/lwjglx/util/vector/ReadableVector.java
deleted file mode 100644
index c307834..0000000
--- a/src/embeddedlibs/org/lwjglx/util/vector/ReadableVector.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.vector;
-
-import java.nio.FloatBuffer;
-
-/**
- * @author foo
- */
-public interface ReadableVector {
-	/**
-	 * @return the length of the vector
-	 */
-	float length();
-	/**
-	 * @return the length squared of the vector
-	 */
-	float lengthSquared();
-	/**
-	 * Store this vector in a FloatBuffer
-	 * @param buf The buffer to store it in, at the current position
-	 * @return this
-	 */
-	Vector store(FloatBuffer buf);
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/util/vector/ReadableVector2f.java b/src/embeddedlibs/org/lwjglx/util/vector/ReadableVector2f.java
deleted file mode 100644
index d3deccf..0000000
--- a/src/embeddedlibs/org/lwjglx/util/vector/ReadableVector2f.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.vector;
-
-/**
- * @author foo
- */
-public interface ReadableVector2f extends ReadableVector {
-	/**
-	 * @return x
-	 */
-	float getX();
-	/**
-	 * @return y
-	 */
-	float getY();
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/util/vector/ReadableVector3f.java b/src/embeddedlibs/org/lwjglx/util/vector/ReadableVector3f.java
deleted file mode 100644
index 881d316..0000000
--- a/src/embeddedlibs/org/lwjglx/util/vector/ReadableVector3f.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.vector;
-
-/**
- * @author foo
- */
-public interface ReadableVector3f extends ReadableVector2f {
-	/**
-	 * @return z
-	 */
-	float getZ();
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/util/vector/ReadableVector4f.java b/src/embeddedlibs/org/lwjglx/util/vector/ReadableVector4f.java
deleted file mode 100644
index c9579b7..0000000
--- a/src/embeddedlibs/org/lwjglx/util/vector/ReadableVector4f.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.vector;
-
-/**
- * @author foo
- */
-public interface ReadableVector4f extends ReadableVector3f {
-
-	/**
-	 * @return w
-	 */
-	float getW();
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/vector/Vector.java b/src/embeddedlibs/org/lwjglx/util/vector/Vector.java
deleted file mode 100644
index d7bc883..0000000
--- a/src/embeddedlibs/org/lwjglx/util/vector/Vector.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.vector;
-
-import java.io.Serializable;
-import java.nio.FloatBuffer;
-
-/**
- *
- * Base class for vectors.
- *
- * @author cix_foo <cix_foo@users.sourceforge.net>
- * @version $Revision: 3418 $
- * $Id: Vector.java 3418 2010-09-28 21:11:35Z spasi $
- */
-public abstract class Vector implements Serializable, ReadableVector {
-
-	/**
-	 * Constructor for Vector.
-	 */
-	protected Vector() {
-		super();
-	}
-
-	/**
-	 * @return the length of the vector
-	 */
-	public final float length() {
-		return (float) Math.sqrt(lengthSquared());
-	}
-
-
-	/**
-	 * @return the length squared of the vector
-	 */
-	public abstract float lengthSquared();
-
-	/**
-	 * Load this vector from a FloatBuffer
-	 * @param buf The buffer to load it from, at the current position
-	 * @return this
-	 */
-	public abstract Vector load(FloatBuffer buf);
-
-	/**
-	 * Negate a vector
-	 * @return this
-	 */
-	public abstract Vector negate();
-
-
-	/**
-	 * Normalise this vector
-	 * @return this
-	 */
-	public final Vector normalise() {
-		float len = length();
-		if (len != 0.0f) {
-			float l = 1.0f / len;
-			return scale(l);
-		} else
-			throw new IllegalStateException("Zero length vector");
-	}
-
-
-	/**
-	 * Store this vector in a FloatBuffer
-	 * @param buf The buffer to store it in, at the current position
-	 * @return this
-	 */
-	public abstract Vector store(FloatBuffer buf);
-
-
-	/**
-	 * Scale this vector
-	 * @param scale The scale factor
-	 * @return this
-	 */
-	public abstract Vector scale(float scale);
-
-
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/vector/Vector2f.java b/src/embeddedlibs/org/lwjglx/util/vector/Vector2f.java
deleted file mode 100644
index f4b9c7e..0000000
--- a/src/embeddedlibs/org/lwjglx/util/vector/Vector2f.java
+++ /dev/null
@@ -1,290 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.vector;
-
-import java.io.Serializable;
-import java.nio.FloatBuffer;
-
-/**
- *
- * Holds a 2-tuple vector.
- *
- * @author cix_foo <cix_foo@users.sourceforge.net>
- * @version $Revision: 3418 $
- * $Id: Vector2f.java 3418 2010-09-28 21:11:35Z spasi $
- */
-
-public class Vector2f extends Vector implements Serializable, ReadableVector2f, WritableVector2f {
-
-	private static final long serialVersionUID = 1L;
-
-	public float x, y;
-
-	/**
-	 * Constructor for Vector3f.
-	 */
-	public Vector2f() {
-		super();
-	}
-
-	/**
-	 * Constructor
-	 */
-	public Vector2f(ReadableVector2f src) {
-		set(src);
-	}
-
-	/**
-	 * Constructor
-	 */
-	public Vector2f(float x, float y) {
-		set(x, y);
-	}
-
-	/* (non-Javadoc)
-	 * @see org.lwjglx.util.vector.WritableVector2f#set(float, float)
-	 */
-	public void set(float x, float y) {
-		this.x = x;
-		this.y = y;
-	}
-
-	/**
-	 * Load from another Vector2f
-	 * @param src The source vector
-	 * @return this
-	 */
-	public Vector2f set(ReadableVector2f src) {
-		x = src.getX();
-		y = src.getY();
-		return this;
-	}
-
-	/**
-	 * @return the length squared of the vector
-	 */
-	public float lengthSquared() {
-		return x * x + y * y;
-	}
-
-	/**
-	 * Translate a vector
-	 * @param x The translation in x
-	 * @param y the translation in y
-	 * @return this
-	 */
-	public Vector2f translate(float x, float y) {
-		this.x += x;
-		this.y += y;
-		return this;
-	}
-
-	/**
-	 * Negate a vector
-	 * @return this
-	 */
-	public Vector negate() {
-		x = -x;
-		y = -y;
-		return this;
-	}
-
-	/**
-	 * Negate a vector and place the result in a destination vector.
-	 * @param dest The destination vector or null if a new vector is to be created
-	 * @return the negated vector
-	 */
-	public Vector2f negate(Vector2f dest) {
-		if (dest == null)
-			dest = new Vector2f();
-		dest.x = -x;
-		dest.y = -y;
-		return dest;
-	}
-
-
-	/**
-	 * Normalise this vector and place the result in another vector.
-	 * @param dest The destination vector, or null if a new vector is to be created
-	 * @return the normalised vector
-	 */
-	public Vector2f normalise(Vector2f dest) {
-		float l = length();
-
-		if (dest == null)
-			dest = new Vector2f(x / l, y / l);
-		else
-			dest.set(x / l, y / l);
-
-		return dest;
-	}
-
-	/**
-	 * The dot product of two vectors is calculated as
-	 * v1.x * v2.x + v1.y * v2.y + v1.z * v2.z
-	 * @param left The LHS vector
-	 * @param right The RHS vector
-	 * @return left dot right
-	 */
-	public static float dot(Vector2f left, Vector2f right) {
-		return left.x * right.x + left.y * right.y;
-	}
-
-
-
-	/**
-	 * Calculate the angle between two vectors, in radians
-	 * @param a A vector
-	 * @param b The other vector
-	 * @return the angle between the two vectors, in radians
-	 */
-	public static float angle(Vector2f a, Vector2f b) {
-		float dls = dot(a, b) / (a.length() * b.length());
-		if (dls < -1f)
-			dls = -1f;
-		else if (dls > 1.0f)
-			dls = 1.0f;
-		return (float)Math.acos(dls);
-	}
-
-	/**
-	 * Add a vector to another vector and place the result in a destination
-	 * vector.
-	 * @param left The LHS vector
-	 * @param right The RHS vector
-	 * @param dest The destination vector, or null if a new vector is to be created
-	 * @return the sum of left and right in dest
-	 */
-	public static Vector2f add(Vector2f left, Vector2f right, Vector2f dest) {
-		if (dest == null)
-			return new Vector2f(left.x + right.x, left.y + right.y);
-		else {
-			dest.set(left.x + right.x, left.y + right.y);
-			return dest;
-		}
-	}
-
-	/**
-	 * Subtract a vector from another vector and place the result in a destination
-	 * vector.
-	 * @param left The LHS vector
-	 * @param right The RHS vector
-	 * @param dest The destination vector, or null if a new vector is to be created
-	 * @return left minus right in dest
-	 */
-	public static Vector2f sub(Vector2f left, Vector2f right, Vector2f dest) {
-		if (dest == null)
-			return new Vector2f(left.x - right.x, left.y - right.y);
-		else {
-			dest.set(left.x - right.x, left.y - right.y);
-			return dest;
-		}
-	}
-
-	/**
-	 * Store this vector in a FloatBuffer
-	 * @param buf The buffer to store it in, at the current position
-	 * @return this
-	 */
-	public Vector store(FloatBuffer buf) {
-		buf.put(x);
-		buf.put(y);
-		return this;
-	}
-
-	/**
-	 * Load this vector from a FloatBuffer
-	 * @param buf The buffer to load it from, at the current position
-	 * @return this
-	 */
-	public Vector load(FloatBuffer buf) {
-		x = buf.get();
-		y = buf.get();
-		return this;
-	}
-
-	/* (non-Javadoc)
-	 * @see org.lwjgl.vector.Vector#scale(float)
-	 */
-	public Vector scale(float scale) {
-
-		x *= scale;
-		y *= scale;
-
-		return this;
-	}
-
-	/* (non-Javadoc)
-	 * @see java.lang.Object#toString()
-	 */
-	public String toString() {
-		StringBuilder sb = new StringBuilder(64);
-
-		sb.append("Vector2f[");
-		sb.append(x);
-		sb.append(", ");
-		sb.append(y);
-		sb.append(']');
-		return sb.toString();
-	}
-
-	/**
-	 * @return x
-	 */
-	public final float getX() {
-		return x;
-	}
-
-	/**
-	 * @return y
-	 */
-	public final float getY() {
-		return y;
-	}
-
-	/**
-	 * Set X
-	 * @param x
-	 */
-	public final void setX(float x) {
-		this.x = x;
-	}
-
-	/**
-	 * Set Y
-	 * @param y
-	 */
-	public final void setY(float y) {
-		this.y = y;
-	}
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/vector/Vector3f.java b/src/embeddedlibs/org/lwjglx/util/vector/Vector3f.java
deleted file mode 100644
index 9329a84..0000000
--- a/src/embeddedlibs/org/lwjglx/util/vector/Vector3f.java
+++ /dev/null
@@ -1,347 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.vector;
-
-import java.io.Serializable;
-import java.nio.FloatBuffer;
-
-/**
- *
- * Holds a 3-tuple vector.
- *
- * @author cix_foo <cix_foo@users.sourceforge.net>
- * @version $Revision: 3418 $
- * $Id: Vector3f.java 3418 2010-09-28 21:11:35Z spasi $
- */
-
-public class Vector3f extends Vector implements Serializable, ReadableVector3f, WritableVector3f {
-
-	private static final long serialVersionUID = 1L;
-
-	public float x, y, z;
-
-	/**
-	 * Constructor for Vector3f.
-	 */
-	public Vector3f() {
-		super();
-	}
-
-	/**
-	 * Constructor
-	 */
-	public Vector3f(ReadableVector3f src) {
-		set(src);
-	}
-
-	/**
-	 * Constructor
-	 */
-	public Vector3f(float x, float y, float z) {
-		set(x, y, z);
-	}
-
-	/* (non-Javadoc)
-	 * @see org.lwjglx.util.vector.WritableVector2f#set(float, float)
-	 */
-	public void set(float x, float y) {
-		this.x = x;
-		this.y = y;
-	}
-
-	/* (non-Javadoc)
-	 * @see org.lwjglx.util.vector.WritableVector3f#set(float, float, float)
-	 */
-	public void set(float x, float y, float z) {
-		this.x = x;
-		this.y = y;
-		this.z = z;
-	}
-
-	/**
-	 * Load from another Vector3f
-	 * @param src The source vector
-	 * @return this
-	 */
-	public Vector3f set(ReadableVector3f src) {
-		x = src.getX();
-		y = src.getY();
-		z = src.getZ();
-		return this;
-	}
-
-	/**
-	 * @return the length squared of the vector
-	 */
-	public float lengthSquared() {
-		return x * x + y * y + z * z;
-	}
-
-	/**
-	 * Translate a vector
-	 * @param x The translation in x
-	 * @param y the translation in y
-	 * @return this
-	 */
-	public Vector3f translate(float x, float y, float z) {
-		this.x += x;
-		this.y += y;
-		this.z += z;
-		return this;
-	}
-
-	/**
-	 * Add a vector to another vector and place the result in a destination
-	 * vector.
-	 * @param left The LHS vector
-	 * @param right The RHS vector
-	 * @param dest The destination vector, or null if a new vector is to be created
-	 * @return the sum of left and right in dest
-	 */
-	public static Vector3f add(Vector3f left, Vector3f right, Vector3f dest) {
-		if (dest == null)
-			return new Vector3f(left.x + right.x, left.y + right.y, left.z + right.z);
-		else {
-			dest.set(left.x + right.x, left.y + right.y, left.z + right.z);
-			return dest;
-		}
-	}
-
-	/**
-	 * Subtract a vector from another vector and place the result in a destination
-	 * vector.
-	 * @param left The LHS vector
-	 * @param right The RHS vector
-	 * @param dest The destination vector, or null if a new vector is to be created
-	 * @return left minus right in dest
-	 */
-	public static Vector3f sub(Vector3f left, Vector3f right, Vector3f dest) {
-		if (dest == null)
-			return new Vector3f(left.x - right.x, left.y - right.y, left.z - right.z);
-		else {
-			dest.set(left.x - right.x, left.y - right.y, left.z - right.z);
-			return dest;
-		}
-	}
-
-	/**
-	 * The cross product of two vectors.
-	 *
-	 * @param left The LHS vector
-	 * @param right The RHS vector
-	 * @param dest The destination result, or null if a new vector is to be created
-	 * @return left cross right
-	 */
-	public static Vector3f cross(
-			Vector3f left,
-			Vector3f right,
-			Vector3f dest)
-	{
-
-		if (dest == null)
-			dest = new Vector3f();
-
-		dest.set(
-				left.y * right.z - left.z * right.y,
-				right.x * left.z - right.z * left.x,
-				left.x * right.y - left.y * right.x
-				);
-
-		return dest;
-	}
-
-
-
-	/**
-	 * Negate a vector
-	 * @return this
-	 */
-	public Vector negate() {
-		x = -x;
-		y = -y;
-		z = -z;
-		return this;
-	}
-
-	/**
-	 * Negate a vector and place the result in a destination vector.
-	 * @param dest The destination vector or null if a new vector is to be created
-	 * @return the negated vector
-	 */
-	public Vector3f negate(Vector3f dest) {
-		if (dest == null)
-			dest = new Vector3f();
-		dest.x = -x;
-		dest.y = -y;
-		dest.z = -z;
-		return dest;
-	}
-
-
-	/**
-	 * Normalise this vector and place the result in another vector.
-	 * @param dest The destination vector, or null if a new vector is to be created
-	 * @return the normalised vector
-	 */
-	public Vector3f normalise(Vector3f dest) {
-		float l = length();
-
-		if (dest == null)
-			dest = new Vector3f(x / l, y / l, z / l);
-		else
-			dest.set(x / l, y / l, z / l);
-
-		return dest;
-	}
-
-	/**
-	 * The dot product of two vectors is calculated as
-	 * v1.x * v2.x + v1.y * v2.y + v1.z * v2.z
-	 * @param left The LHS vector
-	 * @param right The RHS vector
-	 * @return left dot right
-	 */
-	public static float dot(Vector3f left, Vector3f right) {
-		return left.x * right.x + left.y * right.y + left.z * right.z;
-	}
-
-	/**
-	 * Calculate the angle between two vectors, in radians
-	 * @param a A vector
-	 * @param b The other vector
-	 * @return the angle between the two vectors, in radians
-	 */
-	public static float angle(Vector3f a, Vector3f b) {
-		float dls = dot(a, b) / (a.length() * b.length());
-		if (dls < -1f)
-			dls = -1f;
-		else if (dls > 1.0f)
-			dls = 1.0f;
-		return (float)Math.acos(dls);
-	}
-
-	/* (non-Javadoc)
-	 * @see org.lwjgl.vector.Vector#load(FloatBuffer)
-	 */
-	public Vector load(FloatBuffer buf) {
-		x = buf.get();
-		y = buf.get();
-		z = buf.get();
-		return this;
-	}
-
-	/* (non-Javadoc)
-	 * @see org.lwjgl.vector.Vector#scale(float)
-	 */
-	public Vector scale(float scale) {
-
-		x *= scale;
-		y *= scale;
-		z *= scale;
-
-		return this;
-
-	}
-
-	/* (non-Javadoc)
-	 * @see org.lwjgl.vector.Vector#store(FloatBuffer)
-	 */
-	public Vector store(FloatBuffer buf) {
-
-		buf.put(x);
-		buf.put(y);
-		buf.put(z);
-
-		return this;
-	}
-
-	/* (non-Javadoc)
-	 * @see java.lang.Object#toString()
-	 */
-	public String toString() {
-		StringBuilder sb = new StringBuilder(64);
-
-		sb.append("Vector3f[");
-		sb.append(x);
-		sb.append(", ");
-		sb.append(y);
-		sb.append(", ");
-		sb.append(z);
-		sb.append(']');
-		return sb.toString();
-	}
-
-	/**
-	 * @return x
-	 */
-	public final float getX() {
-		return x;
-	}
-
-	/**
-	 * @return y
-	 */
-	public final float getY() {
-		return y;
-	}
-
-	/**
-	 * Set X
-	 * @param x
-	 */
-	public final void setX(float x) {
-		this.x = x;
-	}
-
-	/**
-	 * Set Y
-	 * @param y
-	 */
-	public final void setY(float y) {
-		this.y = y;
-	}
-
-	/**
-	 * Set Z
-	 * @param z
-	 */
-	public void setZ(float z) {
-		this.z = z;
-	}
-
-	/* (Overrides)
-	 * @see org.lwjgl.vector.ReadableVector3f#getZ()
-	 */
-	public float getZ() {
-		return z;
-	}
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/vector/Vector4f.java b/src/embeddedlibs/org/lwjglx/util/vector/Vector4f.java
deleted file mode 100644
index 8e97ab7..0000000
--- a/src/embeddedlibs/org/lwjglx/util/vector/Vector4f.java
+++ /dev/null
@@ -1,340 +0,0 @@
-/* 
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are 
- * met:
- * 
- * * Redistributions of source code must retain the above copyright 
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of 
- *   its contributors may be used to endorse or promote products derived 
- *   from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.vector;
-
-import java.io.Serializable;
-import java.nio.FloatBuffer;
-
-/**
- *
- * Holds a 4-tuple vector.
- * 
- * @author cix_foo <cix_foo@users.sourceforge.net>
- * @version $Revision: 2983 $
- * $Id: Vector4f.java 2983 2008-04-07 18:36:09Z matzon $
- */
-
-public class Vector4f extends Vector implements Serializable, ReadableVector4f, WritableVector4f {
-
-	private static final long serialVersionUID = 1L;
-
-	public float x, y, z, w;
-
-	/**
-	 * Constructor for Vector4f.
-	 */
-	public Vector4f() {
-		super();
-	}
-
-	/**
-	 * Constructor
-	 */
-	public Vector4f(ReadableVector4f src) {
-		set(src);
-	}
-
-	/**
-	 * Constructor
-	 */
-	public Vector4f(float x, float y, float z, float w) {
-		set(x, y, z, w);
-	}
-
-	/* (non-Javadoc)
-	 * @see org.lwjglx.util.vector.WritableVector2f#set(float, float)
-	 */
-	public void set(float x, float y) {
-		this.x = x;
-		this.y = y;
-	}
-
-	/* (non-Javadoc)
-	 * @see org.lwjglx.util.vector.WritableVector3f#set(float, float, float)
-	 */
-	public void set(float x, float y, float z) {
-		this.x = x;
-		this.y = y;
-		this.z = z;
-	}
-
-	/* (non-Javadoc)
-	 * @see org.lwjglx.util.vector.WritableVector4f#set(float, float, float, float)
-	 */
-	public void set(float x, float y, float z, float w) {
-		this.x = x;
-		this.y = y;
-		this.z = z;
-		this.w = w;
-	}
-
-	/**
-	 * Load from another Vector4f
-	 * @param src The source vector
-	 * @return this
-	 */
-	public Vector4f set(ReadableVector4f src) {
-		x = src.getX();
-		y = src.getY();
-		z = src.getZ();
-		w = src.getW();
-		return this;
-	}
-
-	/**
-	 * @return the length squared of the vector
-	 */
-	public float lengthSquared() {
-		return x * x + y * y + z * z + w * w;
-	}
-
-	/**
-	 * Translate a vector
-	 * @param x The translation in x
-	 * @param y the translation in y
-	 * @return this
-	 */
-	public Vector4f translate(float x, float y, float z, float w) {
-		this.x += x;
-		this.y += y;
-		this.z += z;
-		this.w += w;
-		return this;
-	}
-
-	/**
-	 * Add a vector to another vector and place the result in a destination
-	 * vector.
-	 * @param left The LHS vector
-	 * @param right The RHS vector
-	 * @param dest The destination vector, or null if a new vector is to be created
-	 * @return the sum of left and right in dest
-	 */
-	public static Vector4f add(Vector4f left, Vector4f right, Vector4f dest) {
-		if (dest == null)
-			return new Vector4f(left.x + right.x, left.y + right.y, left.z + right.z, left.w + right.w);
-		else {
-			dest.set(left.x + right.x, left.y + right.y, left.z + right.z, left.w + right.w);
-			return dest;
-		}
-	}
-
-	/**
-	 * Subtract a vector from another vector and place the result in a destination
-	 * vector.
-	 * @param left The LHS vector
-	 * @param right The RHS vector
-	 * @param dest The destination vector, or null if a new vector is to be created
-	 * @return left minus right in dest
-	 */
-	public static Vector4f sub(Vector4f left, Vector4f right, Vector4f dest) {
-		if (dest == null)
-			return new Vector4f(left.x - right.x, left.y - right.y, left.z - right.z, left.w - right.w);
-		else {
-			dest.set(left.x - right.x, left.y - right.y, left.z - right.z, left.w - right.w);
-			return dest;
-		}
-	}
-
-
-	/**
-	 * Negate a vector
-	 * @return this
-	 */
-	public Vector negate() {
-		x = -x;
-		y = -y;
-		z = -z;
-		w = -w;
-		return this;
-	}
-
-	/**
-	 * Negate a vector and place the result in a destination vector.
-	 * @param dest The destination vector or null if a new vector is to be created
-	 * @return the negated vector
-	 */
-	public Vector4f negate(Vector4f dest) {
-		if (dest == null)
-			dest = new Vector4f();
-		dest.x = -x;
-		dest.y = -y;
-		dest.z = -z;
-		dest.w = -w;
-		return dest;
-	}
-
-
-	/**
-	 * Normalise this vector and place the result in another vector.
-	 * @param dest The destination vector, or null if a new vector is to be created
-	 * @return the normalised vector
-	 */
-	public Vector4f normalise(Vector4f dest) {
-		float l = length();
-
-		if (dest == null)
-			dest = new Vector4f(x / l, y / l, z / l, w / l);
-		else
-			dest.set(x / l, y / l, z / l, w / l);
-
-		return dest;
-	}
-
-	/**
-	 * The dot product of two vectors is calculated as
-	 * v1.x * v2.x + v1.y * v2.y + v1.z * v2.z + v1.w * v2.w
-	 * @param left The LHS vector
-	 * @param right The RHS vector
-	 * @return left dot right
-	 */
-	public static float dot(Vector4f left, Vector4f right) {
-		return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
-	}
-
-	/**
-	 * Calculate the angle between two vectors, in radians
-	 * @param a A vector
-	 * @param b The other vector
-	 * @return the angle between the two vectors, in radians
-	 */
-	public static float angle(Vector4f a, Vector4f b) {
-		float dls = dot(a, b) / (a.length() * b.length());
-		if (dls < -1f)
-			dls = -1f;
-		else if (dls > 1.0f)
-			dls = 1.0f;
-		return (float)Math.acos(dls);
-	}
-
-	/* (non-Javadoc)
-	 * @see org.lwjgl.vector.Vector#load(FloatBuffer)
-	 */
-	public Vector load(FloatBuffer buf) {
-		x = buf.get();
-		y = buf.get();
-		z = buf.get();
-		w = buf.get();
-		return this;
-	}
-
-	/* (non-Javadoc)
-	 * @see org.lwjgl.vector.Vector#scale(float)
-	 */
-	public Vector scale(float scale) {
-		x *= scale;
-		y *= scale;
-		z *= scale;
-		w *= scale;
-		return this;
-	}
-
-	/* (non-Javadoc)
-	 * @see org.lwjgl.vector.Vector#store(FloatBuffer)
-	 */
-	public Vector store(FloatBuffer buf) {
-
-		buf.put(x);
-		buf.put(y);
-		buf.put(z);
-		buf.put(w);
-
-		return this;
-	}
-
-	public String toString() {
-		return "Vector4f: " + x + " " + y + " " + z + " " + w;
-	}
-
-	/**
-	 * @return x
-	 */
-	public final float getX() {
-		return x;
-	}
-
-	/**
-	 * @return y
-	 */
-	public final float getY() {
-		return y;
-	}
-
-	/**
-	 * Set X
-	 * @param x
-	 */
-	public final void setX(float x) {
-		this.x = x;
-	}
-
-	/**
-	 * Set Y
-	 * @param y
-	 */
-	public final void setY(float y) {
-		this.y = y;
-	}
-
-	/**
-	 * Set Z
-	 * @param z
-	 */
-	public void setZ(float z) {
-		this.z = z;
-	}
-
-
-	/* (Overrides)
-	 * @see org.lwjgl.vector.ReadableVector3f#getZ()
-	 */
-	public float getZ() {
-		return z;
-	}
-
-	/**
-	 * Set W
-	 * @param w
-	 */
-	public void setW(float w) {
-		this.w = w;
-	}
-
-	/* (Overrides)
-	 * @see org.lwjgl.vector.ReadableVector3f#getZ()
-	 */
-	public float getW() {
-		return w;
-	}
-
-
-}
diff --git a/src/embeddedlibs/org/lwjglx/util/vector/WritableVector2f.java b/src/embeddedlibs/org/lwjglx/util/vector/WritableVector2f.java
deleted file mode 100644
index 681e2f9..0000000
--- a/src/embeddedlibs/org/lwjglx/util/vector/WritableVector2f.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.vector;
-
-/**
- * Writable interface to Vector2fs
- * @author $author$
- * @version $revision$
- * $Id: WritableVector2f.java 3418 2010-09-28 21:11:35Z spasi $
- */
-public interface WritableVector2f {
-
-	/**
-	 * Set the X value
-	 * @param x
-	 */
-	void setX(float x);
-
-	/**
-	 * Set the Y value
-	 * @param y
-	 */
-	void setY(float y);
-
-	/**
-	 * Set the X,Y values
-	 * @param x
-   * @param y
-	 */
-	void set(float x, float y);
-
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/util/vector/WritableVector3f.java b/src/embeddedlibs/org/lwjglx/util/vector/WritableVector3f.java
deleted file mode 100644
index 712e348..0000000
--- a/src/embeddedlibs/org/lwjglx/util/vector/WritableVector3f.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.vector;
-
-/**
- * Writable interface to Vector3fs
- * @author $author$
- * @version $revision$
- * $Id: WritableVector3f.java 3418 2010-09-28 21:11:35Z spasi $
- */
-public interface WritableVector3f extends WritableVector2f {
-
-	/**
-	 * Set the Z value
-	 * @param z
-	 */
-	void setZ(float z);
-
-	/**
-	 * Set the X,Y,Z values
-	 * @param x
-   * @param y
-   * @param z
-	 */
-	void set(float x, float y, float z);
-
-}
\ No newline at end of file
diff --git a/src/embeddedlibs/org/lwjglx/util/vector/WritableVector4f.java b/src/embeddedlibs/org/lwjglx/util/vector/WritableVector4f.java
deleted file mode 100644
index 93783fe..0000000
--- a/src/embeddedlibs/org/lwjglx/util/vector/WritableVector4f.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (c) 2002-2008 LWJGL Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- * * Neither the name of 'LWJGL' nor the names of
- *   its contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.lwjglx.util.vector;
-
-/**
- * Writable interface to Vector4fs
- * @author $author$
- * @version $revision$
- * $Id: WritableVector4f.java 3418 2010-09-28 21:11:35Z spasi $
- */
-public interface WritableVector4f extends WritableVector3f {
-
-	/**
-	 * Set the W value
-	 * @param w
-	 */
-	void setW(float w);
-
-	/**
-	 * Set the X,Y,Z,W values
-	 * @param x
-   * @param y
-   * @param z
-   * @param w
-	 */
-	void set(float x, float y, float z, float w);
-
-}
\ No newline at end of file
diff --git a/src/minecraft/fuck/you/scala/Utils.scala b/src/minecraft/fuck/you/scala/Utils.scala
deleted file mode 100644
index df06158..0000000
--- a/src/minecraft/fuck/you/scala/Utils.scala
+++ /dev/null
@@ -1,7 +0,0 @@
-package fuck.you.scala
-
-object Utils {
-  def removeASingleElementFromList[T](element: T, list: List[T]): List[T] =
-    list diff List(element)
-
-}
diff --git a/src/minecraft/net/minecraft/client/entity/EntityPlayerSP.java b/src/minecraft/net/minecraft/client/entity/EntityPlayerSP.java
index 82a5127..ca18441 100644
--- a/src/minecraft/net/minecraft/client/entity/EntityPlayerSP.java
+++ b/src/minecraft/net/minecraft/client/entity/EntityPlayerSP.java
@@ -51,6 +51,8 @@ import net.minecraft.util.MovementInput;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.world.IInteractionObject;
 import net.minecraft.world.World;
+import net.unnamed.event.EventBus;
+import net.unnamed.event.vanilla.PlayerLivingUpdateBeginEvent;
 import net.unnamed.world.schedule.Scheduler;
 
 public class EntityPlayerSP extends AbstractClientPlayer
@@ -715,6 +717,8 @@ public class EntityPlayerSP extends AbstractClientPlayer
      */
     public void onLivingUpdate()
     {
+        EventBus.fireEventJ(new PlayerLivingUpdateBeginEvent());
+
         if (this.sprintingTicksLeft > 0)
         {
             --this.sprintingTicksLeft;
diff --git a/src/minecraft/net/minecraft/client/multiplayer/PlayerControllerMP.java b/src/minecraft/net/minecraft/client/multiplayer/PlayerControllerMP.java
index 495b306..a0cbe9a 100644
--- a/src/minecraft/net/minecraft/client/multiplayer/PlayerControllerMP.java
+++ b/src/minecraft/net/minecraft/client/multiplayer/PlayerControllerMP.java
@@ -28,6 +28,8 @@ import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.Vec3;
 import net.minecraft.world.World;
 import net.minecraft.world.WorldSettings;
+import net.unnamed.event.EventBus;
+import net.unnamed.event.vanilla.AttackedEvent;
 
 public class PlayerControllerMP
 {
@@ -493,6 +495,8 @@ public class PlayerControllerMP
         this.syncCurrentPlayItem();
         this.netClientHandler.addToSendQueue(new C02PacketUseEntity(targetEntity, C02PacketUseEntity.Action.ATTACK));
 
+        EventBus.fireEventJ(new AttackedEvent(targetEntity));
+
         if (this.currentGameType != WorldSettings.GameType.SPECTATOR)
         {
             playerIn.attackTargetEntityWithCurrentItem(targetEntity);
diff --git a/src/minecraft/net/minecraft/client/renderer/EntityRenderer.java b/src/minecraft/net/minecraft/client/renderer/EntityRenderer.java
index 0d2775b..665e02d 100644
--- a/src/minecraft/net/minecraft/client/renderer/EntityRenderer.java
+++ b/src/minecraft/net/minecraft/client/renderer/EntityRenderer.java
@@ -49,6 +49,8 @@ import net.minecraft.world.WorldProvider;
 import net.minecraft.world.WorldSettings;
 import net.minecraft.world.biome.BiomeGenBase;
 import net.unnamed.Unnamed;
+import net.unnamed.event.EventBus;
+import net.unnamed.event.vanilla.Render3DEvent;
 import net.unnamed.modules.render.AntiBlind;
 import net.unnamed.modules.render.NoHurtVibration;
 import optifine.*;
@@ -1885,6 +1887,9 @@ public class EntityRenderer implements IResourceManagerReloadListener
         this.mc.mcProfiler.endStartSection("hand");
         boolean flag2 = ReflectorForge.renderFirstPersonHand(this.mc.renderGlobal, partialTicks, pass);
 
+
+        EventBus.fireEventJ(new Render3DEvent(partialTicks));
+        // thank you LiquidBounce, I'll make this project AGPL-v3.0
         if (!flag2 && this.renderHand && !Shaders.isShadowPass)
         {
             if (flag)
diff --git a/src/minecraft/net/minecraft/client/renderer/RenderGlobal.java b/src/minecraft/net/minecraft/client/renderer/RenderGlobal.java
index 7e1f355..34e0e31 100644
--- a/src/minecraft/net/minecraft/client/renderer/RenderGlobal.java
+++ b/src/minecraft/net/minecraft/client/renderer/RenderGlobal.java
@@ -91,6 +91,7 @@ import net.minecraft.world.WorldProvider;
 import net.minecraft.world.border.WorldBorder;
 import net.minecraft.world.chunk.Chunk;
 import net.unnamed.Unnamed;
+import net.unnamed.world.ClientSideWorld;
 import net.unnamed.world.inputcontrol.Cameras;
 import optifine.ChunkUtils;
 import optifine.CloudRenderer;
@@ -785,7 +786,7 @@ public class RenderGlobal implements IWorldAccess, IResourceManagerReloadListene
                                 boolean flag6 = this.mc.getRenderViewEntity() instanceof EntityLivingBase ? ((EntityLivingBase)this.mc.getRenderViewEntity()).isPlayerSleeping() : false;
 
                                 if ((entity2 != this.mc.getRenderViewEntity() || this.mc.gameSettings.thirdPersonView != 0 || flag6 || (Unnamed.clientSideWorld().get().cameras().activeCamera().isDefined() && entity == mc.thePlayer))
-                                        && (entity2.posY < 0.0D || entity2.posY >= 256.0D || this.theWorld.isBlockLoaded(new BlockPos(entity2))) && !Unnamed.clientSideWorld().get().isClientSideEntity(entity2))
+                                        && (entity2.posY < 0.0D || entity2.posY >= 256.0D || this.theWorld.isBlockLoaded(new BlockPos(entity2))) && !ClientSideWorld.isClientSideEntity(entity2))
                                 {
 
 
diff --git a/src/minecraft/net/minecraft/client/renderer/entity/Render.java b/src/minecraft/net/minecraft/client/renderer/entity/Render.java
index 58595b2..c7b343e 100644
--- a/src/minecraft/net/minecraft/client/renderer/entity/Render.java
+++ b/src/minecraft/net/minecraft/client/renderer/entity/Render.java
@@ -18,6 +18,8 @@ import net.minecraft.util.BlockPos;
 import net.minecraft.util.MathHelper;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.world.World;
+import net.unnamed.modules.render.Chams;
+import net.unnamed.utils.target.selector.EntitySelector;
 import optifine.Config;
 
 import org.lwjgl.opengl.GL11;
diff --git a/src/minecraft/net/minecraft/client/renderer/entity/RenderEntity.java b/src/minecraft/net/minecraft/client/renderer/entity/RenderEntity.java
index 7f4ea2c..77fe299 100644
--- a/src/minecraft/net/minecraft/client/renderer/entity/RenderEntity.java
+++ b/src/minecraft/net/minecraft/client/renderer/entity/RenderEntity.java
@@ -3,11 +3,12 @@ package net.minecraft.client.renderer.entity;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.entity.Entity;
 import net.minecraft.util.ResourceLocation;
+import net.unnamed.modules.render.Chams;
+import net.unnamed.utils.target.selector.EntitySelector;
+import org.lwjgl.opengl.GL11;
 
-public class RenderEntity extends Render<Entity>
-{
-    public RenderEntity(RenderManager renderManagerIn)
-    {
+public class RenderEntity extends Render<Entity> {
+    public RenderEntity(RenderManager renderManagerIn) {
         super(renderManagerIn);
     }
 
@@ -17,8 +18,9 @@ public class RenderEntity extends Render<Entity>
      * (Render<T extends Entity>) and this method has signature public void doRender(T entity, double d, double d1,
      * double d2, float f, float f1). But JAD is pre 1.5 so doe
      */
-    public void doRender(Entity entity, double x, double y, double z, float entityYaw, float partialTicks)
-    {
+    public void doRender(Entity entity, double x, double y, double z, float entityYaw, float partialTicks) {
+
+
         GlStateManager.pushMatrix();
         renderOffsetAABB(entity.getEntityBoundingBox(), x - entity.lastTickPosX, y - entity.lastTickPosY, z - entity.lastTickPosZ);
         GlStateManager.popMatrix();
@@ -28,8 +30,7 @@ public class RenderEntity extends Render<Entity>
     /**
      * Returns the location of an entity's texture. Doesn't seem to be called unless you call Render.bindEntityTexture.
      */
-    protected ResourceLocation getEntityTexture(Entity entity)
-    {
+    protected ResourceLocation getEntityTexture(Entity entity) {
         return null;
     }
 }
diff --git a/src/minecraft/net/minecraft/client/renderer/entity/RenderManager.java b/src/minecraft/net/minecraft/client/renderer/entity/RenderManager.java
index 442cf8d..fb279d1 100644
--- a/src/minecraft/net/minecraft/client/renderer/entity/RenderManager.java
+++ b/src/minecraft/net/minecraft/client/renderer/entity/RenderManager.java
@@ -101,6 +101,8 @@ import net.minecraft.util.EnumFacing;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.Vec3;
 import net.minecraft.world.World;
+import net.unnamed.event.EventBus;
+import net.unnamed.event.vanilla.RenderEntityEvent;
 import optifine.PlayerItemsLayer;
 import optifine.Reflector;
 
@@ -117,9 +119,9 @@ public class RenderManager
 
     /** Renders fonts */
     private FontRenderer textRenderer;
-    private double renderPosX;
-    private double renderPosY;
-    private double renderPosZ;
+    public double renderPosX;
+    public double renderPosY;
+    public double renderPosZ;
     public TextureManager renderEngine;
 
     /** Reference to the World object. */
@@ -320,6 +322,11 @@ public class RenderManager
 
     public boolean renderEntitySimple(Entity entityIn, float partialTicks)
     {
+        final var event = new RenderEntityEvent(entityIn, partialTicks);
+        EventBus.fireEventJ(event);
+        if (event.isCanceled())
+            return false;
+
         return this.renderEntityStatic(entityIn, partialTicks, false);
     }
 
diff --git a/src/minecraft/net/minecraft/client/renderer/entity/RenderPlayer.java b/src/minecraft/net/minecraft/client/renderer/entity/RenderPlayer.java
index b6d6f9d..633ffc8 100644
--- a/src/minecraft/net/minecraft/client/renderer/entity/RenderPlayer.java
+++ b/src/minecraft/net/minecraft/client/renderer/entity/RenderPlayer.java
@@ -1,5 +1,6 @@
 package net.minecraft.client.renderer.entity;
 
+import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.AbstractClientPlayer;
 import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.model.ModelPlayer;
@@ -10,7 +11,6 @@ import net.minecraft.client.renderer.entity.layers.LayerCape;
 import net.minecraft.client.renderer.entity.layers.LayerCustomHead;
 import net.minecraft.client.renderer.entity.layers.LayerDeadmau5Head;
 import net.minecraft.client.renderer.entity.layers.LayerHeldItem;
-import net.minecraft.entity.EntityLivingBase;
 import net.minecraft.entity.player.EnumPlayerModelParts;
 import net.minecraft.item.EnumAction;
 import net.minecraft.item.ItemStack;
@@ -56,7 +56,8 @@ public class RenderPlayer extends RendererLivingEntity<AbstractClientPlayer>
     public void doRender(AbstractClientPlayer entity, double x, double y, double z, float entityYaw, float partialTicks)
     {
 
-        if (!entity.isUser() || this.renderManager.livingPlayer == entity || (Unnamed.clientSideWorld().get().cameras().activeCamera().isDefined()))
+        if (!entity.isUser() || this.renderManager.livingPlayer == entity ||
+                (Unnamed.clientSideWorld().get().cameras().shouldRenderThePlayer(partialTicks)))
         {
             double d0 = y;
 
diff --git a/src/minecraft/net/minecraft/client/renderer/entity/RendererLivingEntity.java b/src/minecraft/net/minecraft/client/renderer/entity/RendererLivingEntity.java
index 942073d..c4c497e 100644
--- a/src/minecraft/net/minecraft/client/renderer/entity/RendererLivingEntity.java
+++ b/src/minecraft/net/minecraft/client/renderer/entity/RendererLivingEntity.java
@@ -23,6 +23,8 @@ import net.minecraft.scoreboard.ScorePlayerTeam;
 import net.minecraft.scoreboard.Team;
 import net.minecraft.util.EnumChatFormatting;
 import net.minecraft.util.MathHelper;
+import net.unnamed.modules.render.Chams;
+import net.unnamed.utils.target.selector.EntitySelector;
 import optifine.Config;
 import optifine.Reflector;
 
@@ -99,6 +101,14 @@ public abstract class RendererLivingEntity<T extends EntityLivingBase> extends R
      */
     public void doRender(T entity, double x, double y, double z, float entityYaw, float partialTicks)
     {
+        boolean doChams = Chams.isOn() && ((EntitySelector)Chams.entitySelector().getValue()).isTarget(entity);
+
+        if (doChams) {
+            GL11.glEnable(GL11.GL_POLYGON_OFFSET_FILL);
+            GL11.glPolygonOffset(1.0F, -1000000F);
+        }
+
+
         if (!Reflector.RenderLivingEvent_Pre_Constructor.exists() || !Reflector.postForgeBusEvent(Reflector.RenderLivingEvent_Pre_Constructor, new Object[] {entity, this, Double.valueOf(x), Double.valueOf(y), Double.valueOf(z)}))
         {
             GlStateManager.pushMatrix();
@@ -221,6 +231,11 @@ public abstract class RendererLivingEntity<T extends EntityLivingBase> extends R
                 ;
             }
         }
+
+        if (doChams) {
+            GL11.glPolygonOffset(1.0F, 1000000F);
+            GL11.glDisable(GL11.GL_POLYGON_OFFSET_FILL);
+        }
     }
 
     protected boolean setScoreTeamColor(EntityLivingBase entityLivingBaseIn)
diff --git a/src/minecraft/net/minecraft/entity/Entity.java b/src/minecraft/net/minecraft/entity/Entity.java
index 8cf794b..57ef1da 100644
--- a/src/minecraft/net/minecraft/entity/Entity.java
+++ b/src/minecraft/net/minecraft/entity/Entity.java
@@ -51,7 +51,7 @@ import net.unnamed.event.vanilla.MovementCalculatePreEvent;
 
 public abstract class Entity implements ICommandSender
 {
-    private static final AxisAlignedBB ZERO_AABB = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
+    public static final AxisAlignedBB ZERO_AABB = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
     private static int nextEntityID;
     private int entityId;
     public double renderDistanceWeight;
diff --git a/src/minecraft/net/minecraft/network/NetworkManager.java b/src/minecraft/net/minecraft/network/NetworkManager.java
index 9cb4865..ab9daff 100644
--- a/src/minecraft/net/minecraft/network/NetworkManager.java
+++ b/src/minecraft/net/minecraft/network/NetworkManager.java
@@ -3,21 +3,11 @@ package net.minecraft.network;
 import com.google.common.collect.Queues;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import io.netty.bootstrap.Bootstrap;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelException;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelFutureListener;
-import io.netty.channel.ChannelHandler;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.EventLoopGroup;
-import io.netty.channel.SimpleChannelInboundHandler;
+import io.netty.channel.*;
 import io.netty.channel.epoll.Epoll;
 import io.netty.channel.epoll.EpollEventLoopGroup;
 import io.netty.channel.epoll.EpollSocketChannel;
 import io.netty.channel.local.LocalChannel;
-import io.netty.channel.DefaultEventLoop;
 import io.netty.channel.local.LocalServerChannel;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
@@ -27,26 +17,7 @@ import io.netty.handler.timeout.TimeoutException;
 import io.netty.util.AttributeKey;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
-
-import java.net.InetAddress;
-import java.net.SocketAddress;
-import java.util.Queue;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
-import javax.crypto.SecretKey;
-
-import net.minecraft.util.ChatComponentText;
-import net.minecraft.util.ChatComponentTranslation;
-import net.minecraft.util.CryptManager;
-import net.minecraft.util.IChatComponent;
-import net.minecraft.util.ITickable;
-import net.minecraft.util.LazyLoadBase;
-import net.minecraft.util.MessageDeserializer;
-import net.minecraft.util.MessageDeserializer2;
-import net.minecraft.util.MessageSerializer;
-import net.minecraft.util.MessageSerializer2;
-
+import net.minecraft.util.*;
 import net.unnamed.event.EventBus;
 import net.unnamed.event.vanilla.PacketEvent;
 import org.apache.commons.lang3.ArrayUtils;
@@ -56,6 +27,13 @@ import org.apache.logging.log4j.Logger;
 import org.apache.logging.log4j.Marker;
 import org.apache.logging.log4j.MarkerManager;
 
+import javax.crypto.SecretKey;
+import java.net.InetAddress;
+import java.net.SocketAddress;
+import java.util.Queue;
+import java.util.concurrent.Executors;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
 public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     private static final Logger logger = LogManager.getLogger();
     public static final Marker logMarkerNetwork = MarkerManager.getMarker("NETWORK");
@@ -77,7 +55,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
         }
     };
     private final EnumPacketDirection direction;
-    private final Queue<NetworkManager.InboundHandlerTuplePacketListener> outboundPacketsQueue = Queues.<NetworkManager.InboundHandlerTuplePacketListener>newConcurrentLinkedQueue();
+    private final Queue<NetworkManager.InboundHandlerTuplePacketListener> outboundPacketsQueue = Queues.newConcurrentLinkedQueue();
     private final ReentrantReadWriteLock field_181680_j = new ReentrantReadWriteLock();
 
     /**
@@ -145,11 +123,14 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
 
     @Override
     protected void messageReceived(ChannelHandlerContext p_channelRead0_1_, Packet p_channelRead0_2_) throws Exception {
-        PacketEvent event = new PacketEvent(p_channelRead0_2_);
-        EventBus.fireEventJ(event);
+        if (direction == EnumPacketDirection.CLIENTBOUND) {
+
+            PacketEvent event = new PacketEvent(p_channelRead0_2_, true);
+            EventBus.fireEventJ(event);
 
-        if (event.isCanceled())
-            return;
+            if (event.isCanceled())
+                return;
+        }
 
 
         if (this.channel.isOpen()) {
@@ -172,11 +153,13 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     }
 
     public void sendPacket(Packet packetIn) {
-        PacketEvent event = new PacketEvent(packetIn);
-        EventBus.fireEventJ(event);
+        if (direction == EnumPacketDirection.CLIENTBOUND) {
+            PacketEvent event = new PacketEvent(packetIn, false);
+            EventBus.fireEventJ(event);
 
-        if (event.isCanceled())
-            return;
+            if (event.isCanceled())
+                return;
+        }
 
         if (this.isChannelOpen()) {
             this.flushOutboundQueue();
@@ -192,6 +175,21 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
         }
     }
 
+    public void sendPacketNoEvent(Packet packetIn) {
+        if (this.isChannelOpen()) {
+            this.flushOutboundQueue();
+            this.dispatchPacket(packetIn, (GenericFutureListener<? extends Future<? super Void>>[]) null);
+        } else {
+            this.field_181680_j.writeLock().lock();
+
+            try {
+                this.outboundPacketsQueue.add(new NetworkManager.InboundHandlerTuplePacketListener(packetIn, (GenericFutureListener[]) null));
+            } finally {
+                this.field_181680_j.writeLock().unlock();
+            }
+        }
+    }
+
     public void sendPacket(Packet packetIn, GenericFutureListener<? extends Future<? super Void>> listener, GenericFutureListener<? extends Future<? super Void>>... listeners) {
         if (this.isChannelOpen()) {
             this.flushOutboundQueue();
@@ -255,6 +253,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
      * Will iterate through the outboundPacketQueue and dispatch all Packets
      */
     private void flushOutboundQueue() {
+
         if (this.channel != null && this.channel.isOpen()) {
             this.field_181680_j.readLock().lock();
 
diff --git a/src/minecraft/net/unnamed/Unnamed.scala b/src/minecraft/net/unnamed/Unnamed.scala
deleted file mode 100644
index 1d499bc..0000000
--- a/src/minecraft/net/unnamed/Unnamed.scala
+++ /dev/null
@@ -1,34 +0,0 @@
-package net.unnamed
-
-import net.unnamed.event.unnamed.UnnamedEventsGen
-import net.unnamed.event.vanilla.WorldEvent
-import net.unnamed.event.{AlwaysActiveListener, EventBus}
-import net.unnamed.modules.Modules
-import net.unnamed.scripting.Contexts
-import net.unnamed.settings.Settings
-import net.unnamed.world.ClientSideWorld
-
-object Unnamed {
-  val name = "unnamed"
-  val version = "0.0.0"
-
-  val eventBus: EventBus.type = EventBus
-
-  var clientSideWorld: Option[ClientSideWorld] = None
-
-  val launch: Unit = {
-
-    EventBus += new AlwaysActiveListener[WorldEvent]((event: WorldEvent) => {
-        clientSideWorld = Some(new ClientSideWorld(event.worldClient))
-    })
-
-    UnnamedEventsGen
-    Modules
-    Settings
-
-    Contexts
-
-    Settings.loadSettings()
-    Settings.changeActiveLocalSetting()
-  }
-}
diff --git a/src/minecraft/net/unnamed/cheats/packet/modification/Velocity.scala b/src/minecraft/net/unnamed/cheats/packet/modification/Velocity.scala
deleted file mode 100644
index bd77127..0000000
--- a/src/minecraft/net/unnamed/cheats/packet/modification/Velocity.scala
+++ /dev/null
@@ -1,24 +0,0 @@
-package net.unnamed.cheats.packet.modification
-
-import net.unnamed.event.unnamed.PlayerGotKnockedBackEvent
-import net.unnamed.utils.common.ifce.MinecraftInstance
-
-import javax.vecmath.Vector2d
-
-
-object Velocity extends MinecraftInstance {
-
-  def cancelPlayerKnockBackEvent(event: PlayerGotKnockedBackEvent): Unit = {
-    event.cancel()
-  }
-
-  def modifyKnockBackBy(event: PlayerGotKnockedBackEvent)(byVertical: Double)(byHorizontal: Vector2d): Unit = {
-    val packet = event.packet
-
-    packet.motionY = (packet.motionY * byVertical).toInt
-
-    packet.motionX = (packet.motionX * byHorizontal.x).toInt
-    packet.motionZ = (packet.motionZ * byHorizontal.y).toInt
-  }
-
-}
diff --git a/src/minecraft/net/unnamed/event/Event.scala b/src/minecraft/net/unnamed/event/Event.scala
deleted file mode 100644
index 4de1fe6..0000000
--- a/src/minecraft/net/unnamed/event/Event.scala
+++ /dev/null
@@ -1,13 +0,0 @@
-package net.unnamed.event
-
-import net.minecraft.network.Packet
-
-trait Event
-
-abstract class CancelableEvent extends Event {
-  def cancel(): Unit = canceled = true
-
-  def isCanceled: Boolean = canceled
-
-  private var canceled = false
-}
diff --git a/src/minecraft/net/unnamed/event/EventAlias.scala b/src/minecraft/net/unnamed/event/EventAlias.scala
deleted file mode 100644
index 0c0c8a3..0000000
--- a/src/minecraft/net/unnamed/event/EventAlias.scala
+++ /dev/null
@@ -1,7 +0,0 @@
-package net.unnamed.event
-
-import net.unnamed.event.unnamed.PlayerMovementCalculatePreEvent
-
-case object EventAlias {
-  type StrafeEvent = PlayerMovementCalculatePreEvent
-}
diff --git a/src/minecraft/net/unnamed/event/EventBus.scala b/src/minecraft/net/unnamed/event/EventBus.scala
deleted file mode 100644
index 1a5c8d6..0000000
--- a/src/minecraft/net/unnamed/event/EventBus.scala
+++ /dev/null
@@ -1,64 +0,0 @@
-package net.unnamed.event
-
-import fuck.you.scala.Utils.removeASingleElementFromList
-
-import scala.collection.mutable
-import scala.reflect.ClassTag
-
-
-case object EventBus {
-
-  private val registry = new mutable.LinkedHashMap[ClassTag[Event], List[Listener[Event]]]
-    .withDefaultValue(Nil)
-
-  private val oneShot = new mutable.LinkedHashMap[ClassTag[Event], List[OneShotListener[Event]]]
-    .withDefaultValue(Nil)
-
-
-  def registerListener[SubEvent <: Event](listener: Listener[SubEvent]): EventBus.type = {
-    registry(listener.tag.asInstanceOf[ClassTag[Event]]) ::= listener.asInstanceOf[Listener[Event]]
-    this
-  }
-
-  def unRegisterListener[SubEvent <: Event](listener: Listener[SubEvent]): EventBus.type = {
-    val clazz = listener.tag.asInstanceOf[ClassTag[Event]]
-    registry(clazz) = removeASingleElementFromList(listener.asInstanceOf[Listener[Event]], registry(clazz))
-    this
-  }
-
-  def next[SubEvent <: Event](timesToCall: Int = 1)(callback: SubEvent => Unit)(implicit tag: ClassTag[SubEvent]): EventBus.type = {
-    next(OneShotListener(timesToCall)(callback)(tag))
-    this
-  }
-
-  def next[SubEvent <: Event](oneShotListener: OneShotListener[SubEvent]): EventBus.type = {
-    oneShot(oneShotListener.tag.asInstanceOf[ClassTag[Event]]) ::= oneShotListener.asInstanceOf[OneShotListener[Event]]
-    this
-  }
-
-  def fireEventJ[SubEvent <: Event](event: SubEvent): Unit = {
-    fireEvent(event)(ClassTag(event.getClass))
-  }
-
-  def fireEvent[SubEvent <: Event](event: SubEvent)(implicit tag: ClassTag[SubEvent]): Unit = {
-    registry(tag.asInstanceOf[ClassTag[Event]]).foreach((listener: Listener[Event]) => listener.callback(event))
-
-    oneShot(tag.asInstanceOf[ClassTag[Event]]) = oneShot(tag.asInstanceOf[ClassTag[Event]]).filter((listener: OneShotListener[Event]) => {
-      listener.timesToCall -= 1
-      if (listener.timesToCall == 0) {
-        listener.callback(event)
-        false
-      } else {
-        if (listener.callEveryTime)
-          listener.callback(event)
-        true
-      }
-    })
-  }
-
-  def +=[SubEvent <: Event](listener: Listener[SubEvent]): EventBus.type =
-    registerListener(listener)
-
-  def -=[SubEvent <: Event](listener: Listener[SubEvent]): EventBus.type =
-    unRegisterListener(listener)
-}
diff --git a/src/minecraft/net/unnamed/event/Listener.scala b/src/minecraft/net/unnamed/event/Listener.scala
deleted file mode 100644
index 7e273b9..0000000
--- a/src/minecraft/net/unnamed/event/Listener.scala
+++ /dev/null
@@ -1,20 +0,0 @@
-package net.unnamed.event
-
-import scala.reflect.ClassTag
-
-abstract class Listener[SubEvent <: Event](implicit val tag: ClassTag[SubEvent]) {
-  def isActive: Boolean
-
-  def callback(event: SubEvent): Unit
-}
-
-class AlwaysActiveListener[SubEvent <: Event](val callbackFunc: SubEvent => Unit)(implicit override val tag: ClassTag[SubEvent]) extends Listener[SubEvent] {
-  override def isActive = true
-
-  override def callback(event: SubEvent): Unit = callbackFunc(event)
-}
-
-case class OneShotListener[SubEvent <: Event](var timesToCall: Int = 1, callEveryTime:Boolean = false)(val callback: SubEvent => Unit)(implicit val tag: ClassTag[SubEvent]) {
-  def cancel(): Unit =
-    timesToCall = 0
-}
\ No newline at end of file
diff --git a/src/minecraft/net/unnamed/event/unnamed/ModuleToggleEvent.scala b/src/minecraft/net/unnamed/event/unnamed/ModuleToggleEvent.scala
deleted file mode 100644
index d717a98..0000000
--- a/src/minecraft/net/unnamed/event/unnamed/ModuleToggleEvent.scala
+++ /dev/null
@@ -1,6 +0,0 @@
-package net.unnamed.event.unnamed
-
-import net.unnamed.event.Event
-import net.unnamed.modules.Module
-
-case class ModuleToggleEvent(module: Module) extends Event
\ No newline at end of file
diff --git a/src/minecraft/net/unnamed/event/unnamed/PlayerGotKnockedBackEvent.scala b/src/minecraft/net/unnamed/event/unnamed/PlayerGotKnockedBackEvent.scala
deleted file mode 100644
index 867667b..0000000
--- a/src/minecraft/net/unnamed/event/unnamed/PlayerGotKnockedBackEvent.scala
+++ /dev/null
@@ -1,6 +0,0 @@
-package net.unnamed.event.unnamed
-
-import net.minecraft.network.play.server.S12PacketEntityVelocity
-import net.unnamed.event.CancelableEvent
-
-case class PlayerGotKnockedBackEvent(packet: S12PacketEntityVelocity) extends CancelableEvent
diff --git a/src/minecraft/net/unnamed/event/unnamed/PlayerMovementCalculatePreEvent.scala b/src/minecraft/net/unnamed/event/unnamed/PlayerMovementCalculatePreEvent.scala
deleted file mode 100644
index bba1db6..0000000
--- a/src/minecraft/net/unnamed/event/unnamed/PlayerMovementCalculatePreEvent.scala
+++ /dev/null
@@ -1,7 +0,0 @@
-package net.unnamed.event.unnamed
-
-import net.unnamed.event.CancelableEvent
-
-case class PlayerMovementCalculatePreEvent(var forward: java.lang.Float,
-                                           var strafe: java.lang.Float,
-                                           var friction: java.lang.Float) extends CancelableEvent
diff --git a/src/minecraft/net/unnamed/event/unnamed/ProbFromServerEvent.scala b/src/minecraft/net/unnamed/event/unnamed/ProbFromServerEvent.scala
deleted file mode 100644
index 85874df..0000000
--- a/src/minecraft/net/unnamed/event/unnamed/ProbFromServerEvent.scala
+++ /dev/null
@@ -1,12 +0,0 @@
-package net.unnamed.event.unnamed
-
-import net.unnamed.event.CancelableEvent
-import net.unnamed.event.unnamed.ServerProbes.Probe
-
-object ServerProbes extends Enumeration {
-  type Probe = Value
-
-  val TRANSACTION_PING, FILE_PROB_OUT_OF_RCPACK_FOLDER = Value
-}
-
-case class ProbeFromServerEvent(probeType: Probe, message: String = "") extends CancelableEvent
diff --git a/src/minecraft/net/unnamed/event/unnamed/UnnamedEventsGen.scala b/src/minecraft/net/unnamed/event/unnamed/UnnamedEventsGen.scala
deleted file mode 100644
index c26f6b1..0000000
--- a/src/minecraft/net/unnamed/event/unnamed/UnnamedEventsGen.scala
+++ /dev/null
@@ -1,46 +0,0 @@
-package net.unnamed.event.unnamed
-
-import net.minecraft.network.play.client.C0FPacketConfirmTransaction
-import net.minecraft.network.play.server.{S12PacketEntityVelocity, S23PacketBlockChange, S32PacketConfirmTransaction}
-import net.unnamed.event.vanilla.{MovementCalculatePreEvent, PacketEvent}
-import net.unnamed.event.{AlwaysActiveListener, Event, EventBus}
-import net.unnamed.utils.common.ifce.MinecraftInstance
-
-object UnnamedEventsGen extends MinecraftInstance {
-  {
-    EventBus +=
-      new AlwaysActiveListener[PacketEvent](
-        (event: PacketEvent) => event.packet match {
-
-          case velocityPacket: S12PacketEntityVelocity =>
-            if (velocityPacket.getEntityID == mc.thePlayer.getEntityId) {
-              val kbEvent = PlayerGotKnockedBackEvent(velocityPacket)
-              EventBus.fireEvent(kbEvent)
-              if (kbEvent.isCanceled)
-                event.cancel()
-            }
-
-          case transactionPacket: S32PacketConfirmTransaction =>
-            EventBus.fireEvent(ProbeFromServerEvent(ServerProbes.TRANSACTION_PING,
-              s"Window id: ${transactionPacket.getWindowId}" +
-                s"Action Number: ${transactionPacket.getActionNumber}" +
-                s"Should Send C0FPacketConfirmTransaction: ${!transactionPacket.func_148888_e()}"))
-
-          case _ =>
-        }) +=
-      new AlwaysActiveListener[MovementCalculatePreEvent]((event: MovementCalculatePreEvent) =>
-        if (event.entity == mc.thePlayer) {
-          val strafeEvent = PlayerMovementCalculatePreEvent(event.forward, event.strafe, event.friction)
-          EventBus.fireEvent(strafeEvent)
-
-          if (strafeEvent.isCanceled)
-            event.cancel()
-          else {
-            event.forward = strafeEvent.forward
-            event.strafe = strafeEvent.strafe
-            event.friction = strafeEvent.friction
-          }
-        }
-      )
-  }
-}
diff --git a/src/minecraft/net/unnamed/event/vanilla/ClientShutDownEvent.scala b/src/minecraft/net/unnamed/event/vanilla/ClientShutDownEvent.scala
deleted file mode 100644
index 66d3169..0000000
--- a/src/minecraft/net/unnamed/event/vanilla/ClientShutDownEvent.scala
+++ /dev/null
@@ -1,5 +0,0 @@
-package net.unnamed.event.vanilla
-
-import net.unnamed.event.CancelableEvent
-
-case class ClientShutDownEvent() extends CancelableEvent
diff --git a/src/minecraft/net/unnamed/event/vanilla/CurrentGUIScreenUpdateEvent.scala b/src/minecraft/net/unnamed/event/vanilla/CurrentGUIScreenUpdateEvent.scala
deleted file mode 100644
index e75382d..0000000
--- a/src/minecraft/net/unnamed/event/vanilla/CurrentGUIScreenUpdateEvent.scala
+++ /dev/null
@@ -1,6 +0,0 @@
-package net.unnamed.event.vanilla
-
-import net.minecraft.client.gui.GuiScreen
-import net.unnamed.event.CancelableEvent
-
-case class CurrentGUIScreenUpdateEvent(newScreen: GuiScreen) extends CancelableEvent
diff --git a/src/minecraft/net/unnamed/event/vanilla/MovementCalculatePreEvent.scala b/src/minecraft/net/unnamed/event/vanilla/MovementCalculatePreEvent.scala
deleted file mode 100644
index 3973c83..0000000
--- a/src/minecraft/net/unnamed/event/vanilla/MovementCalculatePreEvent.scala
+++ /dev/null
@@ -1,10 +0,0 @@
-package net.unnamed.event.vanilla
-
-import net.minecraft.entity.Entity
-import net.unnamed.event.CancelableEvent
-
-case class MovementCalculatePreEvent(entity: Entity,
-                                     var forward: java.lang.Float,
-                                     var strafe: java.lang.Float,
-                                     var friction: java.lang.Float) extends CancelableEvent
-
diff --git a/src/minecraft/net/unnamed/event/vanilla/PacketEvent.scala b/src/minecraft/net/unnamed/event/vanilla/PacketEvent.scala
deleted file mode 100644
index 62d7d9c..0000000
--- a/src/minecraft/net/unnamed/event/vanilla/PacketEvent.scala
+++ /dev/null
@@ -1,6 +0,0 @@
-package net.unnamed.event.vanilla
-
-import net.minecraft.network.Packet
-import net.unnamed.event.CancelableEvent
-
-case class PacketEvent(packet: Packet[_]) extends CancelableEvent
\ No newline at end of file
diff --git a/src/minecraft/net/unnamed/event/vanilla/RenderEvent.scala b/src/minecraft/net/unnamed/event/vanilla/RenderEvent.scala
deleted file mode 100644
index e928868..0000000
--- a/src/minecraft/net/unnamed/event/vanilla/RenderEvent.scala
+++ /dev/null
@@ -1,6 +0,0 @@
-package net.unnamed.event.vanilla
-
-import net.unnamed.event.Event
-
-case class Render3DEvent(partialTicks: Float) extends Event
-case class Render2DEvent(partialTicks: Float) extends Event
diff --git a/src/minecraft/net/unnamed/event/vanilla/WorldEvent.scala b/src/minecraft/net/unnamed/event/vanilla/WorldEvent.scala
deleted file mode 100644
index d2496f1..0000000
--- a/src/minecraft/net/unnamed/event/vanilla/WorldEvent.scala
+++ /dev/null
@@ -1,6 +0,0 @@
-package net.unnamed.event.vanilla
-
-import net.minecraft.client.multiplayer.WorldClient
-import net.unnamed.event.Event
-
-case class WorldEvent(worldClient: WorldClient) extends Event
\ No newline at end of file
diff --git a/src/minecraft/net/unnamed/modules/Module.scala b/src/minecraft/net/unnamed/modules/Module.scala
deleted file mode 100644
index 1881b6f..0000000
--- a/src/minecraft/net/unnamed/modules/Module.scala
+++ /dev/null
@@ -1,73 +0,0 @@
-package net.unnamed.modules
-
-import net.unnamed.event.unnamed.ModuleToggleEvent
-import net.unnamed.event.{Event, EventBus, Listener}
-import net.unnamed.settings.Settings.ISaveLocal
-import net.unnamed.settings.setting.SaveThisAlso
-import net.unnamed.utils.common.ifce.{ClientInstance, MinecraftInstance, Toggleable}
-
-import scala.reflect.ClassTag
-
-
-class Module(
-              val description: String = "As the name suggests"
-            ) extends Toggleable with ClientInstance with MinecraftInstance with ISaveLocal {
-
-  {
-  }
-
-  @SaveThisAlso
-  var state: Boolean = false
-
-  override def on(): Unit = {
-    if (!state)
-      toggle()
-  }
-
-  override def off(): Unit = {
-    if (state)
-      toggle()
-  }
-
-  override def toggle(): Unit = {
-    state = !state
-    onToggle()
-  }
-
-  override def isOn: Boolean = state
-
-
-  val moduleName: String = getClass.getSimpleName
-
-  def onEnable(): Unit = {}
-
-  def onDisable(): Unit = {}
-
-
-  val enableOnJoin: Boolean = true
-
-  override def onToggle(): Unit = {
-    if (mc.theWorld == null)
-      return
-
-    if (isOn)
-      onEnable()
-    else
-      onDisable()
-
-    EventBus.fireEvent(ModuleToggleEvent(this))
-  }
-
-  def onEvent[SubEvent <: Event](callbackFunc: SubEvent => Unit)(implicit tag: ClassTag[SubEvent]): Listener[SubEvent] = {
-    val listener = new Listener[SubEvent] {
-      override def isActive: Boolean = isOn && mc.theWorld != null
-
-      override def callback(event: SubEvent): Unit
-      = callbackFunc(event)
-    }
-
-    EventBus += listener
-
-    listener
-  }
-}
\ No newline at end of file
diff --git a/src/minecraft/net/unnamed/modules/Modules.scala b/src/minecraft/net/unnamed/modules/Modules.scala
deleted file mode 100644
index 27a33fc..0000000
--- a/src/minecraft/net/unnamed/modules/Modules.scala
+++ /dev/null
@@ -1,50 +0,0 @@
-package net.unnamed.modules
-
-import net.minecraft.client.gui.GuiIngameMenu
-import net.unnamed.event.vanilla.{CurrentGUIScreenUpdateEvent, WorldEvent}
-import net.unnamed.event.{AlwaysActiveListener, EventBus}
-import net.unnamed.modules.antiexploit.AntiScanFromResourcePackConfirm
-import net.unnamed.modules.render.{AntiBlind, FreeCam, FullBright, NoFOV, NoHurtVibration}
-
-case object Modules {
-  var modules: List[Module] = Nil
-
-
-  {
-    // TODO: can we do that by reflection or do we need to reference explicitly here?
-    modules ::= FullBright
-    modules ::= AntiScanFromResourcePackConfirm
-    modules ::= FreeCam
-    modules ::= NoFOV
-    modules ::= NoHurtVibration
-    modules ::= AntiBlind
-
-
-    EventBus +=
-      new AlwaysActiveListener[WorldEvent]((event: WorldEvent) => {
-        if (event.worldClient != null)
-          for (module <- modules) {
-
-            module.loadSetting()
-
-            if (!module.enableOnJoin)
-              module.off()
-
-            if (module.isOn)
-              module.onEnable()
-          }
-        else
-          for (module <- modules) {
-            if (module.isOn) module.onDisable()
-          }
-      }) +=
-      new AlwaysActiveListener[CurrentGUIScreenUpdateEvent]((event: CurrentGUIScreenUpdateEvent) => {
-        if (event.newScreen.isInstanceOf[GuiIngameMenu]) {
-          for (module <- modules)
-            module.saveSetting()
-        }
-      })
-  }
-
-  // TODO: mutex
-}
diff --git a/src/minecraft/net/unnamed/modules/antiexploit/AntiScanFromResourcePackConfirm.scala b/src/minecraft/net/unnamed/modules/antiexploit/AntiScanFromResourcePackConfirm.scala
deleted file mode 100644
index f444d18..0000000
--- a/src/minecraft/net/unnamed/modules/antiexploit/AntiScanFromResourcePackConfirm.scala
+++ /dev/null
@@ -1,5 +0,0 @@
-package net.unnamed.modules.antiexploit
-
-import net.unnamed.modules.Module
-
-object AntiScanFromResourcePackConfirm extends Module
\ No newline at end of file
diff --git a/src/minecraft/net/unnamed/modules/render/AntiBlind.scala b/src/minecraft/net/unnamed/modules/render/AntiBlind.scala
deleted file mode 100644
index 5d1dc34..0000000
--- a/src/minecraft/net/unnamed/modules/render/AntiBlind.scala
+++ /dev/null
@@ -1,8 +0,0 @@
-package net.unnamed.modules.render
-
-import net.unnamed.modules.Module
-import net.unnamed.settings.setting.FloatSetting
-
-case object AntiBlind extends Module {
-  val alpha = new FloatSetting(.2f)
-}
diff --git a/src/minecraft/net/unnamed/modules/render/FreeCam.scala b/src/minecraft/net/unnamed/modules/render/FreeCam.scala
deleted file mode 100644
index f12a9ea..0000000
--- a/src/minecraft/net/unnamed/modules/render/FreeCam.scala
+++ /dev/null
@@ -1,22 +0,0 @@
-package net.unnamed.modules.render
-
-import net.unnamed.modules.Module
-import net.unnamed.settings.setting.FloatSetting
-import net.unnamed.world.inputcontrol.{Cameras, FreeCamera}
-
-case object FreeCam extends Module {
-
-  val flySpeed = new FloatSetting(.5f)
-
-  override val enableOnJoin: Boolean = false
-
-  override def onEnable(): Unit = {
-    val freeCam = new FreeCamera()
-    freeCam.capabilities.setFlySpeed(flySpeed.getValue)
-    clientSideWorld.cameras.setActiveCamera(Some(freeCam))
-  }
-
-  override def onDisable(): Unit = {
-    clientSideWorld.cameras.activeCamera = None
-  }
-}
\ No newline at end of file
diff --git a/src/minecraft/net/unnamed/modules/render/FullBright.scala b/src/minecraft/net/unnamed/modules/render/FullBright.scala
deleted file mode 100644
index 89978dc..0000000
--- a/src/minecraft/net/unnamed/modules/render/FullBright.scala
+++ /dev/null
@@ -1,17 +0,0 @@
-package net.unnamed.modules.render
-
-import net.unnamed.modules.Module
-
-case object FullBright extends Module {
-
-  var originalGama = 0f
-
-  override def onEnable(): Unit = {
-    originalGama = mc.gameSettings.gammaSetting
-    mc.gameSettings.gammaSetting = 100F
-  }
-
-  override def onDisable(): Unit = {
-    mc.gameSettings.gammaSetting = originalGama
-  }
-}
diff --git a/src/minecraft/net/unnamed/modules/render/NoFOV.scala b/src/minecraft/net/unnamed/modules/render/NoFOV.scala
deleted file mode 100644
index 12f1cc2..0000000
--- a/src/minecraft/net/unnamed/modules/render/NoFOV.scala
+++ /dev/null
@@ -1,8 +0,0 @@
-package net.unnamed.modules.render
-
-import net.unnamed.modules.Module
-import net.unnamed.settings.setting.{FloatSetting, IntegerSetting}
-
-case object NoFOV extends Module {
-  val fov = new FloatSetting(1)
-}
diff --git a/src/minecraft/net/unnamed/modules/render/NoHurtVibration.scala b/src/minecraft/net/unnamed/modules/render/NoHurtVibration.scala
deleted file mode 100644
index d613b14..0000000
--- a/src/minecraft/net/unnamed/modules/render/NoHurtVibration.scala
+++ /dev/null
@@ -1,5 +0,0 @@
-package net.unnamed.modules.render
-
-import net.unnamed.modules.Module
-
-case object NoHurtVibration extends Module
diff --git a/src/minecraft/net/unnamed/scripting/Contexts.scala b/src/minecraft/net/unnamed/scripting/Contexts.scala
deleted file mode 100644
index 1c19030..0000000
--- a/src/minecraft/net/unnamed/scripting/Contexts.scala
+++ /dev/null
@@ -1,10 +0,0 @@
-package net.unnamed.scripting
-
-import net.unnamed.scripting.context.{REPLContext, ModuleEvalREPLContext}
-
-case object Contexts {
-  var contexts: List[REPLContext] =
-    ModuleEvalREPLContext ::
-      Nil
-
-}
diff --git a/src/minecraft/net/unnamed/scripting/context/GraalJSREPLContext.scala b/src/minecraft/net/unnamed/scripting/context/GraalJSREPLContext.scala
deleted file mode 100644
index fe163e3..0000000
--- a/src/minecraft/net/unnamed/scripting/context/GraalJSREPLContext.scala
+++ /dev/null
@@ -1,36 +0,0 @@
-package net.unnamed.scripting.context
-
-import org.graalvm.polyglot.{Context, HostAccess, Source}
-
-class GraalJSREPLContext extends net.unnamed.scripting.context.REPLContext {
-
-  val graalContext: Context = {
-    val context = Context
-      .newBuilder("js")
-      .allowAllAccess(true)
-      .allowExperimentalOptions(true)
-      .allowHostAccess(HostAccess.ALL)
-      .allowHostClassLoading(true)
-      .allowIO(true)
-      .allowCreateThread(true)
-      .option("js.ecmascript-version", "2022")
-      .build()
-
-    context.eval("js", """const Unnamed = Java.type("net.unnamed.Unnamed")""")
-    context.eval("js", """const Minecraft = Java.type("net.minecraft.client.Minecraft")""")
-    context.eval("js", """const mc = Minecraft.getMinecraft()""")
-
-    context
-  }
-
-
-  override def eval(code: String) = {
-    graalContext.eval("js", code).as(classOf[Any])
-  }
-
-  override def dispose(): Unit =
-    graalContext.close()
-
-  override def interpret(code: String): Unit =
-    eval(code)
-}
diff --git a/src/minecraft/net/unnamed/scripting/context/ModuleEvalREPLContext.scala b/src/minecraft/net/unnamed/scripting/context/ModuleEvalREPLContext.scala
deleted file mode 100644
index f52e391..0000000
--- a/src/minecraft/net/unnamed/scripting/context/ModuleEvalREPLContext.scala
+++ /dev/null
@@ -1,4 +0,0 @@
-package net.unnamed.scripting.context
-
-object ModuleEvalREPLContext extends GraalJSREPLContext {
-}
diff --git a/src/minecraft/net/unnamed/scripting/context/REPLContext.scala b/src/minecraft/net/unnamed/scripting/context/REPLContext.scala
deleted file mode 100644
index 2dc0180..0000000
--- a/src/minecraft/net/unnamed/scripting/context/REPLContext.scala
+++ /dev/null
@@ -1,7 +0,0 @@
-package net.unnamed.scripting.context
-
-trait REPLContext {
-  def interpret(code: String): Unit
-  def eval(code: String): Any
-  def dispose(): Unit
-}
diff --git a/src/minecraft/net/unnamed/scripting/context/ScalaREPLContext.scala b/src/minecraft/net/unnamed/scripting/context/ScalaREPLContext.scala
deleted file mode 100644
index 3cf1e64..0000000
--- a/src/minecraft/net/unnamed/scripting/context/ScalaREPLContext.scala
+++ /dev/null
@@ -1,45 +0,0 @@
-package net.unnamed.scripting.context
-
-import scala.tools.nsc.Settings
-import scala.tools.nsc.interpreter.shell.ReplReporterImpl
-import scala.tools.nsc.interpreter.{IMain, ReplReporter, Results}
-
-
-class ScalaREPLContext extends REPLContext {
-
-  val settings: Settings = {
-    val settings = new Settings()
-    settings.usejavacp.value = true
-    settings
-  }
-
-  val interpreter: IMain = {
-    val interpreter = new IMain(settings, new ReplReporterImpl(settings))
-
-    interpreter.interpret(
-      "import net.minecraft.client.Minecraft \n" +
-        "val mc = Minecraft.getMinecraft()"
-      , synthetic = true)
-
-    interpreter
-  }
-
-  override def eval(code: String): Any = {
-    val compiled = interpreter.compile(code, synthetic = true)
-
-    compiled match {
-      case Right(value) =>
-        val result = value.eval
-
-        result match {
-          case Right(retValue) => retValue
-          case Left(retValue) => None
-        }
-      case Left(value) => None
-    }
-  }
-
-  override def dispose(): Unit = interpreter.close()
-
-  override def interpret(code: String): Unit = interpreter.interpret(code, synthetic = true)
-}
diff --git a/src/minecraft/net/unnamed/scripting/scripts/Script.scala b/src/minecraft/net/unnamed/scripting/scripts/Script.scala
deleted file mode 100644
index 6268632..0000000
--- a/src/minecraft/net/unnamed/scripting/scripts/Script.scala
+++ /dev/null
@@ -1,30 +0,0 @@
-package net.unnamed.scripting.scripts
-
-import net.unnamed.scripting.context.{GraalJSREPLContext, REPLContext, ScalaREPLContext}
-import org.apache.commons.io.FilenameUtils
-
-import java.io.{BufferedReader, File}
-import java.nio.file.Files
-
-
-abstract class Script (val file: File) {
-  val scriptText = new String(Files.readAllBytes(file.toPath))
-
-  def load(): Unit = {
-    context().interpret(scriptText)
-  }
-  def context(): REPLContext
-}
-
-object Script {
-  def loadFromFile(file: File): Script = {
-    FilenameUtils.getExtension(file.getName) match {
-      case "js" => new Script(file) {
-        override def context(): REPLContext = new GraalJSREPLContext
-      }
-      case "scala" => new Script(file) {
-        override def context(): REPLContext = new ScalaREPLContext
-      }
-    }
-  }
-}
\ No newline at end of file
diff --git a/src/minecraft/net/unnamed/scripting/scripts/Scripts.scala b/src/minecraft/net/unnamed/scripting/scripts/Scripts.scala
deleted file mode 100644
index b92405b..0000000
--- a/src/minecraft/net/unnamed/scripting/scripts/Scripts.scala
+++ /dev/null
@@ -1,5 +0,0 @@
-package net.unnamed.scripting.scripts
-
-case object Scripts {
-
-}
diff --git a/src/minecraft/net/unnamed/settings/Settings.scala b/src/minecraft/net/unnamed/settings/Settings.scala
deleted file mode 100644
index ed3a416..0000000
--- a/src/minecraft/net/unnamed/settings/Settings.scala
+++ /dev/null
@@ -1,242 +0,0 @@
-package net.unnamed.settings
-
-import com.google.gson._
-import com.google.gson.annotations.Expose
-import net.minecraft.client.gui.GuiIngameMenu
-import net.unnamed.Unnamed
-import net.unnamed.event.vanilla.{ClientShutDownEvent, CurrentGUIScreenUpdateEvent}
-import net.unnamed.event.{AlwaysActiveListener, EventBus}
-import net.unnamed.settings.setting.{SaveThisAlso, Setting, SettingDeserializer, SettingSerializer}
-import net.unnamed.utils.ReflectionUtils
-import net.unnamed.utils.common.ifce.MinecraftInstance
-
-import java.io.{BufferedReader, File, FileReader, FileWriter}
-import java.lang.reflect.Field
-import java.util
-import scala.collection.convert.ImplicitConversions._
-import scala.collection.mutable
-
-object Settings extends MinecraftInstance {
-
-  {
-    EventBus += new AlwaysActiveListener[ClientShutDownEvent]((_: ClientShutDownEvent) => saveSettings())
-    EventBus += new AlwaysActiveListener[CurrentGUIScreenUpdateEvent]((event: CurrentGUIScreenUpdateEvent) =>
-      if (event.newScreen.isInstanceOf[GuiIngameMenu])
-        saveSettings()
-    )
-  }
-
-
-  val settingsDirectory = new File(mc.mcDataDir, Unnamed.name)
-  val globalSettings: mutable.Map[String, List[ISaveGlobal]] = new mutable.HashMap[String, List[ISaveGlobal]]().withDefaultValue(Nil)
-
-  var activeDirectory = new File(settingsDirectory, "default")
-  var activeSettings: mutable.Map[String, List[ISaveLocal]] = new mutable.HashMap[String, List[ISaveLocal]]().withDefaultValue(Nil)
-
-
-  val serializer: Gson = {
-    val builder = new GsonBuilder()
-
-    ReflectionUtils.getAllSubClassInPackage(getClass.getPackage, classOf[Setting[_]]).foreach((value: Class[Setting[_]]) => {
-      builder.registerTypeAdapter(value, SettingSerializer)
-      builder.registerTypeAdapter(value, SettingDeserializer)
-    })
-
-    builder
-      .excludeFieldsWithoutExposeAnnotation()
-      .setPrettyPrinting()
-      .create()
-  }
-
-  val parser = new JsonParser()
-
-  trait ISave {
-    val settingName: String = getClass.getSimpleName
-    val locatedPackage: Package = getClass.getPackage
-
-    var settings = new JsonArray
-
-    def loadSetting(): Unit = {
-      for (jsonElement <- settings) {
-
-        val jsonObject = jsonElement.getAsJsonObject
-        jsonObject.entrySet().foreach((value: util.Map.Entry[String, JsonElement]) => {
-
-          val settingField = ReflectionUtils.getAllField(this)
-            .find((field: Field) => field.getName == value.getKey)
-            .orNull
-
-          if (!settingField.isAccessible)
-            settingField.setAccessible(true)
-
-          val originalSetting = settingField.get(this)
-          val deserializedSetting = serializer.fromJson(value.getValue, originalSetting.getClass)
-
-          if (settingField.isAnnotationPresent(classOf[SaveThisAlso]))
-            settingField.set(this, deserializedSetting)
-          else
-            ReflectionUtils.getAllField(originalSetting).foreach((field: Field) => {
-
-              if (field.isAnnotationPresent(classOf[Expose])) {
-
-                if (!field.isAccessible)
-                  field.setAccessible(true)
-
-                field.set(originalSetting, field.get(deserializedSetting))
-              }
-            })
-        })
-      }
-    }
-
-    def saveSetting(): Unit = {
-      settings = new JsonArray
-      ReflectionUtils.getAllField(this).filter((field: Field) => {
-        if (!field.isAccessible)
-          field.setAccessible(true)
-
-        classOf[Setting[_]].isAssignableFrom(field.getType) ||
-          field.isAnnotationPresent(classOf[SaveThisAlso])
-      }
-      )
-        .foreach((field: Field) => {
-
-          val setting = field.get(this)
-
-          val jsonObject = new JsonObject
-          jsonObject.add(field.getName, serializer.toJsonTree(setting))
-          settings.add(jsonObject)
-        })
-
-    }
-
-    def getConfigFileName: String =
-      locatedPackage.getName + ".json"
-  }
-
-  trait ISaveLocal extends ISave {
-
-    {
-      activeSettings(getConfigFileName) ::= this
-    }
-
-  }
-
-  trait ISaveGlobal extends ISave {
-
-    {
-      globalSettings(getConfigFileName) ::= this
-    }
-
-  }
-
-  def loadSettings(): Unit = {
-    if (!settingsDirectory.exists())
-      settingsDirectory.mkdir()
-
-    for (file <- settingsDirectory.listFiles()) {
-      if (file.isDirectory)
-        return
-
-      val settingFileName = file.getName
-
-      val fileContent = parser.parse(new BufferedReader(new FileReader(file)))
-      for (element <- fileContent.getAsJsonArray) {
-        val jsonObject = element.getAsJsonObject
-
-        val save = globalSettings(settingFileName).find((global: ISaveGlobal) =>
-          global.settingName == jsonObject.get("settingName").getAsString)
-
-        if (save.isDefined)
-          save.get.settings = jsonObject.get("settings").getAsJsonArray
-
-      }
-
-    }
-  }
-
-  def changeActiveLocalSetting(settingName: String = "default"): Unit = {
-    activeDirectory = new File(settingsDirectory, settingName)
-
-
-    if (!activeDirectory.exists())
-      activeDirectory.mkdir()
-
-    for (file <- activeDirectory.listFiles()) {
-      val settingFileName = file.getName
-
-      val fileContent = parser.parse(new BufferedReader(new FileReader(file)))
-      for (element <- fileContent.getAsJsonArray) {
-        val jsonObject = element.getAsJsonObject
-
-        val save = activeSettings(settingFileName).find((global: ISaveLocal) =>
-          global.settingName == jsonObject.get("settingName").getAsString)
-
-        if (save.isDefined)
-          save.get.settings = jsonObject.get("settings").getAsJsonArray
-
-      }
-
-    }
-  }
-
-  def saveSettings(): Unit = {
-
-    globalSettings.foreachEntry((_: String, value: List[ISave]) =>
-      for (save <- value)
-        save.saveSetting())
-
-    activeSettings.foreachEntry((_: String, value: List[ISave]) =>
-      for (save <- value)
-        save.saveSetting())
-
-    if (!settingsDirectory.exists())
-      settingsDirectory.mkdir()
-
-    if (!activeDirectory.exists())
-      activeDirectory.mkdir()
-
-    globalSettings.foreachEntry((fileName: String, saves: List[ISaveGlobal]) => {
-      val file = new File(settingsDirectory, fileName)
-      if (!file.exists())
-        file.createNewFile()
-
-      val jsonArray = new JsonArray
-      for (save <- saves) {
-        val jsonObject = new JsonObject
-
-        jsonObject.addProperty("settingName", save.settingName)
-        jsonObject.add("settings", save.settings)
-
-        jsonArray.add(jsonObject)
-      }
-
-      val writer = new FileWriter(file)
-      writer.write(serializer.toJson(jsonArray))
-      writer.close()
-    })
-
-
-    activeSettings.foreachEntry((fileName: String, saves: List[ISaveLocal]) => {
-      val file = new File(activeDirectory, fileName)
-      if (!file.exists())
-        file.createNewFile()
-
-      val jsonArray = new JsonArray
-      for (save <- saves) {
-        val jsonObject = new JsonObject
-        jsonObject.addProperty("settingName", save.settingName)
-        jsonObject.add("settings", save.settings)
-
-        jsonArray.add(jsonObject)
-      }
-
-
-      val writer = new FileWriter(file)
-      writer.write(serializer.toJson(jsonArray))
-      writer.close()
-    })
-
-  }
-
-}
diff --git a/src/minecraft/net/unnamed/settings/setting/SaveThisAlso.java b/src/minecraft/net/unnamed/settings/setting/SaveThisAlso.java
deleted file mode 100644
index 6126d40..0000000
--- a/src/minecraft/net/unnamed/settings/setting/SaveThisAlso.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package net.unnamed.settings.setting;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-@Target(ElementType.FIELD)
-@Retention(RetentionPolicy.RUNTIME)
-public @interface SaveThisAlso {
-}
diff --git a/src/minecraft/net/unnamed/settings/setting/Setting.scala b/src/minecraft/net/unnamed/settings/setting/Setting.scala
deleted file mode 100644
index 02787fe..0000000
--- a/src/minecraft/net/unnamed/settings/setting/Setting.scala
+++ /dev/null
@@ -1,103 +0,0 @@
-package net.unnamed.settings.setting
-
-import com.google.gson.{Gson, GsonBuilder, JsonDeserializationContext, JsonDeserializer, JsonElement, JsonSerializationContext, JsonSerializer}
-import com.google.gson.annotations.Expose
-import net.unnamed.settings.Settings
-
-import java.lang.reflect.Type
-
-trait Setting[T] {
-  // TODO: integrate with internal REPL (that doesn't exist yet)
-
-  @(Expose @annotation.meta.field)
-  var expr: String = null
-
-  protected def valueFromSetting: T
-
-  def getValue: T = {
-    //    if (expr != null)
-    //      eval(expr)
-    //    else
-    valueFromSetting
-  }
-
-  def set(value: T): Unit
-
-  val suggestedValue: String
-}
-
-object SettingSerializer extends JsonSerializer[Setting[_]] {
-
-  val serializer: Gson =  new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()
-
-  override def serialize(src: Setting[_], `type`: Type, jsonSerializationContext: JsonSerializationContext): JsonElement = {
-    val jsonObject = serializer.toJsonTree(src).getAsJsonObject
-    jsonObject.addProperty("expr", src.expr)
-    jsonObject
-  }
-}
-
-object SettingDeserializer extends JsonDeserializer[Setting[_]] {
-
-  val serializer: Gson =  new Gson()
-
-  override def deserialize(jsonElement: JsonElement, `type`: Type, jsonDeserializationContext: JsonDeserializationContext): Setting[_] = {
-    val setting = serializer.fromJson(jsonElement, `type`).asInstanceOf[Setting[_]]
-    val expr = jsonElement.getAsJsonObject.get("expr")
-    if (expr != null)
-      setting.expr = expr.getAsString
-    setting
-  }
-}
-
-
-class BoolSetting(
-                   @(Expose @annotation.meta.field)
-                   private var on: Boolean,
-                   private val default: Boolean = false) extends Setting[Boolean] {
-  override def set(value: Boolean): Unit =
-    on = value
-
-  override def valueFromSetting: Boolean = on
-
-  override val suggestedValue: String = default.toString
-}
-
-class IntegerSetting(
-                      @(Expose @annotation.meta.field)
-                      private var number: Int,
-                      private val suggestedLower: Int = 0,
-                      private val suggestedHigher: Int = 1) extends Setting[Int] {
-  override def valueFromSetting: Int = number
-
-  override def set(value: Int): Unit =
-    number = value
-
-  override val suggestedValue: String = s"[$suggestedLower, $suggestedHigher]"
-}
-
-
-class FloatSetting(
-                    @(Expose @annotation.meta.field)
-                    private var number: Float,
-                    private val suggestedLower: Float = 0,
-                    private val suggestedHigher: Float = 1) extends Setting[Float] {
-  override def valueFromSetting: Float = number
-
-  override def set(value: Float): Unit =
-    number = value
-
-  override val suggestedValue: String = s"[$suggestedLower, $suggestedHigher]"
-}
-
-class ListSetting(
-                   @(Expose @annotation.meta.field)
-                   private var choice: String,
-                   private val suggestedList: List[String]) extends Setting[String] {
-  override def valueFromSetting: String = choice
-
-  override def set(value: String): Unit =
-    choice = value
-
-  override val suggestedValue: String = suggestedList.toString()
-}
\ No newline at end of file
diff --git a/src/minecraft/net/unnamed/utils/REPLHelper.scala b/src/minecraft/net/unnamed/utils/REPLHelper.scala
deleted file mode 100644
index b27d32b..0000000
--- a/src/minecraft/net/unnamed/utils/REPLHelper.scala
+++ /dev/null
@@ -1,20 +0,0 @@
-package net.unnamed.utils
-
-import net.minecraft.client.main.Main
-
-object REPLHelper {
-  def startMinecraft(args: Array[String] = Array("--username", "UnnamedPlayer")): Unit = {
-
-    new Thread() {
-      override def run(): Unit = {
-        Main.main(Array(
-          "--version", "mcp",
-          "--accessToken", "0",
-          "--assetsDir", "assets",
-          "--assetIndex", "1.8",
-          "--userProperties", "{}",
-        ) ++ args)
-      }
-    }.start()
-  }
-}
diff --git a/src/minecraft/net/unnamed/utils/ReflectionUtils.scala b/src/minecraft/net/unnamed/utils/ReflectionUtils.scala
deleted file mode 100644
index 0ac3c67..0000000
--- a/src/minecraft/net/unnamed/utils/ReflectionUtils.scala
+++ /dev/null
@@ -1,61 +0,0 @@
-package net.unnamed.utils
-
-import java.io.File
-import java.lang.reflect.Field
-
-case object ReflectionUtils {
-  def getAllField(obj: Object): List[Field] = {
-    var fields: List[Field] = Nil
-
-    var clazz: Class[_] = obj.getClass
-
-    while (clazz != classOf[Object]) {
-      fields ++= clazz.getDeclaredFields
-      clazz = clazz.getSuperclass
-    }
-
-    fields
-  }
-
-  def getAllSubClassInPackage[T](pack: Package, clazz: Class[T]): List[Class[T]] = {
-    val clazzs = getClasses(pack.getName)
-    clazzs.filter((value: Class[_]) => clazz.isAssignableFrom(value) && clazz != value).asInstanceOf[List[Class[T]]]
-  }
-
-
-  private def getClasses(packageName: String) = {
-    val classLoader = Thread.currentThread.getContextClassLoader
-    assert(classLoader != null)
-    val path = packageName.replace('.', '/')
-    val resources = classLoader.getResources(path)
-    var dirs: List[File] = Nil
-    while ( {
-      resources.hasMoreElements
-    }) {
-      val resource = resources.nextElement
-      dirs ::= new File(resource.getFile)
-    }
-    var classes: List[Class[_]] = Nil
-    for (directory <- dirs) {
-      classes ++= findClasses(directory, packageName)
-    }
-    classes
-  }
-
-  private def findClasses(directory: File, packageName: String):List[Class[_]] = {
-    var classes: List[Class[_]] = Nil
-    if (directory.exists) {
-
-      val files = directory.listFiles
-      for (file <- files) {
-        if (file.isDirectory) {
-          assert(!file.getName.contains("."))
-          classes ++= findClasses(file, packageName + "." + file.getName)
-        }
-        else if (file.getName.endsWith(".class"))
-          classes ::= (Class.forName(packageName + '.' + file.getName.substring(0, file.getName.length - 6)))
-      }
-    }
-    classes
-  }
-}
diff --git a/src/minecraft/net/unnamed/utils/Rotation.scala b/src/minecraft/net/unnamed/utils/Rotation.scala
deleted file mode 100644
index 5dee056..0000000
--- a/src/minecraft/net/unnamed/utils/Rotation.scala
+++ /dev/null
@@ -1,43 +0,0 @@
-package net.unnamed.utils
-
-import net.minecraft.client.settings.GameSettings
-import net.minecraft.entity.Entity
-import net.unnamed.utils.Rotation.getGCD
-import net.unnamed.utils.common.ifce.MinecraftInstance
-
-case class Rotation(rotationYaw: Float, rotationPitch: Float) {
-
-  def correctByGCD(GCD: Float, input: Float): Float = {
-    val mod = input % GCD
-    input - (if (mod < GCD / 2) mod else mod - GCD)
-  }
-
-  def add(deltaYaw: Float, deltaPitch: Float): Rotation = {
-    val GCD = getGCD
-
-    val correctedDeltaYaw = correctByGCD(GCD, deltaYaw)
-    val correctedDeltaPitch = correctByGCD(GCD, deltaPitch)
-
-    Rotation.apply(rotationYaw + correctedDeltaYaw, rotationPitch + correctedDeltaPitch)
-  }
-
-  def +(deltaYaw: Float, deltaPitch: Float): Rotation = {
-    add(deltaYaw, deltaPitch)
-  }
-
-  def to(entity: Entity): Unit = {
-    entity.rotationYaw = rotationYaw
-    entity.rotationPitch = rotationPitch
-  }
-}
-
-object Rotation extends MinecraftInstance {
-  def getGCD: Float = {
-    val f = mc.gameSettings.mouseSensitivity * 0.6F + 0.2F
-    f * f * f * 8.0F
-  }
-
-  def fromEntity(entity: Entity): Rotation = {
-    Rotation.apply(entity.rotationYaw, entity.rotationPitch)
-  }
-}
\ No newline at end of file
diff --git a/src/minecraft/net/unnamed/utils/common/ifce/ClientInstance.scala b/src/minecraft/net/unnamed/utils/common/ifce/ClientInstance.scala
deleted file mode 100644
index b71f279..0000000
--- a/src/minecraft/net/unnamed/utils/common/ifce/ClientInstance.scala
+++ /dev/null
@@ -1,8 +0,0 @@
-package net.unnamed.utils.common.ifce
-
-import net.unnamed.Unnamed
-import net.unnamed.world.ClientSideWorld
-
-trait ClientInstance {
-  def clientSideWorld: ClientSideWorld = Unnamed.clientSideWorld.get
-}
diff --git a/src/minecraft/net/unnamed/utils/common/ifce/MinecraftInstance.scala b/src/minecraft/net/unnamed/utils/common/ifce/MinecraftInstance.scala
deleted file mode 100644
index 0a8561f..0000000
--- a/src/minecraft/net/unnamed/utils/common/ifce/MinecraftInstance.scala
+++ /dev/null
@@ -1,7 +0,0 @@
-package net.unnamed.utils.common.ifce
-
-import net.minecraft.client.Minecraft
-
-trait MinecraftInstance {
-  val mc: Minecraft = Minecraft.getMinecraft
-}
diff --git a/src/minecraft/net/unnamed/utils/common/ifce/Toggleable.scala b/src/minecraft/net/unnamed/utils/common/ifce/Toggleable.scala
deleted file mode 100644
index ecaf034..0000000
--- a/src/minecraft/net/unnamed/utils/common/ifce/Toggleable.scala
+++ /dev/null
@@ -1,24 +0,0 @@
-package net.unnamed.utils.common.ifce
-
-trait Toggleable {
-  private var isActive: Boolean = false
-
-  def isOn: Boolean = isActive
-
-  protected def onToggle(): Unit = {}
-
-  protected def on(): Unit = {
-    if (!isActive)
-      toggle()
-  }
-
-  protected def off(): Unit = {
-    if (isActive)
-      toggle()
-  }
-
-  protected def toggle(): Unit = {
-    isActive = !isActive
-    onToggle()
-  }
-}
diff --git a/src/minecraft/net/unnamed/world/ClientSideWorld.scala b/src/minecraft/net/unnamed/world/ClientSideWorld.scala
deleted file mode 100644
index 3364161..0000000
--- a/src/minecraft/net/unnamed/world/ClientSideWorld.scala
+++ /dev/null
@@ -1,24 +0,0 @@
-package net.unnamed.world
-
-import net.minecraft.client.multiplayer.WorldClient
-import net.minecraft.entity.Entity
-import net.unnamed.utils.common.ifce.MinecraftInstance
-import net.unnamed.world.inputcontrol.Cameras
-
-class ClientSideWorld (val world: WorldClient) extends MinecraftInstance {
-
-  val cameras = new Cameras
-
-  val clientSideEntityIdBegin: Int = -10000000
-  var clientSideEntityId: Int = clientSideEntityIdBegin
-
-  // TODO: find other solution that is not so hacky
-  def addClientEntity(entity: Entity): Unit = {
-    mc.theWorld.addEntityToWorld(clientSideEntityId, entity)
-    clientSideEntityId -= 1
-  }
-
-  def isClientSideEntity(entity: Entity): Boolean = {
-    entity.getEntityId <= clientSideEntityIdBegin
-  }
-}
diff --git a/src/minecraft/net/unnamed/world/inputcontrol/CameraFixedOnEntity.scala b/src/minecraft/net/unnamed/world/inputcontrol/CameraFixedOnEntity.scala
deleted file mode 100644
index 83a2f10..0000000
--- a/src/minecraft/net/unnamed/world/inputcontrol/CameraFixedOnEntity.scala
+++ /dev/null
@@ -1,17 +0,0 @@
-package net.unnamed.world.inputcontrol
-
-import net.minecraft.client.Minecraft
-import net.minecraft.entity.Entity
-import net.minecraft.entity.player.EntityPlayer
-import net.unnamed.utils.common.ifce.{ClientInstance, MinecraftInstance}
-
-case class CameraFixedOnEntity(entity: Entity) extends EntityPlayer(Minecraft.getMinecraft.theWorld,
-Minecraft.getMinecraft.thePlayer.getGameProfile) with MinecraftInstance with ClientInstance {
-
-  override def onLivingUpdate(): Unit = {
-    super.onLivingUpdate()
-    setPosition(entity.posX, entity.posY, entity.posZ)
-  }
-
-  override def isSpectator: Boolean = true
-}
diff --git a/src/minecraft/net/unnamed/world/inputcontrol/Cameras.scala b/src/minecraft/net/unnamed/world/inputcontrol/Cameras.scala
deleted file mode 100644
index b755fac..0000000
--- a/src/minecraft/net/unnamed/world/inputcontrol/Cameras.scala
+++ /dev/null
@@ -1,25 +0,0 @@
-package net.unnamed.world.inputcontrol
-
-import net.minecraft.entity.Entity
-import net.unnamed.utils.common.ifce.MinecraftInstance
-
-class Cameras extends MinecraftInstance {
-  var cameras: List[Entity] = Nil
-
-  var activeCamera: Option[Entity] = None
-
-  def setActiveCamera(entity: Option[Entity]): Unit = {
-    if (entity.isDefined) {
-      cameras ::= entity.get
-      mc.entityRenderer.loadEntityShader(entity.get)
-    }
-    activeCamera = entity
-  }
-
-  def getPlayerOrSupposedToBeViewEntity: Entity = {
-    if (activeCamera.isDefined)
-      mc.thePlayer
-    else
-      this.mc.getRenderViewEntity
-  }
-}
diff --git a/src/minecraft/net/unnamed/world/inputcontrol/FreeCamera.scala b/src/minecraft/net/unnamed/world/inputcontrol/FreeCamera.scala
deleted file mode 100644
index 9c063d7..0000000
--- a/src/minecraft/net/unnamed/world/inputcontrol/FreeCamera.scala
+++ /dev/null
@@ -1,67 +0,0 @@
-package net.unnamed.world.inputcontrol
-
-import net.minecraft.client.Minecraft
-import net.minecraft.entity.player.EntityPlayer
-import net.minecraft.util.MovementInputFromOptions
-import net.unnamed.Unnamed
-import net.unnamed.utils.common.ifce.{ClientInstance, MinecraftInstance}
-
-class FreeCamera
-  extends EntityPlayer(Minecraft.getMinecraft.theWorld,
-    Minecraft.getMinecraft.thePlayer.getGameProfile) with MinecraftInstance with ClientInstance {
-
-  {
-    clonePlayer(mc.thePlayer, true)
-    copyLocationAndAnglesFrom(mc.thePlayer)
-
-    Unnamed.clientSideWorld.get.addClientEntity(this)
-
-    capabilities.isFlying = true
-
-  }
-
-  /**
-   * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
-   * use this to react to sunlight and start to burn.
-   */
-  override def onLivingUpdate(): Unit = {
-    moveFlying(moveStrafing, moveForward, 0.1F)
-    moveEntity(motionX, motionY, motionZ)
-    motionX *= .8
-    motionY *= .8
-    motionZ *= .8
-  }
-
-  /**
-   * Returns whether the entity is in a server world
-   */
-
-
-  override def moveFlying(strafe: Float, forward: Float, friction: Float): Unit = {
-
-    var inputStrafe = strafe
-    var inputForward = forward
-
-    if (clientSideWorld.cameras.activeCamera.isDefined && clientSideWorld.cameras.activeCamera.get == this) {
-      val inputControl = new MovementInputFromOptions(mc.gameSettings)
-      inputControl.updatePlayerMoveState()
-
-      inputStrafe = inputControl.moveStrafe
-      inputForward = inputControl.moveForward
-
-
-      if (inputControl.sneak)
-        motionY -= capabilities.getFlySpeed / 2
-
-      if (inputControl.jump)
-        motionY += capabilities.getFlySpeed / 2
-    }
-
-    super.moveFlying(inputStrafe, inputForward, capabilities.getFlySpeed)
-  }
-
-  /**
-   * Returns true if the player is in spectator mode.
-   */
-  override def isSpectator: Boolean = true
-}
diff --git a/src/minecraft/net/unnamed/world/inputcontrol/PlayerMovementControl.scala b/src/minecraft/net/unnamed/world/inputcontrol/PlayerMovementControl.scala
deleted file mode 100644
index cce4d29..0000000
--- a/src/minecraft/net/unnamed/world/inputcontrol/PlayerMovementControl.scala
+++ /dev/null
@@ -1,24 +0,0 @@
-package net.unnamed.world.inputcontrol
-
-import net.minecraft.client.settings.GameSettings
-import net.minecraft.util.MovementInputFromOptions
-import net.unnamed.Unnamed
-import net.unnamed.world.schedule.Scheduler
-
-class PlayerMovementControl(val gameSettings: GameSettings) extends MovementInputFromOptions(gameSettings) {
-
-  override def updatePlayerMoveState(): Unit = {
-    if (Scheduler.isPlayerControlledByScheduler) {
-      val movementInput = Scheduler.getPlayerMovementInput
-      moveForward = movementInput.moveForward
-      moveStrafe = movementInput.moveStrafe
-      jump = movementInput.jump
-      sneak = movementInput.sneak
-      return
-    }
-    else if (Unnamed.clientSideWorld.get.cameras.activeCamera.isDefined)
-      return
-
-    super.updatePlayerMoveState()
-  }
-}
diff --git a/src/minecraft/net/unnamed/world/schedule/Scheduler.scala b/src/minecraft/net/unnamed/world/schedule/Scheduler.scala
deleted file mode 100644
index 10ae628..0000000
--- a/src/minecraft/net/unnamed/world/schedule/Scheduler.scala
+++ /dev/null
@@ -1,21 +0,0 @@
-package net.unnamed.world.schedule
-
-import net.minecraft.util.MovementInput
-import net.unnamed.utils.Rotation
-
-
-object Scheduler {
-
-
-  def isPlayerControlledByScheduler: Boolean = {
-    false
-  }
-
-  def getPlayerMovementInput: MovementInput = {
-    new MovementInput()
-  }
-
-  def getPlayerRotation: Rotation = {
-    Rotation.apply(0, 0)
-  }
-}
